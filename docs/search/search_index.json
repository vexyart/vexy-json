{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vexy JSON Documentation","text":"<p>A forgiving JSON parser that handles real-world JSON with comments, trailing commas, unquoted keys, and more.</p>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"#try-it-now","title":"Try It Now","text":"<ul> <li>Interactive Demo - Test Vexy JSON in your browser with WASM</li> <li>Legacy Tool - Previous version of the web tool</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Rust\ncargo add vexy-json\n\n# Python\npip install vexy-json\n\n# CLI\ncargo install vexy-json\n</code></pre>"},{"location":"#quick-start-rust","title":"Quick Start (Rust)","text":"<pre><code>use vexy_json::parse;\n\nfn main() {\n    let data = r#\"{ key: 1, /* comment */ arr: [1,2,3,], hex: 0x10 }\"#;\n    let value = parse(data).unwrap();\n    println!(\"{:?}\", value);\n}\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":""},{"location":"#for-users","title":"For Users","text":"<p>\ud83d\udcd6 User Documentation - Complete user guide including: - Installation and getting started - API documentation for all languages - How-to guides and examples - Troubleshooting and reference</p>"},{"location":"#for-developers","title":"For Developers","text":"<p>\ud83d\udd27 Developer Documentation - For contributors and extension developers: - Contributing guidelines and setup - Architecture and internals - Plugin development - Build, test, and release processes</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":""},{"location":"#comments-support","title":"\ud83d\udcac Comments Support","text":"<pre><code>{\n    // Single-line comments\n    \"name\": \"example\",\n    /* Multi-line\n       comments */ \n    \"value\": 42\n}\n</code></pre>"},{"location":"#unquoted-keys","title":"\ud83c\udff7\ufe0f Unquoted Keys","text":"<pre><code>{\n    name: \"No quotes needed\",\n    version: 1.0,\n    active: true\n}\n</code></pre>"},{"location":"#trailing-commas","title":"\u2795 Trailing Commas","text":"<pre><code>{\n    \"items\": [\n        \"first\",\n        \"second\",  // &lt;- This comma is OK\n    ],\n    \"done\": true,  // &lt;- And this one too\n}\n</code></pre>"},{"location":"#error-recovery","title":"\ud83d\udd27 Error Recovery","text":"<pre><code>{\n    \"broken\": \"json,\n    \"gets\": \"fixed automatically\"\n}\n</code></pre>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>Configuration Files - More readable config with comments</li> <li>API Development - Forgiving parsing for client-side JSON</li> <li>Data Migration - Repair malformed JSON data</li> <li>Developer Tools - Build JSON editors and validators</li> <li>Log Processing - Handle JSON logs with comments</li> </ul>"},{"location":"#performance","title":"\ud83c\udf1f Performance","text":"<p>Vexy JSON is designed for both correctness and speed:</p> <ul> <li>\u26a1 Fast parsing - Competitive with standard JSON parsers</li> <li>\ud83e\udde0 Smart recovery - Fixes common JSON errors automatically  </li> <li>\ud83c\udf10 Multi-platform - Rust, Python, WebAssembly, and C/C++ bindings</li> <li>\ud83d\udd12 Memory safe - Built in Rust with comprehensive error handling</li> </ul>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>GitHub Repository - Source code and issues</li> <li>Crates.io - Rust package</li> <li>PyPI - Python package</li> <li>NPM - WebAssembly package</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>Licensed under either of: - Apache License, Version 2.0 - MIT License</p> <p>at your option.</p>"},{"location":"dev/","title":"Developer Documentation","text":"<p>Welcome to the Vexy JSON developer documentation! This section is for contributors, plugin developers, and anyone wanting to understand the internals.</p>"},{"location":"dev/#getting-started","title":"\ud83d\ude80 Getting Started","text":"<ul> <li>Contributing Guide - How to contribute to the project</li> <li>Development Setup - Set up your development environment</li> <li>Build Process - Building and testing the project</li> </ul>"},{"location":"dev/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<ul> <li>Architecture Overview - High-level system design</li> <li>Parser Implementation - How the parser works</li> <li>Error Recovery - Error handling and repair mechanisms</li> <li>WASM Integration - WebAssembly compilation details</li> </ul>"},{"location":"dev/#extension-development","title":"\ud83d\udd27 Extension Development","text":"<ul> <li>Plugin Development - Creating plugins for Vexy JSON</li> <li>Plugin Registry - Available plugins and extensions</li> <li>Custom Parsers - Extending parsing capabilities</li> </ul>"},{"location":"dev/#release-deployment","title":"\ud83d\ude80 Release &amp; Deployment","text":"<ul> <li>Release Process - Release procedures and guidelines</li> <li>Packaging - Platform-specific packaging</li> <li>macOS Packaging</li> <li>Windows Packaging</li> <li>Linux Packaging</li> </ul>"},{"location":"dev/#testing-performance","title":"\ud83d\udcca Testing &amp; Performance","text":"<ul> <li>Testing Strategy - Testing approach and guidelines</li> <li>Benchmarks - Performance comparisons and benchmarks</li> <li>Profiling - Performance analysis tools</li> </ul>"},{"location":"dev/#debugging-troubleshooting","title":"\ud83d\udd0d Debugging &amp; Troubleshooting","text":"<ul> <li>Debug Tools - Available debugging utilities</li> <li>Common Issues - Developer-specific issues</li> <li>Performance Debugging - Optimizing performance</li> </ul>"},{"location":"dev/#internal-documentation","title":"\ud83d\udccb Internal Documentation","text":"<p>For project maintainers: - Internal Docs - Planning documents and internal tools - Release Planning - Current development roadmap - TODO List - Outstanding tasks</p>"},{"location":"dev/benchmarks/","title":"Benchmark Results","text":"<p>This section presents the parsing performance benchmarks for <code>vexy_json</code> (Rust). Benchmarks were run on the following environment:</p> <ul> <li>CPU: [e.g., Intel Core i7-10700K]</li> <li>RAM: [e.g., 32GB DDR4]</li> <li>OS: [e.g., macOS 14.5 Sonoma]</li> <li>Rust Toolchain: [e.g., <code>rustc 1.79.0 (129f3b996 2024-06-10)</code>]</li> </ul> <p>Lower values (nanoseconds per iteration) are better.</p> Test Case <code>vexy_json</code> (ns/iter) simple 7782 array 7836 nested 41319 large_array 299726294 deeply_nested 3370 forgiving 15867 config 142978 <p>Note: <code>ns/iter</code> means nanoseconds per iteration. The results above are examples and may vary depending on your hardware and software environment.</p>"},{"location":"dev/benchmarks/#how-to-run-benchmarks","title":"How to Run Benchmarks","text":"<p>Benchmarks are implemented using <code>criterion.rs</code>. You can run them locally using the following command:</p> <pre><code>cargo bench\n</code></pre> <p>The benchmark definitions are located in the <code>benches/</code> directory, with data files in <code>benches/data/</code>.</p>"},{"location":"dev/build-process/","title":"Build Status Dashboard","text":"<p>This page provides an overview of the current build status and health metrics for the vexy_json project.</p>"},{"location":"dev/build-process/#continuous-integration-status","title":"Continuous Integration Status","text":""},{"location":"dev/build-process/#primary-workflows","title":"Primary Workflows","text":"Workflow Status Description WASM Build Builds WebAssembly module and deploys to GitHub Pages Security Audit Checks for security vulnerabilities in dependencies Release Automated release process for tagged versions"},{"location":"dev/build-process/#package-registries","title":"Package Registries","text":"Registry Version Downloads crates.io docs.rs - npm"},{"location":"dev/build-process/#code-quality-metrics","title":"Code Quality Metrics","text":""},{"location":"dev/build-process/#test-coverage","title":"Test Coverage","text":"<ul> <li>Core Tests: 37/39 tests passing (94.9% success rate)</li> <li>Basic Tests: 7/7 tests passing (100%)</li> <li>Comma Handling: 9/9 tests passing (100%)</li> <li>Comment Handling: 8/8 tests passing (100%)</li> <li>Error Handling: 13/15 tests passing (86.7%)</li> <li>Comprehensive Test Suite: 1400+ test cases covering real-world scenarios</li> <li>WASM Tests: Automated browser testing in CI/CD pipeline</li> </ul>"},{"location":"dev/build-process/#performance-benchmarks","title":"Performance Benchmarks","text":"<ul> <li>Parse Time: ~0.05ms for typical JSON documents</li> <li>Bundle Size: 168KB (WebAssembly module)</li> <li>Memory Usage: Linear scaling with input size</li> </ul>"},{"location":"dev/build-process/#dependency-management","title":"Dependency Management","text":""},{"location":"dev/build-process/#automated-updates","title":"Automated Updates","text":"<ul> <li>Dependabot: Configured for weekly Rust and GitHub Actions updates</li> <li>Security Audits: Automated daily scans for vulnerabilities</li> <li>License Compliance: Automated checks for incompatible licenses</li> </ul>"},{"location":"dev/build-process/#current-dependencies","title":"Current Dependencies","text":"<ul> <li>Runtime: Minimal dependencies (thiserror, serde_json, optional serde)</li> <li>Development: Standard Rust toolchain + wasm-pack</li> <li>CI/CD: GitHub Actions with caching for faster builds</li> </ul>"},{"location":"dev/build-process/#deployment-status","title":"Deployment Status","text":""},{"location":"dev/build-process/#live-deployments","title":"Live Deployments","text":"<ul> <li>Vexy JSON Tool: https://twardoch.github.io/vexy-json/vexy-json-tool/</li> <li>Vexy JSON Tool: https://twardoch.github.io/vexy_json/vexy-json-tool/</li> <li>Tools Overview: https://twardoch.github.io/vexy_json/tools/</li> <li>Documentation: https://docs.rs/vexy_json</li> <li>GitHub Pages: Automatically deployed on main branch updates</li> </ul>"},{"location":"dev/build-process/#release-artifacts","title":"Release Artifacts","text":"<ul> <li>Binary Releases: Available for Linux, macOS, and Windows</li> <li>macOS Package: .dmg with .pkg installer</li> <li>WebAssembly: Standalone module and npm package</li> <li>Source: Available on GitHub and crates.io</li> </ul>"},{"location":"dev/build-process/#monitoring-and-alerts","title":"Monitoring and Alerts","text":""},{"location":"dev/build-process/#automated-checks","title":"Automated Checks","text":"<ol> <li>Build Status: All CI/CD workflows monitored</li> <li>Security Vulnerabilities: Daily automated scans</li> <li>Dependency Updates: Weekly automated PRs</li> <li>Performance Regression: Benchmarks run on each PR</li> </ol>"},{"location":"dev/build-process/#manual-checks","title":"Manual Checks","text":"<ul> <li>Cross-browser compatibility testing</li> <li>Mobile device testing</li> <li>Performance profiling</li> <li>User feedback monitoring</li> </ul>"},{"location":"dev/build-process/#maintenance-schedule","title":"Maintenance Schedule","text":""},{"location":"dev/build-process/#regular-tasks","title":"Regular Tasks","text":"<ul> <li>Weekly: Dependency updates review</li> <li>Monthly: Performance benchmark analysis</li> <li>Quarterly: Security audit review</li> <li>As Needed: Bug fixes and feature updates</li> </ul>"},{"location":"dev/build-process/#contact","title":"Contact","text":"<p>For build failures or urgent issues, please create an issue on GitHub.</p>"},{"location":"dev/contributing/","title":"Contributing to vexy_json","text":"<p>We welcome contributions to <code>vexy_json</code>! Whether it's bug reports, feature requests, documentation improvements, or code contributions, your help is greatly appreciated.</p>"},{"location":"dev/contributing/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Fork the Repository: Start by forking the <code>vexy_json</code> repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine:     <pre><code>git clone https://github.com/your-username/vexy_json.git\ncd vexy_json\n</code></pre></li> <li>Create a New Branch: Create a new branch for your feature or bug fix:     <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b bugfix/fix-description\n</code></pre></li> <li>Make Your Changes: Implement your changes. Ensure your code adheres to the existing style and conventions.</li> <li>Test Your Changes: Run the test suite to ensure your changes haven't introduced any regressions and that new features are adequately covered.     <pre><code>cargo test --all-features\n</code></pre></li> <li>Format and Lint: Ensure your code is properly formatted and passes lint checks.     <pre><code>cargo fmt\ncargo clippy --all-targets --all-features\n</code></pre></li> <li>Commit Your Changes: Write clear and concise commit messages.     <pre><code>git commit -m \"feat: Add new feature X\" # or \"fix: Resolve bug Y\"\n</code></pre></li> <li>Push to Your Fork: Push your changes to your GitHub fork.     <pre><code>git push origin feature/your-feature-name\n</code></pre></li> <li>Create a Pull Request: Open a pull request from your fork to the <code>main</code> branch of the <code>vexy_json</code> repository. Provide a detailed description of your changes.</li> </ol>"},{"location":"dev/contributing/#code-style-and-conventions","title":"Code Style and Conventions","text":"<ul> <li>Follow Rust's official style guidelines (enforced by <code>rustfmt</code>).</li> <li>Use <code>clippy</code> to catch common mistakes and improve code quality.</li> <li>Write clear and concise code comments and documentation where necessary.</li> <li>Ensure new features have corresponding tests.</li> </ul>"},{"location":"dev/contributing/#extending-the-web-tool","title":"Extending the Web Tool","text":"<p>If you're looking to contribute specifically to the <code>vexy_json</code> web tool, please refer to the Developer Guide for Extending the Web Tool for detailed information on its structure, build process, and development considerations.</p>"},{"location":"dev/contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug, please open an issue on the GitHub Issues page. When reporting a bug, please include:</p> <ul> <li>A clear and concise description of the bug.</li> <li>Steps to reproduce the behavior.</li> <li>Expected behavior.</li> <li>Actual behavior.</li> <li>Any relevant error messages or stack traces.</li> <li>Your Rust version (<code>rustc --version</code>).</li> </ul>"},{"location":"dev/contributing/#feature-requests","title":"Feature Requests","text":"<p>Have an idea for a new feature? Open an issue on the GitHub Issues page to discuss it. Describe the feature, why you think it would be valuable, and any potential implementation details.</p> <p>Thank you for contributing to <code>vexy_json</code>!</p>"},{"location":"dev/design/","title":"Design","text":"<p>This section contains design documents and architectural decisions for the vexy_json project.</p>"},{"location":"dev/design/#topics","title":"Topics","text":"<ul> <li>Python API Design - Design for Python bindings using PyO3</li> </ul>"},{"location":"dev/developer-guide/","title":"Developer Guide for Extending the vexy_json Web Tool","text":"<p>This guide is for developers who want to contribute to or extend the <code>vexy_json</code> web tool. It covers the project structure, build process, and key development considerations.</p>"},{"location":"dev/developer-guide/#project-structure","title":"Project Structure","text":"<p>The <code>vexy_json</code> project uses a multi-crate Cargo workspace structure with Jekyll integration for web tools.</p>"},{"location":"dev/developer-guide/#workspace-structure","title":"Workspace Structure","text":"<ul> <li>Root: Multi-crate workspace with <code>Cargo.toml</code> defining members</li> <li><code>crates/core</code>: Core parsing functionality and AST types</li> <li><code>crates/cli</code>: Command-line interface binary</li> <li><code>crates/wasm</code>: WebAssembly bindings for browser use</li> <li><code>crates/serde</code>: Serde integration for serialization support</li> <li><code>crates/test-utils</code>: Shared testing utilities</li> </ul>"},{"location":"dev/developer-guide/#web-tools-structure","title":"Web Tools Structure","text":"<ul> <li><code>docs/</code>: The root directory for the GitHub Pages site.<ul> <li><code>_config.yml</code>: Jekyll configuration file.</li> <li><code>tool.html</code>: Vexy JSON interactive tool (WebAssembly-powered)</li> <li><code>the reference implementation.html</code>: Jsonic interactive tool (CDN-powered)</li> <li><code>vexy-json-tool.md</code>: Jekyll wrapper for Vexy JSON tool</li> <li><code>vexy-json-tool.md</code>: Jekyll wrapper for Jsonic tool</li> <li><code>tool.md</code>: Tools overview page</li> <li><code>assets/</code>: Static assets for the web tools.<ul> <li><code>css/</code>: CSS files, including <code>tool.css</code> and <code>enhanced-features.css</code>.</li> <li><code>js/</code>: JavaScript files for both tools</li> </ul> </li> <li><code>pkg/</code>: Contains the compiled WebAssembly module (<code>vexy_json_bg.wasm</code>, <code>vexy_json.js</code>, <code>vexy_json.d.ts</code>).</li> </ul> </li> </ul>"},{"location":"dev/developer-guide/#development-environment-setup","title":"Development Environment Setup","text":"<p>To set up your development environment, you'll need:</p> <ol> <li>Rust and Cargo: Follow the official Rust installation guide.</li> <li><code>wasm-pack</code>: Install with <code>cargo install wasm-pack</code>.</li> <li>Node.js and npm: For managing JavaScript dependencies and running Jekyll.</li> <li>Ruby and Bundler: For Jekyll. Follow the Jekyll installation guide.</li> </ol>"},{"location":"dev/developer-guide/#build-process","title":"Build Process","text":"<ol> <li> <p>Build All Crates: Navigate to the project root and run:     <pre><code>./build.sh\n</code></pre>     This script handles formatting, linting, building, and testing all workspace crates.</p> </li> <li> <p>Build WebAssembly: For WASM specifically:     <pre><code>cd crates/wasm\nwasm-pack build --target web --out-dir ../../docs/pkg\n</code></pre></p> </li> <li> <p>Build Jekyll Site: Navigate to the <code>docs/</code> directory and run:     <pre><code>bundle install # First time setup\nbundle exec jekyll build\n</code></pre>     Or to serve locally for development:     <pre><code>bundle exec jekyll serve\n</code></pre>     The web tool will be accessible at <code>http://localhost:4000/tool.html</code> (or similar, depending on your Jekyll configuration).</p> </li> </ol>"},{"location":"dev/developer-guide/#key-development-areas","title":"Key Development Areas","text":""},{"location":"dev/developer-guide/#rust-webassembly-bindings-srcwasmrs","title":"Rust WebAssembly Bindings (<code>src/wasm.rs</code>)","text":"<p>This file exposes Rust functions to JavaScript using <code>#[wasm_bindgen]</code>. When adding new functionality from the Rust core to the web tool, you'll modify this file.</p> <ul> <li><code>#[wasm_bindgen]</code>: This macro handles the FFI (Foreign Function Interface) between Rust and JavaScript.</li> <li>Error Handling: Rust <code>Result</code> types are automatically converted to JavaScript exceptions. Ensure your Rust code handles errors gracefully.</li> <li>Data Conversion: <code>wasm_bindgen</code> handles conversion of basic types (strings, numbers, booleans, arrays, objects) between Rust and JavaScript. For complex types, you might need custom serialization/deserialization logic (e.g., using <code>serde</code> with <code>wasm-bindgen-serde</code>).</li> </ul>"},{"location":"dev/developer-guide/#javascript-logic-docsassetsjstooljs","title":"JavaScript Logic (<code>docs/assets/js/tool.js</code>)","text":"<p>This is the main JavaScript file for the web tool. It handles UI interactions, calls the WASM functions, and updates the display.</p> <ul> <li>WASM Module Import: The <code>pkg/vexy_json_wasm.js</code> module (generated by <code>wasm-pack</code>) is imported here.</li> <li>Asynchronous Operations: WASM module loading and initialization are asynchronous. Ensure you <code>await</code> the <code>init()</code> function.</li> <li>UI Updates: Use standard DOM manipulation to update the input/output areas, error messages, and other UI elements.</li> <li>Event Listeners: Attach event listeners to buttons, toggles, and text areas to respond to user actions.</li> </ul>"},{"location":"dev/developer-guide/#examples-docsassetsjsexamplesjs","title":"Examples (<code>docs/assets/js/examples.js</code>)","text":"<p>This file contains the data for the pre-loaded examples. To add new examples:</p> <ol> <li>Define a new object in the <code>EXAMPLES</code> array with <code>category</code>, <code>name</code>, <code>input</code>, and <code>options</code> (if custom parser options are needed).</li> <li>Ensure the <code>category</code> is consistent with existing categories or add a new one if appropriate.</li> </ol>"},{"location":"dev/developer-guide/#styling-docsassetscsstoolcss-enhanced-featurescss","title":"Styling (<code>docs/assets/css/tool.css</code>, <code>enhanced-features.css</code>)","text":"<p>These CSS files define the visual appearance of the web tool. <code>tool.css</code> contains core styles, while <code>enhanced-features.css</code> handles specific styling for features like error highlighting.</p>"},{"location":"dev/developer-guide/#jekyll-integration","title":"Jekyll Integration","text":"<p>The web tool is part of a Jekyll static site. Key considerations:</p> <ul> <li>Front Matter: Each Markdown or HTML page uses YAML front matter to define layout, title, and navigation order.</li> <li>Includes: Jekyll allows reusing content snippets via <code>_includes/</code>.</li> <li>Static Files: Ensure all assets (JS, CSS, WASM files) are correctly placed and referenced so Jekyll copies them to the <code>_site</code> directory.</li> </ul>"},{"location":"dev/developer-guide/#testing","title":"Testing","text":"<p>After making changes, always:</p> <ol> <li>Rebuild WASM: Run <code>./build-wasm.sh</code>.</li> <li>Rebuild/Serve Jekyll: Run <code>bundle exec jekyll build</code> or <code>bundle exec jekyll serve</code>.</li> <li>Test in Browser: Open the <code>tool.html</code> page in your browser and thoroughly test all functionalities, especially those you've modified.</li> </ol>"},{"location":"dev/developer-guide/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please refer to the main Contributing Guide for general contribution guidelines, including how to submit pull requests and code style conventions.</p>"},{"location":"dev/development/","title":"Development","text":"<p>This section contains documentation for developers working on the vexy_json project.</p>"},{"location":"dev/development/#topics","title":"Topics","text":"<ul> <li>Refactor Plan - Comprehensive refactoring roadmap</li> <li>Lean Minimalization - Reducing codebase to minimal core</li> <li>Implementation Summary - WebAssembly &amp; feature verification</li> <li>Distribution Builds - Building platform-specific packages</li> </ul>"},{"location":"dev/feedback/","title":"Feedback &amp; Support","text":"<p>We value your feedback and are committed to improving vexy_json based on user experiences. This page explains how to report issues, request features, and get support.</p>"},{"location":"dev/feedback/#web-tool-feedback","title":"\ud83d\udd27 Web Tool Feedback","text":"<p>The vexy_json web tool includes a built-in feedback system that makes it easy to report issues and suggest improvements.</p>"},{"location":"dev/feedback/#how-to-use-the-feedback-system","title":"How to Use the Feedback System","text":"<ol> <li>Click the feedback button - Look for the floating feedback button in the bottom-right corner of the web tool</li> <li>Choose feedback type - Select from:</li> <li>\ud83d\udc1b Bug Report - Something isn't working correctly</li> <li>\u2728 Feature Request - Suggest new functionality</li> <li>\ud83d\udd27 Improvement Suggestion - Ideas for enhancements</li> <li>\ud83d\udcac General Feedback - Any other comments</li> <li>\u26a1 Performance Issue - Slow parsing or loading</li> <li> <p>\ud83c\udfa8 UI/UX Feedback - Interface improvements</p> </li> <li> <p>Fill out the form - Provide a clear subject and detailed description</p> </li> <li>Include context - Optionally include browser/system information and current tool state</li> <li>Submit - The system will create a GitHub issue template for you</li> </ol>"},{"location":"dev/feedback/#what-information-is-collected","title":"What Information is Collected","text":"<p>The feedback system respects your privacy and only collects:</p> <ul> <li>Required: Feedback type, subject, and description</li> <li>Optional: Email address (for follow-up)</li> <li>Optional: Browser/system information (helps debug issues)</li> <li>Optional: Current tool state (parser options, input sample)</li> </ul>"},{"location":"dev/feedback/#rate-limits","title":"Rate Limits","text":"<p>To prevent spam, the feedback system limits submissions to 5 per day per browser.</p>"},{"location":"dev/feedback/#github-issues","title":"\ud83d\udccb GitHub Issues","text":"<p>For detailed bug reports and feature requests, use our GitHub Issues:</p>"},{"location":"dev/feedback/#bug-reports","title":"Bug Reports","text":"<p>Use the Bug Report Template and include:</p> <ul> <li>Clear description of the bug</li> <li>Steps to reproduce the issue</li> <li>Expected behavior vs actual behavior</li> <li>Input sample that causes the problem</li> <li>Environment details (OS, browser, version)</li> <li>Parser options that were enabled</li> <li>Error messages if any</li> </ul>"},{"location":"dev/feedback/#feature-requests","title":"Feature Requests","text":"<p>Use the Feature Request Template and include:</p> <ul> <li>Problem description - What need does this address?</li> <li>Proposed solution - What would you like to see?</li> <li>Use case - How would you use this feature?</li> <li>Example input/output - Show what it would look like</li> <li>Priority level - How important is this to you?</li> </ul>"},{"location":"dev/feedback/#performance-issues","title":"Performance Issues","text":"<p>Use the Performance Issue Template and include:</p> <ul> <li>Performance problem description</li> <li>Input characteristics (size, complexity)</li> <li>Measurements (timing, memory usage)</li> <li>Environment details (hardware, browser)</li> <li>Comparison with other parsers if available</li> </ul>"},{"location":"dev/feedback/#community-discussion","title":"\ud83d\udcac Community Discussion","text":"<p>For questions, ideas, and general discussion, use GitHub Discussions:</p> <ul> <li>Q&amp;A - Ask questions about usage</li> <li>Ideas - Share feature ideas and get feedback</li> <li>Show and Tell - Share how you're using vexy_json</li> <li>General - Any other discussion</li> </ul>"},{"location":"dev/feedback/#direct-contact","title":"\ud83d\udce7 Direct Contact","text":"<p>For security issues or private matters, you can contact the maintainer directly:</p> <ul> <li>Email: adam+vexy-json@twardoch.com</li> <li>Security: Please use responsible disclosure for security issues</li> </ul>"},{"location":"dev/feedback/#what-makes-good-feedback","title":"\ud83c\udfaf What Makes Good Feedback","text":""},{"location":"dev/feedback/#for-bug-reports","title":"For Bug Reports","text":"<ul> <li>Reproducible steps - Can others follow your steps and see the issue?</li> <li>Minimal example - The smallest input that demonstrates the problem</li> <li>Clear expectations - What should happen vs what actually happens</li> <li>Environment details - Help us understand your setup</li> </ul>"},{"location":"dev/feedback/#for-feature-requests","title":"For Feature Requests","text":"<ul> <li>Real use case - Why do you need this feature?</li> <li>Clear specification - What exactly should it do?</li> <li>Compatibility - How should it work with existing features?</li> <li>Examples - Show input/output examples</li> </ul>"},{"location":"dev/feedback/#for-performance-issues","title":"For Performance Issues","text":"<ul> <li>Specific measurements - Actual timing and memory usage</li> <li>Input characteristics - Size and complexity details</li> <li>Environment details - Hardware and software specifications</li> <li>Comparison baseline - How does it compare to expectations?</li> </ul>"},{"location":"dev/feedback/#feedback-process","title":"\ud83d\udd04 Feedback Process","text":"<ol> <li>Submission - You submit feedback through any channel</li> <li>Triage - We review and categorize the feedback</li> <li>Discussion - We may ask follow-up questions</li> <li>Implementation - Valid issues/features are added to roadmap</li> <li>Testing - Changes are tested thoroughly</li> <li>Release - Improvements are released in new versions</li> <li>Follow-up - We'll let you know when your feedback is addressed</li> </ol>"},{"location":"dev/feedback/#contributing","title":"\ud83d\ude80 Contributing","text":"<p>Want to contribute code? See our Contributing Guide for:</p> <ul> <li>Development setup</li> <li>Code style guidelines</li> <li>Testing requirements</li> <li>Pull request process</li> </ul>"},{"location":"dev/feedback/#feedback-statistics","title":"\ud83d\udcca Feedback Statistics","text":"<p>The feedback system tracks anonymous usage statistics to help us improve:</p> <ul> <li>Number of feedback submissions by type</li> <li>Most common issues and requests</li> <li>Response times and resolution rates</li> <li>User satisfaction trends</li> </ul> <p>All statistics are aggregated and anonymized to protect privacy.</p>"},{"location":"dev/feedback/#response-times","title":"\u2705 Response Times","text":"<p>We aim to respond to feedback within:</p> <ul> <li>Critical bugs: 24 hours</li> <li>Bug reports: 3-5 days</li> <li>Feature requests: 1-2 weeks</li> <li>General questions: 3-5 days</li> </ul> <p>Response times may vary based on complexity and maintainer availability.</p> <p>Thank you for helping make vexy_json better! Your feedback drives improvements and helps us build a tool that works well for everyone.</p>"},{"location":"dev/packaging-macos/","title":"macOS Packaging Guide","text":"<p>This guide explains how to package vexy_json for macOS distribution as a <code>.dmg</code> containing a <code>.pkg</code> installer.</p>"},{"location":"dev/packaging-macos/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS development environment</li> <li>Xcode Command Line Tools installed</li> <li>Rust toolchain installed</li> <li>Valid code signing certificate (optional, for signed packages)</li> </ul>"},{"location":"dev/packaging-macos/#building-the-package","title":"Building the Package","text":"<p>Run the packaging script from the project root:</p> <pre><code>./scripts/package-macos.sh\n</code></pre> <p>This script will: 1. Build the release binary using <code>cargo build --release</code> 2. Create a <code>.pkg</code> installer that installs vexy_json to <code>/usr/local/bin</code> 3. Wrap the <code>.pkg</code> in a <code>.dmg</code> for easy distribution</p>"},{"location":"dev/packaging-macos/#output","title":"Output","text":"<p>The script produces: - <code>vexy_json-{VERSION}-macos.dmg</code> - The distributable disk image - Contains the <code>.pkg</code> installer and a README</p>"},{"location":"dev/packaging-macos/#installation","title":"Installation","text":"<p>Users can install vexy_json by: 1. Opening the <code>.dmg</code> file 2. Double-clicking the <code>.pkg</code> installer 3. Following the installation wizard 4. The <code>vexy_json</code> command will be available in their terminal</p>"},{"location":"dev/packaging-macos/#code-signing-optional","title":"Code Signing (Optional)","text":"<p>To sign the package for distribution outside the App Store:</p> <pre><code># Sign the package\nproductsign --sign \"Developer ID Installer: Your Name (TEAMID)\" \\\n    unsigned.pkg signed.pkg\n\n# Sign the DMG\ncodesign --sign \"Developer ID Application: Your Name (TEAMID)\" \\\n    --timestamp vexy_json-*.dmg\n</code></pre>"},{"location":"dev/packaging-macos/#notarization-recommended","title":"Notarization (Recommended)","text":"<p>For macOS 10.15+ distribution, notarize the DMG:</p> <pre><code># Submit for notarization\nxcrun altool --notarize-app \\\n    --primary-bundle-id \"com.twardoch.vexy_json\" \\\n    --username \"your-apple-id@example.com\" \\\n    --password \"@keychain:AC_PASSWORD\" \\\n    --file vexy_json-*.dmg\n\n# Staple the notarization ticket\nxcrun stapler staple vexy_json-*.dmg\n</code></pre>"},{"location":"dev/packaging-macos/#automation","title":"Automation","text":"<p>This packaging process is automated in the GitHub Actions release workflow. See <code>.github/workflows/release.yml</code> for the CI/CD implementation.</p>"},{"location":"dev/plugin-development/","title":"Vexy JSON Plugin Development Guide","text":""},{"location":"dev/plugin-development/#introduction","title":"Introduction","text":"<p>This guide will walk you through creating custom plugins for the Vexy JSON parser. Plugins allow you to extend the parser's functionality with custom transformations, validations, and parsing logic.</p>"},{"location":"dev/plugin-development/#quick-start","title":"Quick Start","text":"<p>Let's create a simple plugin that converts all string values to uppercase:</p> <pre><code>use vexy_json_core::plugin::ParserPlugin;\nuse vexy_json_core::ast::Value;\nuse vexy_json_core::error::Result;\nuse std::any::Any;\n\npub struct UppercasePlugin;\n\nimpl ParserPlugin for UppercasePlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"uppercase\"\n    }\n\n    fn transform_value(&amp;mut self, value: &amp;mut Value, _path: &amp;str) -&gt; Result&lt;()&gt; {\n        match value {\n            Value::String(s) =&gt; {\n                *s = s.to_uppercase();\n            }\n            Value::Object(obj) =&gt; {\n                for (_, val) in obj.iter_mut() {\n                    self.transform_value(val, _path)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for val in arr.iter_mut() {\n                    self.transform_value(val, _path)?;\n                }\n            }\n            _ =&gt; {}\n        }\n        Ok(())\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {\n        self\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#plugin-architecture","title":"Plugin Architecture","text":""},{"location":"dev/plugin-development/#plugin-trait","title":"Plugin Trait","text":"<p>The <code>ParserPlugin</code> trait defines the interface for all plugins:</p> <pre><code>pub trait ParserPlugin: Send + Sync {\n    fn name(&amp;self) -&gt; &amp;str;\n\n    // Lifecycle hooks\n    fn on_parse_start(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; { Ok(()) }\n    fn on_parse_end(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; { Ok(()) }\n\n    // Value transformation\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; { Ok(()) }\n\n    // Validation\n    fn validate(&amp;self, value: &amp;Value, path: &amp;str) -&gt; Result&lt;()&gt; { Ok(()) }\n\n    // Token-level hooks\n    fn on_string(&amp;mut self, value: &amp;str, path: &amp;str) -&gt; Result&lt;String&gt; { Ok(value.to_string()) }\n    fn on_number(&amp;mut self, value: &amp;str, path: &amp;str) -&gt; Result&lt;Value&gt; { \n        // Default implementation\n        Ok(Value::String(value.to_string()))\n    }\n    fn on_object_key(&amp;mut self, key: &amp;str, path: &amp;str) -&gt; Result&lt;()&gt; { Ok(()) }\n\n    // Type casting for downcasting\n    fn as_any(&amp;self) -&gt; &amp;dyn Any;\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any;\n}\n</code></pre>"},{"location":"dev/plugin-development/#plugin-execution-order","title":"Plugin Execution Order","text":"<p>Plugins are executed in the following order:</p> <ol> <li><code>on_parse_start</code>: Called before parsing begins</li> <li>Token-level hooks: Called during lexing/parsing</li> <li><code>on_string</code>: For string literals</li> <li><code>on_number</code>: For number literals</li> <li><code>on_object_key</code>: For object keys</li> <li><code>transform_value</code>: Called after parsing, traverses the AST</li> <li><code>validate</code>: Called after transformation</li> <li><code>on_parse_end</code>: Called after parsing completes</li> </ol>"},{"location":"dev/plugin-development/#advanced-plugin-examples","title":"Advanced Plugin Examples","text":""},{"location":"dev/plugin-development/#configuration-plugin","title":"Configuration Plugin","text":"<p>A plugin that processes configuration files with environment variable substitution:</p> <pre><code>use std::env;\nuse std::collections::HashMap;\nuse regex::Regex;\n\npub struct ConfigPlugin {\n    env_vars: HashMap&lt;String, String&gt;,\n    prefix: String,\n}\n\nimpl ConfigPlugin {\n    pub fn new(prefix: &amp;str) -&gt; Self {\n        let mut env_vars = HashMap::new();\n        for (key, value) in env::vars() {\n            if key.starts_with(prefix) {\n                env_vars.insert(key, value);\n            }\n        }\n\n        ConfigPlugin {\n            env_vars,\n            prefix: prefix.to_string(),\n        }\n    }\n\n    fn substitute_env_vars(&amp;self, s: &amp;str) -&gt; String {\n        let re = Regex::new(r\"\\$\\{([^}]+)\\}\").unwrap();\n        re.replace_all(s, |caps: &amp;regex::Captures| {\n            let var_name = &amp;caps[1];\n            self.env_vars.get(var_name)\n                .cloned()\n                .unwrap_or_else(|| format!(\"${{{}}}\", var_name))\n        }).into_owned()\n    }\n}\n\nimpl ParserPlugin for ConfigPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"config\"\n    }\n\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        match value {\n            Value::String(s) =&gt; {\n                *s = self.substitute_env_vars(s);\n            }\n            Value::Object(obj) =&gt; {\n                for (_, val) in obj.iter_mut() {\n                    self.transform_value(val, path)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for val in arr.iter_mut() {\n                    self.transform_value(val, path)?;\n                }\n            }\n            _ =&gt; {}\n        }\n        Ok(())\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {\n        self\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#data-validation-plugin","title":"Data Validation Plugin","text":"<p>A plugin that validates data against business rules:</p> <pre><code>use vexy_json_core::error::Error;\n\npub struct ValidationPlugin {\n    rules: Vec&lt;ValidationRule&gt;,\n}\n\npub struct ValidationRule {\n    pub path_pattern: String,\n    pub validator: Box&lt;dyn Fn(&amp;Value) -&gt; Result&lt;()&gt; + Send + Sync&gt;,\n}\n\nimpl ValidationPlugin {\n    pub fn new() -&gt; Self {\n        ValidationPlugin {\n            rules: Vec::new(),\n        }\n    }\n\n    pub fn add_rule&lt;F&gt;(&amp;mut self, path_pattern: &amp;str, validator: F) \n    where \n        F: Fn(&amp;Value) -&gt; Result&lt;()&gt; + Send + Sync + 'static \n    {\n        self.rules.push(ValidationRule {\n            path_pattern: path_pattern.to_string(),\n            validator: Box::new(validator),\n        });\n    }\n\n    fn matches_pattern(&amp;self, path: &amp;str, pattern: &amp;str) -&gt; bool {\n        // Simple glob-style matching\n        if pattern == \"*\" {\n            return true;\n        }\n\n        if pattern.ends_with(\"*\") {\n            let prefix = &amp;pattern[..pattern.len() - 1];\n            return path.starts_with(prefix);\n        }\n\n        path == pattern\n    }\n}\n\nimpl ParserPlugin for ValidationPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"validation\"\n    }\n\n    fn validate(&amp;self, value: &amp;Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        for rule in &amp;self.rules {\n            if self.matches_pattern(path, &amp;rule.path_pattern) {\n                (rule.validator)(value)?;\n            }\n        }\n\n        // Recurse into nested values\n        match value {\n            Value::Object(obj) =&gt; {\n                for (key, val) in obj {\n                    let child_path = format!(\"{}.{}\", path, key);\n                    self.validate(val, &amp;child_path)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for (i, val) in arr.iter().enumerate() {\n                    let child_path = format!(\"{}[{}]\", path, i);\n                    self.validate(val, &amp;child_path)?;\n                }\n            }\n            _ =&gt; {}\n        }\n\n        Ok(())\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {\n        self\n    }\n}\n\n// Usage example\nfn create_validation_plugin() -&gt; ValidationPlugin {\n    let mut plugin = ValidationPlugin::new();\n\n    // Validate that age is a positive number\n    plugin.add_rule(\"*.age\", |value| {\n        if let Value::Number(n) = value {\n            if n.as_f64() &lt; 0.0 {\n                return Err(Error::Custom(\"Age must be positive\".to_string()));\n            }\n        }\n        Ok(())\n    });\n\n    // Validate email format\n    plugin.add_rule(\"*.email\", |value| {\n        if let Value::String(s) = value {\n            if !s.contains('@') {\n                return Err(Error::Custom(\"Invalid email format\".to_string()));\n            }\n        }\n        Ok(())\n    });\n\n    plugin\n}\n</code></pre>"},{"location":"dev/plugin-development/#macro-expansion-plugin","title":"Macro Expansion Plugin","text":"<p>A plugin that expands custom macros in JSON:</p> <pre><code>use std::collections::HashMap;\n\npub struct MacroPlugin {\n    macros: HashMap&lt;String, Value&gt;,\n}\n\nimpl MacroPlugin {\n    pub fn new() -&gt; Self {\n        MacroPlugin {\n            macros: HashMap::new(),\n        }\n    }\n\n    pub fn define_macro(&amp;mut self, name: &amp;str, value: Value) {\n        self.macros.insert(name.to_string(), value);\n    }\n\n    fn expand_macro(&amp;self, value: &amp;Value) -&gt; Option&lt;Value&gt; {\n        if let Value::String(s) = value {\n            if s.starts_with(\"$\") {\n                let macro_name = &amp;s[1..];\n                return self.macros.get(macro_name).cloned();\n            }\n        }\n        None\n    }\n}\n\nimpl ParserPlugin for MacroPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"macro\"\n    }\n\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        // Try to expand macro first\n        if let Some(expanded) = self.expand_macro(value) {\n            *value = expanded;\n            // Recursively process the expanded value\n            self.transform_value(value, path)?;\n            return Ok(());\n        }\n\n        // Process nested values\n        match value {\n            Value::Object(obj) =&gt; {\n                for (_, val) in obj.iter_mut() {\n                    self.transform_value(val, path)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for val in arr.iter_mut() {\n                    self.transform_value(val, path)?;\n                }\n            }\n            _ =&gt; {}\n        }\n\n        Ok(())\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {\n        self\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#testing-plugins","title":"Testing Plugins","text":""},{"location":"dev/plugin-development/#unit-testing","title":"Unit Testing","text":"<p>Create comprehensive unit tests for your plugins:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use vexy_json::parse;\n\n    #[test]\n    fn test_uppercase_plugin() {\n        let mut plugin = UppercasePlugin;\n        let mut value = parse(r#\"{\"message\": \"hello world\"}\"#).unwrap();\n\n        plugin.transform_value(&amp;mut value, \"$\").unwrap();\n\n        if let Value::Object(obj) = value {\n            if let Some(Value::String(s)) = obj.get(\"message\") {\n                assert_eq!(s, \"HELLO WORLD\");\n            } else {\n                panic!(\"Expected string value\");\n            }\n        } else {\n            panic!(\"Expected object\");\n        }\n    }\n\n    #[test]\n    fn test_config_plugin() {\n        std::env::set_var(\"TEST_VAR\", \"test_value\");\n\n        let mut plugin = ConfigPlugin::new(\"TEST_\");\n        let mut value = parse(r#\"{\"config\": \"${TEST_VAR}\"}\"#).unwrap();\n\n        plugin.transform_value(&amp;mut value, \"$\").unwrap();\n\n        if let Value::Object(obj) = value {\n            if let Some(Value::String(s)) = obj.get(\"config\") {\n                assert_eq!(s, \"test_value\");\n            } else {\n                panic!(\"Expected string value\");\n            }\n        } else {\n            panic!(\"Expected object\");\n        }\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#integration-testing","title":"Integration Testing","text":"<p>Test plugins with the full parser:</p> <pre><code>#[test]\nfn test_plugin_integration() {\n    use vexy_json::{parse_with_options, ParserOptions};\n\n    let json = r#\"{\"name\": \"john\", \"age\": 25}\"#;\n    let mut plugin = UppercasePlugin;\n\n    // This would require parser integration\n    // let options = ParserOptions::default().with_plugin(plugin);\n    // let result = parse_with_options(json, options).unwrap();\n\n    // For now, test manually\n    let mut value = parse(json).unwrap();\n    plugin.transform_value(&amp;mut value, \"$\").unwrap();\n\n    // Verify transformation\n    assert_eq!(value.get(\"name\").unwrap().as_str().unwrap(), \"JOHN\");\n}\n</code></pre>"},{"location":"dev/plugin-development/#performance-considerations","title":"Performance Considerations","text":""},{"location":"dev/plugin-development/#1-minimize-allocations","title":"1. Minimize Allocations","text":"<p>Avoid unnecessary allocations in hot paths:</p> <pre><code>// Good: Modify in place\nfn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n    if let Value::String(s) = value {\n        s.make_ascii_uppercase(); // Modifies in place\n    }\n    Ok(())\n}\n\n// Avoid: Creating new strings\nfn transform_value_slow(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n    if let Value::String(s) = value {\n        *s = s.to_uppercase(); // Creates new string\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"dev/plugin-development/#2-use-efficient-data-structures","title":"2. Use Efficient Data Structures","text":"<p>Choose appropriate data structures for your use case:</p> <pre><code>use rustc_hash::FxHashMap; // Faster than std::collections::HashMap\nuse indexmap::IndexMap;    // For ordered maps\nuse smallvec::SmallVec;    // For small vectors\n</code></pre>"},{"location":"dev/plugin-development/#3-lazy-evaluation","title":"3. Lazy Evaluation","text":"<p>Defer expensive operations until necessary:</p> <pre><code>pub struct LazyPlugin {\n    cached_result: Option&lt;Value&gt;,\n    input: String,\n}\n\nimpl LazyPlugin {\n    fn get_processed_value(&amp;mut self) -&gt; &amp;Value {\n        if self.cached_result.is_none() {\n            self.cached_result = Some(self.expensive_computation());\n        }\n        self.cached_result.as_ref().unwrap()\n    }\n\n    fn expensive_computation(&amp;self) -&gt; Value {\n        // Expensive operation here\n        Value::String(\"computed\".to_string())\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#error-handling","title":"Error Handling","text":""},{"location":"dev/plugin-development/#custom-error-types","title":"Custom Error Types","text":"<p>Create specific error types for your plugin:</p> <pre><code>use thiserror::Error;\n\n#[derive(Error, Debug)]\npub enum PluginError {\n    #[error(\"Validation failed at {path}: {message}\")]\n    ValidationError { path: String, message: String },\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n\n    #[error(\"Macro expansion failed: {macro_name}\")]\n    MacroError { macro_name: String },\n}\n\nimpl From&lt;PluginError&gt; for vexy_json_core::error::Error {\n    fn from(err: PluginError) -&gt; Self {\n        vexy_json_core::error::Error::Custom(err.to_string())\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#error-recovery","title":"Error Recovery","text":"<p>Implement graceful error recovery:</p> <pre><code>fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n    match self.try_transform(value, path) {\n        Ok(()) =&gt; Ok(()),\n        Err(e) =&gt; {\n            // Log error but continue processing\n            eprintln!(\"Warning: Plugin error at {}: {}\", path, e);\n            Ok(())\n        }\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#plugin-configuration","title":"Plugin Configuration","text":""},{"location":"dev/plugin-development/#configuration-structs","title":"Configuration Structs","text":"<p>Use configuration structs for complex plugins:</p> <pre><code>#[derive(Debug, Clone)]\npub struct PluginConfig {\n    pub enabled: bool,\n    pub max_depth: usize,\n    pub custom_rules: Vec&lt;String&gt;,\n}\n\nimpl Default for PluginConfig {\n    fn default() -&gt; Self {\n        PluginConfig {\n            enabled: true,\n            max_depth: 10,\n            custom_rules: Vec::new(),\n        }\n    }\n}\n\npub struct ConfigurablePlugin {\n    config: PluginConfig,\n}\n\nimpl ConfigurablePlugin {\n    pub fn new(config: PluginConfig) -&gt; Self {\n        ConfigurablePlugin { config }\n    }\n}\n</code></pre>"},{"location":"dev/plugin-development/#builder-pattern","title":"Builder Pattern","text":"<p>Use the builder pattern for complex plugin configuration:</p> <pre><code>pub struct PluginBuilder {\n    config: PluginConfig,\n}\n\nimpl PluginBuilder {\n    pub fn new() -&gt; Self {\n        PluginBuilder {\n            config: PluginConfig::default(),\n        }\n    }\n\n    pub fn with_max_depth(mut self, depth: usize) -&gt; Self {\n        self.config.max_depth = depth;\n        self\n    }\n\n    pub fn add_rule(mut self, rule: String) -&gt; Self {\n        self.config.custom_rules.push(rule);\n        self\n    }\n\n    pub fn build(self) -&gt; ConfigurablePlugin {\n        ConfigurablePlugin::new(self.config)\n    }\n}\n\n// Usage\nlet plugin = PluginBuilder::new()\n    .with_max_depth(5)\n    .add_rule(\"validate_email\".to_string())\n    .build();\n</code></pre>"},{"location":"dev/plugin-development/#distribution-and-packaging","title":"Distribution and Packaging","text":""},{"location":"dev/plugin-development/#cargo-features","title":"Cargo Features","text":"<p>Use Cargo features to make plugins optional:</p> <pre><code>[features]\ndefault = [\"builtin-plugins\"]\nbuiltin-plugins = [\"datetime\", \"validation\"]\ndatetime = [\"chrono\"]\nvalidation = [\"regex\"]\n</code></pre>"},{"location":"dev/plugin-development/#plugin-crates","title":"Plugin Crates","text":"<p>Create separate crates for complex plugins:</p> <pre><code>[package]\nname = \"vexy-json-plugin-myplugin\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nvexy-json-core = \"2.0\"\n</code></pre>"},{"location":"dev/plugin-development/#best-practices-summary","title":"Best Practices Summary","text":"<ol> <li>Keep plugins focused: Each plugin should have a single, clear purpose</li> <li>Use appropriate data structures: Choose efficient collections and algorithms</li> <li>Handle errors gracefully: Provide meaningful error messages and recovery</li> <li>Write comprehensive tests: Test both success and failure cases</li> <li>Document your plugins: Provide clear usage examples and API documentation</li> <li>Consider performance: Profile your plugins and optimize hot paths</li> <li>Use configuration: Make plugins configurable for different use cases</li> <li>Follow Rust conventions: Use idiomatic Rust patterns and naming</li> </ol>"},{"location":"dev/plugin-development/#next-steps","title":"Next Steps","text":"<ul> <li>Study the built-in plugins in <code>crates/core/src/plugin/plugins/</code></li> <li>Create your own plugin following these patterns</li> <li>Submit your plugin to the community registry</li> <li>Contribute improvements to the plugin system</li> </ul> <p>For more examples and detailed API documentation, see the <code>examples/plugin_examples.rs</code> file.</p>"},{"location":"dev/plugin-registry/","title":"Vexy JSON Plugin Registry","text":""},{"location":"dev/plugin-registry/#overview","title":"Overview","text":"<p>Vexy JSON supports a plugin system that allows extending the parser with custom functionality. This document serves as a registry of available plugins and a guide for creating new ones.</p>"},{"location":"dev/plugin-registry/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"dev/plugin-registry/#schema-validation-plugin","title":"Schema Validation Plugin","text":"<p>Location: <code>crates/core/src/plugin/plugins/schema_validation.rs</code> Purpose: Validate JSON against a schema Usage: <pre><code>use vexy_json_core::plugin::plugins::SchemaValidationPlugin;\n\nlet schema = parse(r#\"{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}}}\"#)?;\nlet validator = SchemaValidationPlugin::new(schema);\nvalidator.validate(&amp;parsed_json, \"$\")?;\n</code></pre></p>"},{"location":"dev/plugin-registry/#datetime-plugin","title":"DateTime Plugin","text":"<p>Location: <code>crates/core/src/plugin/plugins/datetime.rs</code> Purpose: Parse ISO 8601 dates and convert them to structured objects Usage: <pre><code>use vexy_json_core::plugin::plugins::DateTimePlugin;\n\nlet mut datetime_plugin = DateTimePlugin::new();\ndatetime_plugin.transform_value(&amp;mut value, \"$\")?;\n</code></pre></p>"},{"location":"dev/plugin-registry/#custom-number-format-plugin","title":"Custom Number Format Plugin","text":"<p>Location: <code>crates/core/src/plugin/plugins/custom_number.rs</code> Purpose: Parse non-standard number formats (hex, binary, underscores) Usage: <pre><code>use vexy_json_core::plugin::plugins::CustomNumberFormatPlugin;\n\nlet mut number_plugin = CustomNumberFormatPlugin::new();\nlet result = number_plugin.on_number(\"0xFF\", \"$\")?;\n</code></pre></p>"},{"location":"dev/plugin-registry/#comment-preservation-plugin","title":"Comment Preservation Plugin","text":"<p>Location: <code>crates/core/src/plugin/plugins/comment_preservation.rs</code> Purpose: Preserve comments during parsing Usage: <pre><code>use vexy_json_core::plugin::plugins::CommentPreservationPlugin;\n\nlet mut comment_plugin = CommentPreservationPlugin::new();\ncomment_plugin.add_comment(\"Description\".to_string(), \"$.field\", false);\n</code></pre></p>"},{"location":"dev/plugin-registry/#creating-custom-plugins","title":"Creating Custom Plugins","text":""},{"location":"dev/plugin-registry/#plugin-trait","title":"Plugin Trait","text":"<p>All plugins must implement the <code>ParserPlugin</code> trait:</p> <pre><code>use vexy_json_core::plugin::ParserPlugin;\nuse vexy_json_core::ast::Value;\nuse vexy_json_core::error::Result;\nuse std::any::Any;\n\nstruct MyPlugin;\n\nimpl ParserPlugin for MyPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"my_plugin\"\n    }\n\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        // Transform the value\n        Ok(())\n    }\n\n    fn validate(&amp;self, value: &amp;Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        // Validate the value\n        Ok(())\n    }\n\n    fn on_number(&amp;mut self, value: &amp;str, path: &amp;str) -&gt; Result&lt;Value&gt; {\n        // Parse custom number formats\n        Ok(Value::String(value.to_string()))\n    }\n\n    fn on_string(&amp;mut self, value: &amp;str, path: &amp;str) -&gt; Result&lt;String&gt; {\n        // Transform string values\n        Ok(value.to_string())\n    }\n\n    fn on_parse_start(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {\n        // Called when parsing starts\n        Ok(())\n    }\n\n    fn on_parse_end(&amp;mut self, value: &amp;Value) -&gt; Result&lt;()&gt; {\n        // Called when parsing ends\n        Ok(())\n    }\n\n    fn as_any(&amp;self) -&gt; &amp;dyn Any {\n        self\n    }\n\n    fn as_any_mut(&amp;mut self) -&gt; &amp;mut dyn Any {\n        self\n    }\n}\n</code></pre>"},{"location":"dev/plugin-registry/#plugin-hooks","title":"Plugin Hooks","text":""},{"location":"dev/plugin-registry/#transform-hook","title":"Transform Hook","text":"<ul> <li>Purpose: Modify parsed values after parsing</li> <li>When called: After a value is parsed</li> <li>Use cases: Date parsing, string transformations, data normalization</li> </ul>"},{"location":"dev/plugin-registry/#validate-hook","title":"Validate Hook","text":"<ul> <li>Purpose: Validate parsed values</li> <li>When called: After transformation</li> <li>Use cases: Schema validation, business rule validation</li> </ul>"},{"location":"dev/plugin-registry/#number-hook","title":"Number Hook","text":"<ul> <li>Purpose: Parse custom number formats</li> <li>When called: During lexing when a number is encountered</li> <li>Use cases: Hex/binary numbers, special float values, units</li> </ul>"},{"location":"dev/plugin-registry/#string-hook","title":"String Hook","text":"<ul> <li>Purpose: Transform string values</li> <li>When called: During lexing when a string is encountered</li> <li>Use cases: Escape sequence handling, encoding conversion</li> </ul>"},{"location":"dev/plugin-registry/#plugin-integration","title":"Plugin Integration","text":"<p>Plugins can be integrated into the parser in several ways:</p>"},{"location":"dev/plugin-registry/#direct-integration","title":"Direct Integration","text":"<pre><code>use vexy_json_core::parser::Parser;\nuse vexy_json_core::plugin::ParserPluginManager;\n\nlet mut manager = ParserPluginManager::new();\nmanager.register(Box::new(MyPlugin));\n\nlet mut parser = Parser::new_with_plugins(manager);\nlet result = parser.parse(json_string)?;\n</code></pre>"},{"location":"dev/plugin-registry/#parser-options","title":"Parser Options","text":"<pre><code>use vexy_json::{parse_with_options, ParserOptions};\n\nlet options = ParserOptions {\n    plugins: vec![Box::new(MyPlugin)],\n    ..Default::default()\n};\n\nlet result = parse_with_options(json_string, options)?;\n</code></pre>"},{"location":"dev/plugin-registry/#plugin-best-practices","title":"Plugin Best Practices","text":""},{"location":"dev/plugin-registry/#1-error-handling","title":"1. Error Handling","text":"<p>Always use proper error handling and return meaningful error messages:</p> <pre><code>fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n    match value {\n        Value::String(s) =&gt; {\n            // Transform string\n            Ok(())\n        }\n        _ =&gt; Err(Error::Custom(format!(\"Expected string at {}\", path)))\n    }\n}\n</code></pre>"},{"location":"dev/plugin-registry/#2-performance-considerations","title":"2. Performance Considerations","text":"<ul> <li>Avoid expensive operations in hot paths</li> <li>Use lazy evaluation where possible</li> <li>Cache computed values when appropriate</li> </ul>"},{"location":"dev/plugin-registry/#3-path-handling","title":"3. Path Handling","text":"<p>Use the provided path parameter for error reporting and validation:</p> <pre><code>fn validate(&amp;self, value: &amp;Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n    if let Value::Object(obj) = value {\n        for (key, val) in obj {\n            let child_path = format!(\"{}.{}\", path, key);\n            self.validate(val, &amp;child_path)?;\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"dev/plugin-registry/#4-state-management","title":"4. State Management","text":"<p>Keep plugin state minimal and avoid global state:</p> <pre><code>struct MyPlugin {\n    config: MyConfig,\n    // Avoid: static mut GLOBAL_STATE\n}\n</code></pre>"},{"location":"dev/plugin-registry/#5-testing","title":"5. Testing","text":"<p>Write comprehensive tests for your plugins:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use vexy_json::parse;\n\n    #[test]\n    fn test_my_plugin() {\n        let mut plugin = MyPlugin::new();\n        let mut value = parse(r#\"{\"test\": \"value\"}\"#).unwrap();\n        plugin.transform_value(&amp;mut value, \"$\").unwrap();\n        // Assert expected behavior\n    }\n}\n</code></pre>"},{"location":"dev/plugin-registry/#community-plugins","title":"Community Plugins","text":""},{"location":"dev/plugin-registry/#submitting-plugins","title":"Submitting Plugins","text":"<p>To submit a plugin to the registry:</p> <ol> <li>Create a plugin following the guidelines above</li> <li>Add comprehensive documentation</li> <li>Include examples and tests</li> <li>Submit a pull request with:</li> <li>Plugin code in <code>crates/core/src/plugin/plugins/</code></li> <li>Documentation update to this registry</li> <li>Example usage in <code>examples/</code></li> </ol>"},{"location":"dev/plugin-registry/#plugin-categories","title":"Plugin Categories","text":""},{"location":"dev/plugin-registry/#data-transformation","title":"Data Transformation","text":"<ul> <li>DateTime parsing and formatting</li> <li>Number format conversion</li> <li>String encoding/decoding</li> <li>Unit conversion</li> </ul>"},{"location":"dev/plugin-registry/#validation","title":"Validation","text":"<ul> <li>Schema validation</li> <li>Business rule validation</li> <li>Data integrity checks</li> <li>Format validation</li> </ul>"},{"location":"dev/plugin-registry/#parsing-extensions","title":"Parsing Extensions","text":"<ul> <li>Custom comment styles</li> <li>Extended number formats</li> <li>Alternative string delimiters</li> <li>Macro expansion</li> </ul>"},{"location":"dev/plugin-registry/#integration","title":"Integration","text":"<ul> <li>Database connectivity</li> <li>API validation</li> <li>Configuration management</li> <li>Templating support</li> </ul>"},{"location":"dev/plugin-registry/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Plugin performance is tracked in the benchmark suite. Expected overhead:</p> <ul> <li>Schema Validation: ~30-50\u03bcs per validation</li> <li>DateTime Parsing: ~20-30\u03bcs per date field</li> <li>Custom Numbers: ~5-10\u03bcs per number</li> <li>Comment Preservation: ~10-20\u03bcs per comment</li> </ul>"},{"location":"dev/plugin-registry/#security-considerations","title":"Security Considerations","text":""},{"location":"dev/plugin-registry/#safe-plugin-development","title":"Safe Plugin Development","text":"<ol> <li>Input Validation: Always validate plugin inputs</li> <li>Memory Safety: Use safe Rust patterns</li> <li>Error Boundaries: Handle errors gracefully</li> <li>Resource Limits: Avoid unbounded resource usage</li> </ol>"},{"location":"dev/plugin-registry/#plugin-sandboxing","title":"Plugin Sandboxing","text":"<p>Future versions may include plugin sandboxing for untrusted plugins.</p>"},{"location":"dev/plugin-registry/#api-stability","title":"API Stability","text":"<p>The plugin API is considered stable as of v2.0.0. Breaking changes will follow semantic versioning.</p>"},{"location":"dev/plugin-registry/#contributing","title":"Contributing","text":"<p>See <code>CONTRIBUTING.md</code> for details on contributing new plugins or improving existing ones.</p>"},{"location":"dev/release-process/","title":"Release Process","text":"<p>This document describes the automated release process for vexy_json.</p>"},{"location":"dev/release-process/#overview","title":"Overview","text":"<p>Releases are automatically triggered when a version tag is pushed to the repository. The tag must follow the format <code>v*.*.*</code> (e.g., <code>v1.2.0</code>).</p>"},{"location":"dev/release-process/#prerequisites","title":"Prerequisites","text":"<p>Before creating a release, ensure:</p> <ol> <li>Version Updated: Update the version in <code>Cargo.toml</code></li> <li>Changelog Updated: Add release notes to <code>CHANGELOG.md</code></li> <li>Tests Pass: Run <code>./build.sh</code> and ensure all tests pass</li> <li>Documentation Updated: Update any relevant documentation</li> </ol>"},{"location":"dev/release-process/#github-secrets-required","title":"GitHub Secrets Required","text":"<p>The following secrets must be configured in the repository settings:</p> <ul> <li><code>CRATES_IO_TOKEN</code>: API token for publishing to crates.io</li> <li><code>NPM_TOKEN</code>: API token for publishing to npm (optional)</li> </ul>"},{"location":"dev/release-process/#creating-a-release","title":"Creating a Release","text":"<ol> <li> <p>Update Version:    <pre><code># Edit Cargo.toml and update the version field\nversion = \"1.2.0\"\n</code></pre></p> </li> <li> <p>Update Changelog:    <pre><code># Add a new section to CHANGELOG.md\n## [1.2.0] - 2025-01-XX\n- Feature: Added new functionality\n- Fix: Resolved issue with...\n</code></pre></p> </li> <li> <p>Commit Changes:    <pre><code>git add Cargo.toml CHANGELOG.md\ngit commit -m \"chore: bump version to 1.2.0\"\ngit push\n</code></pre></p> </li> <li> <p>Create and Push Tag:    <pre><code>git tag v1.2.0\ngit push origin v1.2.0\n</code></pre></p> </li> </ol>"},{"location":"dev/release-process/#automated-release-workflow","title":"Automated Release Workflow","text":"<p>Once the tag is pushed, the GitHub Actions workflow will:</p> <ol> <li>Create GitHub Release: Generate release notes from commits</li> <li>Build Binaries: Compile for multiple platforms:</li> <li>Linux (x86_64, aarch64) with musl for static linking</li> <li>macOS (x86_64, aarch64)</li> <li>Windows (x86_64, i686)</li> <li>Build macOS Package: Create .dmg with .pkg installer</li> <li>Build WebAssembly: Package WASM module and bindings</li> <li>Publish to crates.io: Automatically publish the Rust crate</li> <li>Publish to npm: Publish WASM package (if configured)</li> <li>Generate Checksums: Create SHA256 checksums for all artifacts</li> <li>Update Documentation: Deploy updated docs to GitHub Pages</li> </ol>"},{"location":"dev/release-process/#release-assets","title":"Release Assets","text":"<p>Each release includes:</p> <ul> <li>Binary executables for all supported platforms</li> <li>macOS installer (.dmg containing .pkg)</li> <li>WebAssembly module (tar.gz archive)</li> <li>SHA256 checksums for all files</li> <li>Source code archives (zip and tar.gz)</li> </ul>"},{"location":"dev/release-process/#manual-release-steps","title":"Manual Release Steps","text":"<p>If automatic publishing fails:</p>"},{"location":"dev/release-process/#publish-to-cratesio","title":"Publish to crates.io","text":"<pre><code>cargo login &lt;YOUR_API_TOKEN&gt;\ncargo publish\n</code></pre>"},{"location":"dev/release-process/#publish-to-npm","title":"Publish to npm","text":"<pre><code>cd npm-pkg\nnpm login\nnpm publish --access public\n</code></pre>"},{"location":"dev/release-process/#rollback-process","title":"Rollback Process","text":"<p>If a release needs to be rolled back:</p> <ol> <li>Delete the release from GitHub</li> <li>Yank the version from crates.io: <code>cargo yank --version 1.2.0</code></li> <li>Unpublish from npm (within 72 hours): <code>npm unpublish @vexy_json/vexy_json@1.2.0</code></li> <li>Delete the git tag: <code>git push --delete origin v1.2.0</code></li> </ol>"},{"location":"dev/release-process/#troubleshooting","title":"Troubleshooting","text":""},{"location":"dev/release-process/#build-failures","title":"Build Failures","text":"<ul> <li>Check the GitHub Actions logs for specific errors</li> <li>Ensure all dependencies are properly specified</li> <li>Verify cross-compilation targets are correctly configured</li> </ul>"},{"location":"dev/release-process/#publishing-failures","title":"Publishing Failures","text":"<ul> <li>Verify API tokens are correctly set in GitHub Secrets</li> <li>Check that the version doesn't already exist on the registry</li> <li>Ensure package metadata is complete and valid</li> </ul>"},{"location":"dev/release-process/#macos-package-issues","title":"macOS Package Issues","text":"<ul> <li>Verify the packaging script has executable permissions</li> <li>Check that the build completes successfully locally</li> <li>Ensure pkgbuild and productbuild tools are available</li> </ul>"},{"location":"dev/release-process/#security-considerations","title":"Security Considerations","text":"<ul> <li>Never commit API tokens to the repository</li> <li>Use GitHub Secrets for all sensitive credentials</li> <li>Consider signing binaries for production releases</li> <li>Enable 2FA on crates.io and npm accounts</li> </ul>"},{"location":"dev/design/cli-enhancements/","title":"CLI Enhancements Design for vexy_json","text":""},{"location":"dev/design/cli-enhancements/#overview","title":"Overview","text":"<p>This document outlines the design for comprehensive CLI enhancements to the vexy_json command-line tool, building on the current basic implementation to provide a powerful and user-friendly JSON processing experience.</p>"},{"location":"dev/design/cli-enhancements/#current-state-analysis","title":"Current State Analysis","text":"<p>Existing CLI Features: - Basic stdin JSON parsing and compact output - Comment-aware JSON processing (for non-comment content) - Simple error reporting</p> <p>Limitations: - No file input/output options - No pretty printing or formatting options - No batch processing capabilities - No watch mode for continuous monitoring - Limited error context and reporting - No query/filtering capabilities</p>"},{"location":"dev/design/cli-enhancements/#enhancement-goals","title":"Enhancement Goals","text":"<ol> <li>User Experience: Make vexy_json the go-to CLI tool for JSON processing</li> <li>Feature Parity: Match or exceed capabilities of popular JSON tools (jq, jsonlint)</li> <li>Rust Integration: Leverage Rust's performance and safety for robust operations</li> <li>Flexibility: Support various workflows from simple formatting to complex transformations</li> </ol>"},{"location":"dev/design/cli-enhancements/#proposed-cli-interface","title":"Proposed CLI Interface","text":""},{"location":"dev/design/cli-enhancements/#basic-usage-enhanced","title":"Basic Usage (Enhanced)","text":"<pre><code># Current (unchanged for compatibility)\necho '{\"key\": \"value\"}' | vexy_json\n\n# New file input/output\nvexy_json input.json                    # Read from file, output to stdout\nvexy_json input.json -o output.json     # Read from file, write to file\nvexy_json -i input.json -o output.json  # Explicit input/output\n\n# Multiple files\nvexy_json file1.json file2.json         # Process multiple files\nvexy_json *.json                        # Glob support\n</code></pre>"},{"location":"dev/design/cli-enhancements/#formatting-options","title":"Formatting Options","text":"<pre><code># Pretty printing (default when output is terminal)\nvexy_json --pretty input.json\nvexy_json -p input.json\n\n# Compact output (default when piped)\nvexy_json --compact input.json\nvexy_json -c input.json\n\n# Custom indentation\nvexy_json --indent 4 input.json\nvexy_json --indent tab input.json\n\n# Sort keys\nvexy_json --sort-keys input.json\n</code></pre>"},{"location":"dev/design/cli-enhancements/#validation-and-analysis","title":"Validation and Analysis","text":"<pre><code># Validate only (exit code indicates success/failure)\nvexy_json --validate input.json\nvexy_json -v input.json\n\n# Show statistics\nvexy_json --stats input.json\n# Output: {\"objects\": 5, \"arrays\": 3, \"strings\": 12, ...}\n\n# Detailed error reporting\nvexy_json --strict input.json    # Fail on any forgiving features\nvexy_json --explain input.json   # Show what forgiving features were used\n</code></pre>"},{"location":"dev/design/cli-enhancements/#parser-options-control","title":"Parser Options Control","text":"<pre><code># Disable specific forgiving features\nvexy_json --no-comments input.json\nvexy_json --no-trailing-commas input.json\nvexy_json --no-unquoted-keys input.json\nvexy_json --no-single-quotes input.json\n\n# Enable specific features (when starting from strict mode)\nvexy_json --strict --allow-comments input.json\n\n# Newline as comma mode\nvexy_json --newline-as-comma input.json\n</code></pre>"},{"location":"dev/design/cli-enhancements/#watch-mode","title":"Watch Mode","text":"<pre><code># Watch file for changes\nvexy_json --watch input.json\nvexy_json -w input.json\n\n# Watch with auto-output\nvexy_json -w input.json -o output.json\n\n# Watch directory\nvexy_json -w ./config/\n</code></pre>"},{"location":"dev/design/cli-enhancements/#batch-processing","title":"Batch Processing","text":"<pre><code># Process all JSON files in directory\nvexy_json --batch ./data/ --output-dir ./processed/\n\n# With transformation\nvexy_json --batch ./data/ --pretty --sort-keys -o ./formatted/\n\n# Parallel processing\nvexy_json --parallel ./data/*.json\n</code></pre>"},{"location":"dev/design/cli-enhancements/#query-and-filtering-future-enhancement","title":"Query and Filtering (Future Enhancement)","text":"<pre><code># Basic path extraction (jq-like)\nvexy_json input.json --get \".users[0].name\"\n\n# Multiple paths\nvexy_json input.json --get \".name\" --get \".age\"\n\n# Simple filtering\nvexy_json input.json --filter \".age &gt; 30\"\n</code></pre>"},{"location":"dev/design/cli-enhancements/#output-control","title":"Output Control","text":"<pre><code># Output to stderr instead of stdout\nvexy_json --stderr input.json\n\n# Silent mode (only exit codes)\nvexy_json --silent input.json\nvexy_json -s input.json\n\n# Different output formats\nvexy_json --output-format yaml input.json  # Future\nvexy_json --output-format toml input.json  # Future\n</code></pre>"},{"location":"dev/design/cli-enhancements/#advanced-features","title":"Advanced Features","text":"<pre><code># Diff two JSON files (structural comparison)\nvexy_json --diff file1.json file2.json\n\n# Merge JSON files\nvexy_json --merge base.json override.json\n\n# Schema validation (future)\nvexy_json --schema schema.json data.json\n\n# Performance profiling\nvexy_json --profile large-file.json\n</code></pre>"},{"location":"dev/design/cli-enhancements/#implementation-architecture","title":"Implementation Architecture","text":""},{"location":"dev/design/cli-enhancements/#core-components","title":"Core Components","text":"<ol> <li>CLI Parser (clap v4)</li> <li>Comprehensive argument parsing</li> <li>Subcommands for complex operations</li> <li>Environment variable support</li> <li> <p>Shell completion generation</p> </li> <li> <p>Input/Output Manager</p> </li> <li>File handling with proper error recovery</li> <li>Streaming support for large files</li> <li>Memory-mapped files for performance</li> <li> <p>Progress bars for long operations</p> </li> <li> <p>Formatter Engine</p> </li> <li>Pretty printing with configurable indentation</li> <li>Compact output optimization</li> <li>Key sorting algorithms</li> <li> <p>Color output support (when terminal detected)</p> </li> <li> <p>Validator Module</p> </li> <li>Strict mode validation</li> <li>Feature usage detection and reporting</li> <li>Statistics collection</li> <li> <p>Error context extraction</p> </li> <li> <p>Watch System (notify crate)</p> </li> <li>File system monitoring</li> <li>Debouncing for rapid changes</li> <li>Directory watching with filters</li> <li> <p>Change notification system</p> </li> <li> <p>Batch Processor</p> </li> <li>Parallel processing with rayon</li> <li>Progress tracking</li> <li>Error aggregation</li> <li>Transaction-like operations</li> </ol>"},{"location":"dev/design/cli-enhancements/#error-handling-strategy","title":"Error Handling Strategy","text":"<ol> <li> <p>Contextual Errors <pre><code>Error at line 5, column 12:\n  4 |     \"name\": \"John\",\n  5 |     age: 30,\n           ^^^\nExpected quoted key, found unquoted identifier 'age'\n\nHint: Use --allow-unquoted-keys to permit this syntax\n</code></pre></p> </li> <li> <p>Error Recovery</p> </li> <li>Continue processing other files in batch mode</li> <li>Provide partial output where possible</li> <li> <p>Suggest fixes for common issues</p> </li> <li> <p>Exit Codes</p> </li> <li>0: Success</li> <li>1: Parse error</li> <li>2: I/O error</li> <li>3: Validation error</li> <li>4: Invalid arguments</li> </ol>"},{"location":"dev/design/cli-enhancements/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Streaming Architecture</li> <li>Process large files without loading entirely into memory</li> <li>Incremental parsing for watch mode</li> <li> <p>Lazy evaluation where possible</p> </li> <li> <p>Parallel Processing</p> </li> <li>Use rayon for multi-file operations</li> <li>Configurable thread pool size</li> <li> <p>Work-stealing for load balancing</p> </li> <li> <p>Optimization Strategies</p> </li> <li>SIMD operations for string processing</li> <li>Memory pooling for repeated allocations</li> <li>Zero-copy parsing where applicable</li> </ol>"},{"location":"dev/design/cli-enhancements/#testing-strategy","title":"Testing Strategy","text":""},{"location":"dev/design/cli-enhancements/#unit-tests","title":"Unit Tests","text":"<ul> <li>Each CLI option tested independently</li> <li>Error case coverage</li> <li>Edge cases (empty files, huge files, special characters)</li> </ul>"},{"location":"dev/design/cli-enhancements/#integration-tests","title":"Integration Tests","text":"<ul> <li>End-to-end command execution</li> <li>File I/O operations</li> <li>Pipe and redirection handling</li> </ul>"},{"location":"dev/design/cli-enhancements/#performance-tests","title":"Performance Tests","text":"<ul> <li>Benchmark against other JSON tools</li> <li>Memory usage profiling</li> <li>Large file handling</li> </ul>"},{"location":"dev/design/cli-enhancements/#compatibility-tests","title":"Compatibility Tests","text":"<ul> <li>Ensure backward compatibility</li> <li>Test on different platforms</li> <li>Shell integration testing</li> </ul>"},{"location":"dev/design/cli-enhancements/#documentation-plan","title":"Documentation Plan","text":""},{"location":"dev/design/cli-enhancements/#man-page","title":"Man Page","text":"<ul> <li>Comprehensive option documentation</li> <li>Examples for common use cases</li> <li>Troubleshooting section</li> </ul>"},{"location":"dev/design/cli-enhancements/#readme-updates","title":"README Updates","text":"<ul> <li>Quick start guide</li> <li>Feature comparison table</li> <li>Migration guide from other tools</li> </ul>"},{"location":"dev/design/cli-enhancements/#interactive-help","title":"Interactive Help","text":"<ul> <li>Context-sensitive help</li> <li>Did-you-mean suggestions</li> <li>Example snippets in error messages</li> </ul>"},{"location":"dev/design/cli-enhancements/#migration-path","title":"Migration Path","text":""},{"location":"dev/design/cli-enhancements/#phase-1-core-enhancements-week-1-2","title":"Phase 1: Core Enhancements (Week 1-2)","text":"<ul> <li>File I/O support</li> <li>Pretty printing</li> <li>Basic validation</li> <li>Enhanced error messages</li> </ul>"},{"location":"dev/design/cli-enhancements/#phase-2-advanced-features-week-3-4","title":"Phase 2: Advanced Features (Week 3-4)","text":"<ul> <li>Watch mode</li> <li>Batch processing</li> <li>Parser option controls</li> <li>Statistics</li> </ul>"},{"location":"dev/design/cli-enhancements/#phase-3-power-features-week-5-6","title":"Phase 3: Power Features (Week 5-6)","text":"<ul> <li>Parallel processing</li> <li>Query/filtering basics</li> <li>Diff/merge operations</li> <li>Performance optimizations</li> </ul>"},{"location":"dev/design/cli-enhancements/#phase-4-polish-week-7-8","title":"Phase 4: Polish (Week 7-8)","text":"<ul> <li>Documentation</li> <li>Shell completions</li> <li>Testing and benchmarking</li> <li>Release preparation</li> </ul>"},{"location":"dev/design/cli-enhancements/#success-metrics","title":"Success Metrics","text":"<ol> <li>Performance: Process 1MB JSON in &lt;100ms</li> <li>Usability: 90% of operations require no manual reference</li> <li>Compatibility: 100% backward compatibility maintained</li> <li>Reliability: Zero panics in production use</li> <li>Adoption: Featured in awesome-rust JSON tools section</li> </ol>"},{"location":"dev/design/cli-enhancements/#open-questions","title":"Open Questions","text":"<ol> <li>Should we implement a full jq-compatible query language?</li> <li>How much functionality should be in the core vs. plugins?</li> <li>Should we support YAML/TOML output in v1?</li> <li>What level of JSON Schema support is needed?</li> </ol>"},{"location":"dev/design/cli-enhancements/#conclusion","title":"Conclusion","text":"<p>These CLI enhancements will transform vexy_json from a basic JSON parser into a comprehensive JSON processing toolkit. By focusing on user experience, performance, and flexibility, vexy_json can become the preferred choice for developers working with forgiving JSON formats.</p>"},{"location":"dev/design/python-api/","title":"Python API Design for vexy_json","text":""},{"location":"dev/design/python-api/#overview","title":"Overview","text":"<p>This document outlines the design for Python bindings for the vexy_json library, drawing from PyO3 best practices and existing Python JSON parser APIs (json, orjson, ujson).</p>"},{"location":"dev/design/python-api/#core-design-principles","title":"Core Design Principles","text":"<ol> <li>Idiomatic Python: API should feel natural to Python developers</li> <li>Performance First: Minimize Python/Rust round-trips</li> <li>Compatibility: Similar to standard json library where possible</li> <li>Extensibility: Support for streaming and advanced features</li> </ol>"},{"location":"dev/design/python-api/#api-structure","title":"API Structure","text":""},{"location":"dev/design/python-api/#basic-functions-similar-to-json-module","title":"Basic Functions (Similar to json module)","text":"<pre><code>import vexy_json\n\n# Basic parsing - similar to json.loads()\ndef loads(s: str, *, \n          allow_comments: bool = True,\n          allow_trailing_commas: bool = True,\n          allow_unquoted_keys: bool = True,\n          allow_single_quotes: bool = True,\n          implicit_top_level: bool = True,\n          newline_as_comma: bool = True,\n          max_depth: int = 64) -&gt; Any:\n    \"\"\"Parse a JSON string with forgiving features.\"\"\"\n    pass\n\n# Formatting - similar to json.dumps()\ndef dumps(obj: Any, *, \n          indent: Optional[int] = None,\n          ensure_ascii: bool = True) -&gt; str:\n    \"\"\"Format a Python object as JSON string.\"\"\"\n    pass\n\n# Validation\ndef is_valid(s: str) -&gt; bool:\n    \"\"\"Check if string is valid JSON/Vexy JSON.\"\"\"\n    pass\n\n# File operations\ndef load(fp: TextIO, **kwargs) -&gt; Any:\n    \"\"\"Load JSON from file object.\"\"\"\n    pass\n\ndef dump(obj: Any, fp: TextIO, **kwargs) -&gt; None:\n    \"\"\"Dump JSON to file object.\"\"\"\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#options-class-for-advanced-configuration","title":"Options Class (For Advanced Configuration)","text":"<pre><code>class ParserOptions:\n    \"\"\"Configuration options for vexy_json parser.\"\"\"\n\n    def __init__(self, \n                 allow_comments: bool = True,\n                 allow_trailing_commas: bool = True,\n                 allow_unquoted_keys: bool = True,\n                 allow_single_quotes: bool = True,\n                 implicit_top_level: bool = True,\n                 newline_as_comma: bool = True,\n                 max_depth: int = 64):\n        pass\n\n    @classmethod\n    def strict(cls) -&gt; 'ParserOptions':\n        \"\"\"Create strict JSON parser options.\"\"\"\n        pass\n\n    @classmethod\n    def forgiving(cls) -&gt; 'ParserOptions':\n        \"\"\"Create forgiving parser options (default).\"\"\"\n        pass\n\ndef parse_with_options(s: str, options: ParserOptions) -&gt; Any:\n    \"\"\"Parse with explicit options object.\"\"\"\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#streaming-parser","title":"Streaming Parser","text":"<pre><code>class StreamingParser:\n    \"\"\"Event-based streaming JSON parser.\"\"\"\n\n    def __init__(self, options: Optional[ParserOptions] = None):\n        pass\n\n    def feed(self, data: str) -&gt; Iterator[StreamingEvent]:\n        \"\"\"Feed data and yield events.\"\"\"\n        pass\n\n    def close(self) -&gt; Iterator[StreamingEvent]:\n        \"\"\"Close parser and yield remaining events.\"\"\"\n        pass\n\nclass StreamingEvent:\n    \"\"\"Base class for streaming events.\"\"\"\n    pass\n\nclass StartObject(StreamingEvent):\n    pass\n\nclass EndObject(StreamingEvent):\n    pass\n\nclass StartArray(StreamingEvent):\n    pass\n\nclass EndArray(StreamingEvent):\n    pass\n\nclass ObjectKey(StreamingEvent):\n    def __init__(self, key: str):\n        self.key = key\n\nclass NullValue(StreamingEvent):\n    pass\n\nclass BoolValue(StreamingEvent):\n    def __init__(self, value: bool):\n        self.value = value\n\nclass NumberValue(StreamingEvent):\n    def __init__(self, value: str):\n        self.value = value\n\nclass StringValue(StreamingEvent):\n    def __init__(self, value: str):\n        self.value = value\n\nclass EndOfInput(StreamingEvent):\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#ndjson-support","title":"NDJSON Support","text":"<pre><code>class NdJsonParser:\n    \"\"\"Newline-delimited JSON parser.\"\"\"\n\n    def __init__(self, options: Optional[ParserOptions] = None):\n        pass\n\n    def parse_lines(self, lines: Iterable[str]) -&gt; Iterator[Any]:\n        \"\"\"Parse NDJSON lines.\"\"\"\n        pass\n\n    def parse_file(self, file_path: str) -&gt; Iterator[Any]:\n        \"\"\"Parse NDJSON file.\"\"\"\n        pass\n\ndef parse_ndjson(s: str, **kwargs) -&gt; List[Any]:\n    \"\"\"Parse NDJSON string to list of objects.\"\"\"\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#error-handling","title":"Error Handling","text":"<pre><code>class VexyJsonError(Exception):\n    \"\"\"Base exception for vexy_json errors.\"\"\"\n    pass\n\nclass ParseError(VexyJsonError):\n    \"\"\"JSON parsing error.\"\"\"\n\n    def __init__(self, message: str, line: int, column: int):\n        self.message = message\n        self.line = line\n        self.column = column\n        super().__init__(f\"{message} at line {line}, column {column}\")\n\nclass ValidationError(VexyJsonError):\n    \"\"\"JSON validation error.\"\"\"\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#python-specific-features","title":"Python-Specific Features","text":"<pre><code># Dict/List builders for streaming\nclass StreamingValueBuilder:\n    \"\"\"Build Python objects from streaming events.\"\"\"\n\n    def __init__(self):\n        pass\n\n    def process_event(self, event: StreamingEvent) -&gt; Optional[Any]:\n        \"\"\"Process event and return completed value if any.\"\"\"\n        pass\n\n# Async support (future enhancement)\nasync def loads_async(s: str, **kwargs) -&gt; Any:\n    \"\"\"Async version of loads.\"\"\"\n    pass\n\n# Iterator support\ndef iter_objects(s: str, **kwargs) -&gt; Iterator[Any]:\n    \"\"\"Iterate over top-level objects in string.\"\"\"\n    pass\n\ndef iter_arrays(s: str, **kwargs) -&gt; Iterator[Any]:\n    \"\"\"Iterate over top-level arrays in string.\"\"\"\n    pass\n</code></pre>"},{"location":"dev/design/python-api/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"dev/design/python-api/#1-function-naming-and-signatures","title":"1. Function Naming and Signatures","text":"<ul> <li><code>loads()</code> instead of <code>parse()</code> for consistency with <code>json</code> module</li> <li>Keyword-only arguments for options to prevent positional confusion</li> <li>Boolean defaults match vexy_json's forgiving nature</li> </ul>"},{"location":"dev/design/python-api/#2-error-handling","title":"2. Error Handling","text":"<ul> <li>Custom exception hierarchy with position information</li> <li>Graceful error recovery in streaming mode</li> <li>Validation separate from parsing for performance</li> </ul>"},{"location":"dev/design/python-api/#3-performance-optimizations","title":"3. Performance Optimizations","text":"<ul> <li>Bytes handling like orjson for performance</li> <li>Streaming events minimize memory allocation</li> <li>Bulk operations in Rust rather than Python loops</li> </ul>"},{"location":"dev/design/python-api/#4-python-integration","title":"4. Python Integration","text":"<ul> <li>File object support for <code>load()</code>/<code>dump()</code></li> <li>Iterator protocol for streaming</li> <li>Type hints for better IDE support</li> <li>Docstrings following Python conventions</li> </ul>"},{"location":"dev/design/python-api/#5-api-extensions","title":"5. API Extensions","text":"<ul> <li><code>is_valid()</code> for validation without parsing</li> <li>Options classes for complex configuration</li> <li>NDJSON support for line-oriented JSON</li> <li>Streaming builder for event-to-object conversion</li> </ul>"},{"location":"dev/design/python-api/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Phase 1: Core <code>loads()</code>, <code>dumps()</code>, <code>is_valid()</code> functions</li> <li>Phase 2: <code>ParserOptions</code> class and advanced parsing</li> <li>Phase 3: Streaming parser with events</li> <li>Phase 4: NDJSON support and file operations</li> <li>Phase 5: Performance optimizations and async support</li> </ol>"},{"location":"dev/design/python-api/#compatibility-notes","title":"Compatibility Notes","text":"<ul> <li>Standard library compatibility: <code>loads()</code> and <code>dumps()</code> work as drop-in replacements</li> <li>orjson inspiration: Performance-focused design with bytes handling</li> <li>ujson similarity: Simple API with performance benefits</li> <li>vexy_json extensions: Forgiving features as the key differentiator</li> </ul> <p>This design balances Python idioms with the performance benefits of Rust, providing a comprehensive JSON parsing solution that extends beyond standard JSON capabilities.</p>"},{"location":"internal/PLAN/","title":"this_file: docs/internal/TODO.md","text":"<p>Now /report and mark completed items as done in </p>"},{"location":"internal/PLAN/#this_file-docsinternalplanmd","title":"this_file: docs/internal/PLAN.md","text":""},{"location":"internal/PLAN/#vexy-json-improvement-plan-v232-the-reference-implementation-removal-build-fixes","title":"Vexy JSON Improvement Plan - v2.3.2 the reference implementation Removal &amp; Build Fixes","text":""},{"location":"internal/PLAN/#executive-summary","title":"Executive Summary","text":"<p>Following the successful project renaming to Vexy JSON, this plan addresses critical remaining issues:</p>"},{"location":"internal/PLAN/#new-critical-issues-found-v232","title":"New Critical Issues Found (v2.3.2)","text":"<ol> <li>the reference implementation references removal - Found 50 files containing \"the reference implementation\" references that need cleanup</li> <li>Test failure - test_number_features failing due to number format parsing issues</li> <li>Build warnings - 3 unused variable warnings in examples/recursive_parser.rs</li> <li>Build status - Build succeeds but with warnings and 1 test failure</li> </ol>"},{"location":"internal/PLAN/#completed-v230","title":"Completed (v2.3.0)","text":"<ol> <li>\u2705 C API naming fixed - Resolved struct name mismatches</li> <li>\u2705 Critical compilation errors fixed - Added missing struct fields and enum variants</li> <li>\u2705 README.md updated - Removed migration tool references</li> </ol>"},{"location":"internal/PLAN/#current-status-v231","title":"Current Status (v2.3.1)","text":"<ol> <li>Naming consistency - Minor inconsistencies found in Python bindings</li> <li>Compilation warnings - 24 warnings (reduced from 30)</li> <li>Test failures - 8 failing tests remain</li> <li>Build successful - Core and CLI build without errors</li> <li>Documentation - Mostly consistent, one ZZSON reference remains</li> </ol>"},{"location":"internal/PLAN/#post-migration-findings","title":"Post-Migration Findings","text":""},{"location":"internal/PLAN/#naming-analysis-results","title":"Naming Analysis Results","text":"<ol> <li>Old Naming References: Only 2 files contain \"zzson\" - both in documentation (PLAN.md and issue 610.txt)</li> <li>Python Bindings: Test file previously used <code>VexyJSONParser</code> but was fixed to <code>VexyJsonParser</code></li> <li>Naming Conventions: Generally consistent across languages:</li> <li>Rust: <code>vexy_json-*</code> (crate names), <code>VexyJson*</code> (types)</li> <li>C/C++: <code>VexyJson*</code> (types)</li> <li>Python: <code>vexy_json</code> (package), <code>VexyJson*</code> (classes)</li> <li>JavaScript: <code>VexyJson*</code> (classes)</li> <li>Documentation: \"Vexy JSON\" (with space)</li> </ol>"},{"location":"internal/PLAN/#priority-groups","title":"Priority Groups","text":""},{"location":"internal/PLAN/#group-0-immediate-critical-fixes","title":"Group 0: IMMEDIATE - Critical Fixes","text":""},{"location":"internal/PLAN/#01-remove-the-reference-implementation-references-50-files","title":"0.1 Remove the reference implementation References (50 files)","text":"<ul> <li>High Priority: Remove all \"the reference implementation\" references from codebase</li> <li>Files affected: 50 files including tests, documentation, and code</li> <li>Impact: Legacy naming that confuses project identity</li> <li>Categories to clean:</li> <li>Test files: <code>the reference implementation_*.rs</code>, <code>supported_the reference implementation.rs</code></li> <li>Documentation: HTML files, markdown files, tool descriptions</li> <li>Code references: Comments, variable names, function names</li> <li>Configuration: pyproject.toml, Cargo.toml references</li> </ul>"},{"location":"internal/PLAN/#02-fix-test-failure-1-failure","title":"0.2 Fix Test Failure (1 failure)","text":"<ul> <li>test_number_features - Number format parsing for octal (0o77), binary (0b1010), underscore separators (1_000_000)</li> <li>Root cause: Parser doesn't support these number formats, or incorrectly identifies them as floats. The tests are failing because they expect <code>Number::Integer</code> but receive <code>Number::Float</code>.</li> <li>Fix needed: Implement support for these number formats, ensuring they are correctly parsed as integers when applicable. This involves modifying the number parsing logic in <code>crates/core/src/parser/number.rs</code> to handle binary, octal, hexadecimal, and underscore separators.</li> </ul>"},{"location":"internal/PLAN/#03-fix-build-warnings-3-warnings","title":"0.3 Fix Build Warnings (3 warnings)","text":"<ul> <li>examples/recursive_parser.rs: 3 unused variable warnings</li> <li>Simple fix: Prefix variables with underscore or use the results</li> <li>Impact: Clean build output</li> </ul>"},{"location":"internal/PLAN/#group-1-high-priority-clean-up-warnings","title":"Group 1: HIGH Priority - Clean Up Warnings","text":""},{"location":"internal/PLAN/#11-dead-code-cleanup-24-warnings","title":"1.1 Dead Code Cleanup (24 warnings)","text":"<ul> <li>Unused methods: <code>analyze_custom_error</code>, <code>analyze_context_error</code>, <code>analyze_invalid_utf8</code></li> <li>Unused fields: <code>confidence</code>, <code>patterns</code>, <code>learned_patterns</code>, <code>lookahead_size</code>, etc.</li> <li>Unused variants: <code>StateChange</code>, <code>InsertString</code>, <code>ReplaceRange</code>, etc.</li> <li>Decision needed: Either implement these features or remove the dead code</li> </ul>"},{"location":"internal/PLAN/#12-import-cleanup","title":"1.2 Import Cleanup","text":"<ul> <li>Fix unused imports in <code>trace_parse.rs</code></li> <li>Run <code>cargo fix</code> to automatically clean up simple warnings</li> <li>Target: Reduce warnings from 24 to under 10 (achieved 0 warnings!)</li> </ul>"},{"location":"internal/PLAN/#group-2-medium-priority-post-release-improvements","title":"Group 2: MEDIUM Priority - Post-Release Improvements","text":""},{"location":"internal/PLAN/#21-architecture-improvements","title":"2.1 Architecture Improvements","text":"<ul> <li>Complete the pattern-based error recovery system (currently stubbed)</li> <li>Implement the ML-based pattern recognition</li> <li>Finish the streaming parser implementation</li> <li>Optimize memory pool usage</li> </ul>"},{"location":"internal/PLAN/#22-performance-enhancements","title":"2.2 Performance Enhancements","text":"<ul> <li>Remove dead code to reduce binary size</li> <li>Optimize hot paths identified by warnings</li> <li>Implement SIMD optimizations where applicable</li> </ul>"},{"location":"internal/PLAN/#23-testing-infrastructure","title":"2.3 Testing Infrastructure","text":"<ul> <li>Add integration tests for all language bindings</li> <li>Create property-based tests for edge cases</li> <li>Set up continuous fuzzing</li> </ul>"},{"location":"internal/PLAN/#group-3-low-priority-future-enhancements","title":"Group 3: LOW Priority - Future Enhancements","text":""},{"location":"internal/PLAN/#31-plugin-system","title":"3.1 Plugin System","text":"<ul> <li>Design and implement a plugin architecture</li> <li>Create example plugins</li> <li>Document plugin development</li> </ul>"},{"location":"internal/PLAN/#32-advanced-features","title":"3.2 Advanced Features","text":"<ul> <li>Incremental parsing for live editing</li> <li>Schema validation integration</li> <li>Advanced error recovery strategies</li> <li>JSON path query support</li> </ul>"},{"location":"internal/PLAN/#implementation-plan","title":"Implementation Plan","text":""},{"location":"internal/PLAN/#phase-1-the-reference-implementation-references-removal-immediate-2-3-hours","title":"Phase 1: the reference implementation References Removal (Immediate - 2-3 hours)","text":"<ol> <li>Rename test files: <code>the reference implementation_*.rs</code> \u2192 <code>vexy_json_*.rs</code> or <code>compat_*.rs</code></li> <li>Update documentation: Remove \"the reference implementation\" from HTML, markdown, and tool descriptions</li> <li>Clean code references: Replace \"the reference implementation\" with \"vexy_json\" in comments and variable names</li> <li>Update configurations: Clean pyproject.toml and Cargo.toml references</li> <li>Verify completeness: Re-run grep to ensure no \"the reference implementation\" references remain</li> </ol>"},{"location":"internal/PLAN/#phase-2-build-fixes-30-minutes","title":"Phase 2: Build Fixes (30 minutes)","text":"<ol> <li>Fix unused variables: Prefix with underscore in examples/recursive_parser.rs</li> <li>Fix test failure: Investigate and fix test_number_features number format parsing</li> <li>Action: Modify <code>crates/core/src/parser/number.rs</code> to correctly parse binary (0b), octal (0o), hexadecimal (0x), and numbers with underscore separators. Ensure these are represented as <code>Number::Integer</code> where appropriate.</li> <li>Verify build: Run <code>./build.sh</code> to confirm clean build</li> </ol>"},{"location":"internal/PLAN/#phase-3-final-verification-30-minutes","title":"Phase 3: Final Verification (30 minutes)","text":"<ol> <li>Run full test suite to ensure no regressions</li> <li>Check build output for warnings</li> <li>Verify all the reference implementation references are removed</li> </ol>"},{"location":"internal/PLAN/#phase-4-release-preparation-1-day","title":"Phase 4: Release Preparation (1 day)","text":"<ol> <li>Run full test suite on all platforms.</li> <li>Update version to 2.3.1 in all Cargo.toml files.</li> <li>Update CHANGELOG.md with all fixes.</li> <li>Create git tag v2.3.1.</li> <li>Publish to crates.io.</li> </ol>"},{"location":"internal/PLAN/#success-metrics","title":"Success Metrics","text":"<ul> <li>\u2705 Zero references to ZZSON in code</li> <li>\u2705 Successful build of core and CLI</li> <li>\u2b1c Reduced warnings to &lt; 10 (currently 24)</li> <li>\u2b1c All 8 failing tests fixed</li> <li>\u2b1c Clean documentation with no migration artifacts</li> </ul>"},{"location":"internal/PLAN/#current-state-summary","title":"Current State Summary","text":"<p>The Vexy JSON project has successfully completed its renaming from ZZSON. The codebase is: - Functionally correct - Builds and runs - Mostly consistent - Naming follows language conventions - Nearly release-ready - Only cleanup tasks remain</p>"},{"location":"internal/PLAN/#next-steps","title":"Next Steps","text":"<ol> <li>Remove the ZZSON reference from line 8 of this file</li> <li>Run <code>cargo fix</code> to clean up simple warnings</li> <li>Investigate and fix the 8 failing tests</li> <li>Release version 2.3.1 as a \"post-migration cleanup\" release</li> </ol> <p>The project is in good shape with only minor housekeeping tasks remaining.</p>"},{"location":"internal/TODO/","title":"this_file: docs/internal/TODO.md","text":"<p>Now /report and mark completed items as done in </p>"},{"location":"internal/TODO/#this_file-docsinternalplanmd","title":"this_file: docs/internal/PLAN.md","text":""},{"location":"internal/TODO/#vexy-json-improvement-plan-v232-the-reference-implementation-removal-build-fixes","title":"Vexy JSON Improvement Plan - v2.3.2 the reference implementation Removal &amp; Build Fixes","text":""},{"location":"internal/TODO/#executive-summary","title":"Executive Summary","text":"<p>Following the successful project renaming to Vexy JSON, this plan addresses critical remaining issues:</p>"},{"location":"internal/TODO/#new-critical-issues-found-v232","title":"New Critical Issues Found (v2.3.2)","text":"<ol> <li>the reference implementation references removal - Found 50 files containing \"the reference implementation\" references that need cleanup</li> <li>Test failure - test_number_features failing due to number format parsing issues</li> <li>Build warnings - 3 unused variable warnings in examples/recursive_parser.rs</li> <li>Build status - Build succeeds but with warnings and 1 test failure</li> </ol>"},{"location":"internal/TODO/#completed-v230","title":"Completed (v2.3.0)","text":"<ol> <li>\u2705 C API naming fixed - Resolved struct name mismatches</li> <li>\u2705 Critical compilation errors fixed - Added missing struct fields and enum variants</li> <li>\u2705 README.md updated - Removed migration tool references</li> </ol>"},{"location":"internal/TODO/#current-status-v231","title":"Current Status (v2.3.1)","text":"<ol> <li>Naming consistency - Minor inconsistencies found in Python bindings</li> <li>Compilation warnings - 24 warnings (reduced from 30)</li> <li>Test failures - 8 failing tests remain</li> <li>Build successful - Core and CLI build without errors</li> <li>Documentation - Mostly consistent, one ZZSON reference remains</li> </ol>"},{"location":"internal/TODO/#post-migration-findings","title":"Post-Migration Findings","text":""},{"location":"internal/TODO/#naming-analysis-results","title":"Naming Analysis Results","text":"<ol> <li>Old Naming References: Only 2 files contain \"zzson\" - both in documentation (PLAN.md and issue 610.txt)</li> <li>Python Bindings: Test file previously used <code>VexyJSONParser</code> but was fixed to <code>VexyJsonParser</code></li> <li>Naming Conventions: Generally consistent across languages:</li> <li>Rust: <code>vexy_json-*</code> (crate names), <code>VexyJson*</code> (types)</li> <li>C/C++: <code>VexyJson*</code> (types)</li> <li>Python: <code>vexy_json</code> (package), <code>VexyJson*</code> (classes)</li> <li>JavaScript: <code>VexyJson*</code> (classes)</li> <li>Documentation: \"Vexy JSON\" (with space)</li> </ol>"},{"location":"internal/TODO/#priority-groups","title":"Priority Groups","text":""},{"location":"internal/TODO/#group-0-immediate-critical-fixes","title":"Group 0: IMMEDIATE - Critical Fixes","text":""},{"location":"internal/TODO/#01-remove-the-reference-implementation-references-50-files","title":"0.1 Remove the reference implementation References (50 files)","text":"<ul> <li>High Priority: Remove all \"the reference implementation\" references from codebase</li> <li>Files affected: 50 files including tests, documentation, and code</li> <li>Impact: Legacy naming that confuses project identity</li> <li>Categories to clean:</li> <li>Test files: <code>the reference implementation_*.rs</code>, <code>supported_the reference implementation.rs</code></li> <li>Documentation: HTML files, markdown files, tool descriptions</li> <li>Code references: Comments, variable names, function names</li> <li>Configuration: pyproject.toml, Cargo.toml references</li> </ul>"},{"location":"internal/TODO/#02-fix-test-failure-1-failure","title":"0.2 Fix Test Failure (1 failure)","text":"<ul> <li>test_number_features - Number format parsing for octal (0o77), binary (0b1010), underscore separators (1_000_000)</li> <li>Root cause: Parser doesn't support these number formats, or incorrectly identifies them as floats. The tests are failing because they expect <code>Number::Integer</code> but receive <code>Number::Float</code>.</li> <li>Fix needed: Implement support for these number formats, ensuring they are correctly parsed as integers when applicable. This involves modifying the number parsing logic in <code>crates/core/src/parser/number.rs</code> to handle binary, octal, hexadecimal, and underscore separators.</li> </ul>"},{"location":"internal/TODO/#03-fix-build-warnings-3-warnings","title":"0.3 Fix Build Warnings (3 warnings)","text":"<ul> <li>examples/recursive_parser.rs: 3 unused variable warnings</li> <li>Simple fix: Prefix variables with underscore or use the results</li> <li>Impact: Clean build output</li> </ul>"},{"location":"internal/TODO/#group-1-high-priority-clean-up-warnings","title":"Group 1: HIGH Priority - Clean Up Warnings","text":""},{"location":"internal/TODO/#11-dead-code-cleanup-24-warnings","title":"1.1 Dead Code Cleanup (24 warnings)","text":"<ul> <li>Unused methods: <code>analyze_custom_error</code>, <code>analyze_context_error</code>, <code>analyze_invalid_utf8</code></li> <li>Unused fields: <code>confidence</code>, <code>patterns</code>, <code>learned_patterns</code>, <code>lookahead_size</code>, etc.</li> <li>Unused variants: <code>StateChange</code>, <code>InsertString</code>, <code>ReplaceRange</code>, etc.</li> <li>Decision needed: Either implement these features or remove the dead code</li> </ul>"},{"location":"internal/TODO/#12-import-cleanup","title":"1.2 Import Cleanup","text":"<ul> <li>Fix unused imports in <code>trace_parse.rs</code></li> <li>Run <code>cargo fix</code> to automatically clean up simple warnings</li> <li>Target: Reduce warnings from 24 to under 10 (achieved 0 warnings!)</li> </ul>"},{"location":"internal/TODO/#group-2-medium-priority-post-release-improvements","title":"Group 2: MEDIUM Priority - Post-Release Improvements","text":""},{"location":"internal/TODO/#21-architecture-improvements","title":"2.1 Architecture Improvements","text":"<ul> <li>Complete the pattern-based error recovery system (currently stubbed)</li> <li>Implement the ML-based pattern recognition</li> <li>Finish the streaming parser implementation</li> <li>Optimize memory pool usage</li> </ul>"},{"location":"internal/TODO/#22-performance-enhancements","title":"2.2 Performance Enhancements","text":"<ul> <li>Remove dead code to reduce binary size</li> <li>Optimize hot paths identified by warnings</li> <li>Implement SIMD optimizations where applicable</li> </ul>"},{"location":"internal/TODO/#23-testing-infrastructure","title":"2.3 Testing Infrastructure","text":"<ul> <li>Add integration tests for all language bindings</li> <li>Create property-based tests for edge cases</li> <li>Set up continuous fuzzing</li> </ul>"},{"location":"internal/TODO/#group-3-low-priority-future-enhancements","title":"Group 3: LOW Priority - Future Enhancements","text":""},{"location":"internal/TODO/#31-plugin-system","title":"3.1 Plugin System","text":"<ul> <li>Design and implement a plugin architecture</li> <li>Create example plugins</li> <li>Document plugin development</li> </ul>"},{"location":"internal/TODO/#32-advanced-features","title":"3.2 Advanced Features","text":"<ul> <li>Incremental parsing for live editing</li> <li>Schema validation integration</li> <li>Advanced error recovery strategies</li> <li>JSON path query support</li> </ul>"},{"location":"internal/TODO/#implementation-plan","title":"Implementation Plan","text":""},{"location":"internal/TODO/#phase-1-the-reference-implementation-references-removal-immediate-2-3-hours","title":"Phase 1: the reference implementation References Removal (Immediate - 2-3 hours)","text":"<ol> <li>Rename test files: <code>the reference implementation_*.rs</code> \u2192 <code>vexy_json_*.rs</code> or <code>compat_*.rs</code></li> <li>Update documentation: Remove \"the reference implementation\" from HTML, markdown, and tool descriptions</li> <li>Clean code references: Replace \"the reference implementation\" with \"vexy_json\" in comments and variable names</li> <li>Update configurations: Clean pyproject.toml and Cargo.toml references</li> <li>Verify completeness: Re-run grep to ensure no \"the reference implementation\" references remain</li> </ol>"},{"location":"internal/TODO/#phase-2-build-fixes-30-minutes","title":"Phase 2: Build Fixes (30 minutes)","text":"<ol> <li>Fix unused variables: Prefix with underscore in examples/recursive_parser.rs</li> <li>Fix test failure: Investigate and fix test_number_features number format parsing</li> <li>Action: Modify <code>crates/core/src/parser/number.rs</code> to correctly parse binary (0b), octal (0o), hexadecimal (0x), and numbers with underscore separators. Ensure these are represented as <code>Number::Integer</code> where appropriate.</li> <li>Verify build: Run <code>./build.sh</code> to confirm clean build</li> </ol>"},{"location":"internal/TODO/#phase-3-final-verification-30-minutes","title":"Phase 3: Final Verification (30 minutes)","text":"<ol> <li>Run full test suite to ensure no regressions</li> <li>Check build output for warnings</li> <li>Verify all the reference implementation references are removed</li> </ol>"},{"location":"internal/TODO/#phase-4-release-preparation-1-day","title":"Phase 4: Release Preparation (1 day)","text":"<ol> <li>Run full test suite on all platforms.</li> <li>Update version to 2.3.1 in all Cargo.toml files.</li> <li>Update CHANGELOG.md with all fixes.</li> <li>Create git tag v2.3.1.</li> <li>Publish to crates.io.</li> </ol>"},{"location":"internal/TODO/#success-metrics","title":"Success Metrics","text":"<ul> <li>\u2705 Zero references to ZZSON in code</li> <li>\u2705 Successful build of core and CLI</li> <li>\u2b1c Reduced warnings to &lt; 10 (currently 24)</li> <li>\u2b1c All 8 failing tests fixed</li> <li>\u2b1c Clean documentation with no migration artifacts</li> </ul>"},{"location":"internal/TODO/#current-state-summary","title":"Current State Summary","text":"<p>The Vexy JSON project has successfully completed its renaming from ZZSON. The codebase is: - Functionally correct - Builds and runs - Mostly consistent - Naming follows language conventions - Nearly release-ready - Only cleanup tasks remain</p>"},{"location":"internal/TODO/#next-steps","title":"Next Steps","text":"<ol> <li>Remove the ZZSON reference from line 8 of this file</li> <li>Run <code>cargo fix</code> to clean up simple warnings</li> <li>Investigate and fix the 8 failing tests</li> <li>Release version 2.3.1 as a \"post-migration cleanup\" release</li> </ol> <p>The project is in good shape with only minor housekeeping tasks remaining.</p> <p>and  Then run <code>./build.sh</code> and then check the <code>./build_logs</code>. If needed read the  code snapshot. Then /work on items from  consulting on  Then review reflect refine revise, and then continue to /work on </p>"},{"location":"internal/TODO/#this_file-docsinternalplanmd_1","title":"this_file: docs/internal/PLAN.md","text":""},{"location":"internal/TODO/#vexy-json-improvement-plan-v232-the-reference-implementation-removal-build-fixes_1","title":"Vexy JSON Improvement Plan - v2.3.2 the reference implementation Removal &amp; Build Fixes","text":""},{"location":"internal/TODO/#executive-summary_1","title":"Executive Summary","text":"<p>Following the successful project renaming to Vexy JSON, this plan addresses critical remaining issues:</p>"},{"location":"internal/TODO/#new-critical-issues-found-v232_1","title":"New Critical Issues Found (v2.3.2)","text":"<ol> <li>the reference implementation references removal - Found 50 files containing \"the reference implementation\" references that need cleanup</li> <li>Test failure - test_number_features failing due to number format parsing issues</li> <li>Build warnings - 3 unused variable warnings in examples/recursive_parser.rs</li> <li>Build status - Build succeeds but with warnings and 1 test failure</li> </ol>"},{"location":"internal/TODO/#completed-v230_1","title":"Completed (v2.3.0)","text":"<ol> <li>\u2705 C API naming fixed - Resolved struct name mismatches</li> <li>\u2705 Critical compilation errors fixed - Added missing struct fields and enum variants</li> <li>\u2705 README.md updated - Removed migration tool references</li> </ol>"},{"location":"internal/TODO/#current-status-v231_1","title":"Current Status (v2.3.1)","text":"<ol> <li>Naming consistency - Minor inconsistencies found in Python bindings</li> <li>Compilation warnings - 24 warnings (reduced from 30)</li> <li>Test failures - 8 failing tests remain</li> <li>Build successful - Core and CLI build without errors</li> <li>Documentation - Mostly consistent, one ZZSON reference remains</li> </ol>"},{"location":"internal/TODO/#post-migration-findings_1","title":"Post-Migration Findings","text":""},{"location":"internal/TODO/#naming-analysis-results_1","title":"Naming Analysis Results","text":"<ol> <li>Old Naming References: Only 2 files contain \"zzson\" - both in documentation (PLAN.md and issue 610.txt)</li> <li>Python Bindings: Test file previously used <code>VexyJSONParser</code> but was fixed to <code>VexyJsonParser</code></li> <li>Naming Conventions: Generally consistent across languages:</li> <li>Rust: <code>vexy_json-*</code> (crate names), <code>VexyJson*</code> (types)</li> <li>C/C++: <code>VexyJson*</code> (types)</li> <li>Python: <code>vexy_json</code> (package), <code>VexyJson*</code> (classes)</li> <li>JavaScript: <code>VexyJson*</code> (classes)</li> <li>Documentation: \"Vexy JSON\" (with space)</li> </ol>"},{"location":"internal/TODO/#priority-groups_1","title":"Priority Groups","text":""},{"location":"internal/TODO/#group-0-immediate-critical-fixes_1","title":"Group 0: IMMEDIATE - Critical Fixes","text":""},{"location":"internal/TODO/#01-remove-the-reference-implementation-references-50-files_1","title":"0.1 Remove the reference implementation References (50 files)","text":"<ul> <li>High Priority: Remove all \"the reference implementation\" references from codebase</li> <li>Files affected: 50 files including tests, documentation, and code</li> <li>Impact: Legacy naming that confuses project identity</li> <li>Categories to clean:</li> <li>Test files: <code>the reference implementation_*.rs</code>, <code>supported_the reference implementation.rs</code></li> <li>Documentation: HTML files, markdown files, tool descriptions</li> <li>Code references: Comments, variable names, function names</li> <li>Configuration: pyproject.toml, Cargo.toml references</li> </ul>"},{"location":"internal/TODO/#02-fix-test-failure-1-failure_1","title":"0.2 Fix Test Failure (1 failure)","text":"<ul> <li>test_number_features - Number format parsing for octal (0o77), binary (0b1010), underscore separators (1_000_000)</li> <li>Root cause: Parser doesn't support these number formats, or incorrectly identifies them as floats. The tests are failing because they expect <code>Number::Integer</code> but receive <code>Number::Float</code>.</li> <li>Fix needed: Implement support for these number formats, ensuring they are correctly parsed as integers when applicable. This involves modifying the number parsing logic in <code>crates/core/src/parser/number.rs</code> to handle binary, octal, hexadecimal, and underscore separators.</li> </ul>"},{"location":"internal/TODO/#03-fix-build-warnings-3-warnings_1","title":"0.3 Fix Build Warnings (3 warnings)","text":"<ul> <li>examples/recursive_parser.rs: 3 unused variable warnings</li> <li>Simple fix: Prefix variables with underscore or use the results</li> <li>Impact: Clean build output</li> </ul>"},{"location":"internal/TODO/#group-1-high-priority-clean-up-warnings_1","title":"Group 1: HIGH Priority - Clean Up Warnings","text":""},{"location":"internal/TODO/#11-dead-code-cleanup-24-warnings_1","title":"1.1 Dead Code Cleanup (24 warnings)","text":"<ul> <li>Unused methods: <code>analyze_custom_error</code>, <code>analyze_context_error</code>, <code>analyze_invalid_utf8</code></li> <li>Unused fields: <code>confidence</code>, <code>patterns</code>, <code>learned_patterns</code>, <code>lookahead_size</code>, etc.</li> <li>Unused variants: <code>StateChange</code>, <code>InsertString</code>, <code>ReplaceRange</code>, etc.</li> <li>Decision needed: Either implement these features or remove the dead code</li> </ul>"},{"location":"internal/TODO/#12-import-cleanup_1","title":"1.2 Import Cleanup","text":"<ul> <li>Fix unused imports in <code>trace_parse.rs</code></li> <li>Run <code>cargo fix</code> to automatically clean up simple warnings</li> <li>Target: Reduce warnings from 24 to under 10 (achieved 0 warnings!)</li> </ul>"},{"location":"internal/TODO/#group-2-medium-priority-post-release-improvements_1","title":"Group 2: MEDIUM Priority - Post-Release Improvements","text":""},{"location":"internal/TODO/#21-architecture-improvements_1","title":"2.1 Architecture Improvements","text":"<ul> <li>Complete the pattern-based error recovery system (currently stubbed)</li> <li>Implement the ML-based pattern recognition</li> <li>Finish the streaming parser implementation</li> <li>Optimize memory pool usage</li> </ul>"},{"location":"internal/TODO/#22-performance-enhancements_1","title":"2.2 Performance Enhancements","text":"<ul> <li>Remove dead code to reduce binary size</li> <li>Optimize hot paths identified by warnings</li> <li>Implement SIMD optimizations where applicable</li> </ul>"},{"location":"internal/TODO/#23-testing-infrastructure_1","title":"2.3 Testing Infrastructure","text":"<ul> <li>Add integration tests for all language bindings</li> <li>Create property-based tests for edge cases</li> <li>Set up continuous fuzzing</li> </ul>"},{"location":"internal/TODO/#group-3-low-priority-future-enhancements_1","title":"Group 3: LOW Priority - Future Enhancements","text":""},{"location":"internal/TODO/#31-plugin-system_1","title":"3.1 Plugin System","text":"<ul> <li>Design and implement a plugin architecture</li> <li>Create example plugins</li> <li>Document plugin development</li> </ul>"},{"location":"internal/TODO/#32-advanced-features_1","title":"3.2 Advanced Features","text":"<ul> <li>Incremental parsing for live editing</li> <li>Schema validation integration</li> <li>Advanced error recovery strategies</li> <li>JSON path query support</li> </ul>"},{"location":"internal/TODO/#implementation-plan_1","title":"Implementation Plan","text":""},{"location":"internal/TODO/#phase-1-the-reference-implementation-references-removal-immediate-2-3-hours_1","title":"Phase 1: the reference implementation References Removal (Immediate - 2-3 hours)","text":"<ol> <li>Rename test files: <code>the reference implementation_*.rs</code> \u2192 <code>vexy_json_*.rs</code> or <code>compat_*.rs</code></li> <li>Update documentation: Remove \"the reference implementation\" from HTML, markdown, and tool descriptions</li> <li>Clean code references: Replace \"the reference implementation\" with \"vexy_json\" in comments and variable names</li> <li>Update configurations: Clean pyproject.toml and Cargo.toml references</li> <li>Verify completeness: Re-run grep to ensure no \"the reference implementation\" references remain</li> </ol>"},{"location":"internal/TODO/#phase-2-build-fixes-30-minutes_1","title":"Phase 2: Build Fixes (30 minutes)","text":"<ol> <li>Fix unused variables: Prefix with underscore in examples/recursive_parser.rs</li> <li>Fix test failure: Investigate and fix test_number_features number format parsing</li> <li>Action: Modify <code>crates/core/src/parser/number.rs</code> to correctly parse binary (0b), octal (0o), hexadecimal (0x), and numbers with underscore separators. Ensure these are represented as <code>Number::Integer</code> where appropriate.</li> <li>Verify build: Run <code>./build.sh</code> to confirm clean build</li> </ol>"},{"location":"internal/TODO/#phase-3-final-verification-30-minutes_1","title":"Phase 3: Final Verification (30 minutes)","text":"<ol> <li>Run full test suite to ensure no regressions</li> <li>Check build output for warnings</li> <li>Verify all the reference implementation references are removed</li> </ol>"},{"location":"internal/TODO/#phase-4-release-preparation-1-day_1","title":"Phase 4: Release Preparation (1 day)","text":"<ol> <li>Run full test suite on all platforms.</li> <li>Update version to 2.3.1 in all Cargo.toml files.</li> <li>Update CHANGELOG.md with all fixes.</li> <li>Create git tag v2.3.1.</li> <li>Publish to crates.io.</li> </ol>"},{"location":"internal/TODO/#success-metrics_1","title":"Success Metrics","text":"<ul> <li>\u2705 Zero references to ZZSON in code</li> <li>\u2705 Successful build of core and CLI</li> <li>\u2b1c Reduced warnings to &lt; 10 (currently 24)</li> <li>\u2b1c All 8 failing tests fixed</li> <li>\u2b1c Clean documentation with no migration artifacts</li> </ul>"},{"location":"internal/TODO/#current-state-summary_1","title":"Current State Summary","text":"<p>The Vexy JSON project has successfully completed its renaming from ZZSON. The codebase is: - Functionally correct - Builds and runs - Mostly consistent - Naming follows language conventions - Nearly release-ready - Only cleanup tasks remain</p>"},{"location":"internal/TODO/#next-steps_1","title":"Next Steps","text":"<ol> <li>Remove the ZZSON reference from line 8 of this file</li> <li>Run <code>cargo fix</code> to clean up simple warnings</li> <li>Investigate and fix the 8 failing tests</li> <li>Release version 2.3.1 as a \"post-migration cleanup\" release</li> </ol> <p>The project is in good shape with only minor housekeeping tasks remaining.</p> <p>and  until every single item and issue has been fixed. Iterate iterate iterate! Do not stop, do not ask for confirmation. Work! When you're finishing one task or item, say \"Wait, but...\" and go on to the next task/item. It\u2019s CRUCIAL that we get to a solution that BUILDS everything correctly!</p>"},{"location":"internal/TODO/#unify-naming-conventions","title":"Unify Naming Conventions","text":"<p>This section outlines a detailed plan to unify the naming conventions across the Vexy JSON project, ensuring consistency in how the project name is represented in different contexts (code, documentation, configuration, etc.).</p>"},{"location":"internal/TODO/#naming-strategy-summary","title":"Naming Strategy Summary:","text":"<ul> <li><code>Vexy JSON</code> (Title Case with space): Primary human-readable project name. Use in documentation titles, user-facing messages, and general descriptive text.</li> <li><code>vexy_json</code> (snake_case): Rust crate names, Python package names, internal code references (variables, functions), and file/directory names where snake_case is conventional.</li> <li><code>VexyJson</code> (PascalCase): Rust and C/C++ type names (structs, enums, classes).</li> <li><code>vexy-json</code> (kebab-case): URLs, repository names, and CLI commands.</li> <li><code>VEXY_JSON</code> (All Caps with underscore): Reserved for constants or placeholders (e.g., <code>%%VEXY_JSON_VERSION%%</code>).</li> </ul>"},{"location":"internal/TODO/#implementation-steps","title":"Implementation Steps:","text":"<ul> <li> <p>[ ] Review and Update <code>README.md</code>:</p> <ul> <li>Ensure the main title is \"Vexy JSON\".</li> <li>Verify all descriptive text uses \"Vexy JSON\".</li> <li>Confirm code examples use <code>vexy_json</code> for imports and calls.</li> </ul> </li> <li> <p>[ ] Review and Update <code>AGENTS.md</code> and <code>CLAUDE.md</code>:</p> <ul> <li>Ensure project overview sections use <code>vexy_json</code> for the Rust library name and \"Vexy JSON\" for the overall project name in descriptive text.</li> <li>Verify consistency in crate names (<code>vexy_json-core</code>, <code>vexy_json-cli</code>, etc.).</li> </ul> </li> <li> <p>[ ] Review and Update <code>PLAN.md</code>:</p> <ul> <li>Ensure all references to the project name in descriptive text use \"Vexy JSON\".</li> <li>Confirm consistency in naming conventions for Rust, C/C++, Python, and JavaScript as per the strategy.</li> </ul> </li> <li> <p>[ ] Review and Update Rust Code (<code>.rs</code> files):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify <code>use vexy_json::...</code> and <code>use vexy_json_core::...</code> statements.</li> <li>Ensure function calls like <code>vexy_json::parse</code> are consistent.</li> <li>Check <code>Cargo.toml</code> files within <code>crates/</code> for <code>name = \"vexy_json-...\"</code> and <code>dependencies.vexy_json-core</code> etc.</li> <li>Action: If any Rust code uses <code>VexyJson</code> or <code>VEXYJSON</code> where <code>vexy_json</code> (snake_case) is expected for crate/module names or function calls, change it.</li> </ul> </li> <li><code>VexyJson</code> (PascalCase):<ul> <li>Verify struct and enum names (e.g., <code>VexyJsonParserOptions</code>, <code>VexyJsonParseResult</code>).</li> <li>Action: If any Rust code uses <code>vexy_json</code> or <code>VEXY_JSON</code> where <code>VexyJson</code> (PascalCase) is expected for type names, change it.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update Python Bindings (<code>bindings/python/</code>):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify <code>import vexy_json</code> and usage like <code>vexy_json.parse()</code>.</li> <li>Check <code>bindings/python/src/vexy_json/__init__.py</code> for package name and module-level documentation.</li> <li>Check <code>bindings/python/README.md</code> for installation instructions (<code>pip install vexy_json</code>) and code examples.</li> <li>Action: Ensure all Python code and documentation consistently use <code>vexy_json</code> (snake_case) for the package and its functions.</li> </ul> </li> <li><code>VexyJson</code> (PascalCase):<ul> <li>Verify class names like <code>VexyJsonParser</code> (if present, based on <code>WORK.md</code> fix).</li> <li>Action: If any Python code uses <code>vexy_json</code> or <code>VEXY_JSON</code> where <code>VexyJson</code> (PascalCase) is expected for class names, change it.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update C/C++ Bindings (<code>crates/c-api/</code>):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify C function names (e.g., <code>vexy_json_version</code>, <code>vexy_json_parse</code>).</li> <li>Check <code>crates/c-api/include/vexy_json.h</code> and <code>vexy_json.hpp</code> for function and namespace names.</li> <li>Action: Ensure consistency with <code>vexy_json</code> (snake_case) for C API functions and C++ namespace.</li> </ul> </li> <li><code>VexyJson</code> (PascalCase):<ul> <li>Verify struct names (e.g., <code>VexyJsonParserOptions</code>, <code>VexyJsonParseResult</code>).</li> <li>Action: Ensure consistency with <code>VexyJson</code> (PascalCase) for C/C++ types.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update JavaScript/WASM (<code>crates/wasm/</code>, <code>docs/assets/js/</code>):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify imports like <code>vexy_json_wasm.js</code>.</li> <li>Check <code>docs/assets/js/tool.js</code> for <code>trackingId: 'vexy_json-web-tool'</code> and console logs.</li> <li>Check <code>docs/assets/js/examples.js</code> for <code>name: \"vexy_json\"</code> and <code>description: 'Showcase of all vexy_json forgiving features together'</code>.</li> <li>Action: Ensure consistency with <code>vexy_json</code> (snake_case) for module names and internal JavaScript references.</li> </ul> </li> <li><code>VEXY_JSON</code> (All Caps with underscore):<ul> <li>Verify usage of <code>%%VEXY_JSON_VERSION%%</code> as a placeholder.</li> <li>Action: Ensure <code>VEXY_JSON</code> is only used for such placeholders.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update Configuration Files (<code>Cargo.toml</code>, <code>pyproject.toml</code>, <code>oss-fuzz/project.yaml</code>, <code>scripts/package.json</code>):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify <code>name</code> fields in <code>Cargo.toml</code> and <code>scripts/package.json</code>.</li> <li>Verify dependency names.</li> <li>Action: Ensure <code>vexy_json</code> (snake_case) is used for package/crate names.</li> </ul> </li> <li><code>vexy-json</code> (kebab-case):<ul> <li>Verify <code>repository</code> and <code>homepage</code> URLs in <code>Cargo.toml</code> and <code>oss-fuzz/project.yaml</code>.</li> <li>Verify references in <code>oss-fuzz/README.md</code> and <code>Formula/README.md</code>.</li> <li>Action: Ensure <code>vexy-json</code> (kebab-case) is used for URLs and repository names.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update Shell Scripts (<code>.sh</code> files):</p> <ul> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify <code>cargo build --bin vexy_json</code> and similar commands.</li> <li>Verify file paths like <code>target/release/vexy_json</code>.</li> <li>Action: Ensure <code>vexy_json</code> (snake_case) is used for binary names and related file paths.</li> </ul> </li> <li><code>VEXY_JSON</code> (All Caps with underscore):<ul> <li>Verify usage in generated <code>README.txt</code> (e.g., <code>VEXY_JSON v$VERSION</code>).</li> <li>Action: Confirm this usage is acceptable for generated output.</li> </ul> </li> </ul> </li> <li> <p>[ ] Review and Update Homebrew Formula (<code>Formula/vexy_json.rb</code>):</p> <ul> <li><code>VexyJson</code> (PascalCase):<ul> <li>Verify class name <code>class VexyJson &lt; Formula</code>.</li> <li>Action: Ensure this remains <code>VexyJson</code>.</li> </ul> </li> <li><code>vexy_json</code> (snake_case):<ul> <li>Verify <code>homepage</code>, <code>url</code>, <code>bin/vexy_json</code> references.</li> <li>Action: Ensure consistency with <code>vexy_json</code> (snake_case) for binary and URL components.</li> </ul> </li> </ul> </li> <li> <p>[ ] Final Verification:</p> <ul> <li>After making changes, re-run <code>rg -C 3 \"vexy\" &gt; grep.txt</code> and review the output to ensure all changes are applied correctly and no new inconsistencies are introduced.</li> <li>Run <code>./build.sh</code> to confirm the project still builds and tests pass (addressing the number parsing issue separately).</li> </ul> </li> </ul>"},{"location":"internal/WORK/","title":"this_file: docs/internal/WORK.md","text":""},{"location":"internal/WORK/#work-progress-v233","title":"Work Progress - v2.3.3","text":""},{"location":"internal/WORK/#completed-in-this-session","title":"Completed in this session","text":""},{"location":"internal/WORK/#critical-build-fixes","title":"Critical Build Fixes","text":"<ol> <li>\u2705 Fixed critical clippy errors that were blocking compilation:</li> <li>Fixed <code>while-let-on-iterator</code> warning in parallel.rs (line 246)</li> <li>Fixed <code>uninlined-format-args</code> in parallel.rs (line 158)</li> <li>Fixed <code>should_implement_trait</code> warning in parallel_chunked.rs by implementing Default trait</li> <li>Fixed <code>type-complexity</code> warnings by introducing type aliases (ParseResult, MergedResults)</li> <li> <p>Fixed unused mut warning in parallel.rs (line 244)</p> </li> <li> <p>\u2705 Verified test_number_features is now passing</p> </li> <li> <p>\u2705 Created scripts for the reference implementation reference removal:</p> </li> <li>remove_the reference implementation_refs.sh (general replacement)</li> <li>remove_the reference implementation_refs_targeted.sh (careful targeted replacement)</li> <li>Partially executed targeted removal (reduced references but many remain)</li> </ol>"},{"location":"internal/WORK/#build-status","title":"Build Status","text":"<ul> <li>Core library now builds successfully with only non-critical warnings</li> <li>All tests are passing</li> <li>Ready to proceed with non-critical improvements</li> </ul>"},{"location":"internal/WORK/#next-steps","title":"Next Steps","text":"<ol> <li>Complete the reference implementation reference removal - Still ~1800 references across 41 files</li> <li>Focus on test files and documentation</li> <li>Preserve important compatibility notes</li> <li> <p>Update web assets (rename the reference implementation-tool.js)</p> </li> <li> <p>Fix remaining clippy warnings - 100+ uninlined-format-args warnings</p> </li> <li>Can use <code>cargo fix</code> for automatic fixing</li> <li> <p>Review changes before committing</p> </li> <li> <p>Work on naming unification (issues/611.txt)</p> </li> <li> <p>Ensure consistent naming across all language bindings</p> </li> <li> <p>Improve build deliverables (issues/620.txt)</p> </li> <li>Create proper packaging for each platform</li> <li>macOS: .dmg with .pkg installer</li> <li>Windows: .zip with .exe</li> <li> <p>Linux: .tgz with executable</p> </li> <li> <p>Release v2.3.3</p> </li> <li>Update version numbers</li> <li>Update CHANGELOG.md</li> <li>Create release tag</li> <li>Publish to crates.io</li> </ol>"},{"location":"internal/naming-unification-plan/","title":"Naming Unification Plan for Vexy JSON","text":""},{"location":"internal/naming-unification-plan/#current-naming-conventions","title":"Current Naming Conventions","text":"<p>Based on analysis of the codebase, here are the current naming patterns:</p> <ol> <li>Project Name: \"Vexy JSON\" (with space)</li> <li>Rust Crate Names: <code>vexy-json-*</code> (hyphenated)</li> <li>Rust Module Names: <code>vexy_json_*</code> (underscored)</li> <li>Import Paths: <code>vexy_json</code> (underscored)</li> <li>Type Names: <code>VexyJson*</code> (PascalCase)</li> <li>Binaries: <code>vexy_json</code> (underscored)</li> <li>Web Assets: Mixed (<code>vexy-json-tool.js</code>, <code>vexy_json-tool</code>)</li> <li>URLs: Mixed patterns</li> </ol>"},{"location":"internal/naming-unification-plan/#recommended-naming-standards","title":"Recommended Naming Standards","text":""},{"location":"internal/naming-unification-plan/#1-human-readable-contexts","title":"1. Human-Readable Contexts","text":"<ul> <li>Project Name: \"Vexy JSON\" (with space)</li> <li>Documentation Headers: \"Vexy JSON\"</li> <li>GitHub Repo: <code>vexy-json</code> (hyphenated)</li> <li>URLs: <code>vexy-json</code> (hyphenated)</li> </ul>"},{"location":"internal/naming-unification-plan/#2-rustcargo-contexts","title":"2. Rust/Cargo Contexts","text":"<ul> <li>Crate Names: <code>vexy-json-*</code> (hyphenated) - Required by Cargo</li> <li>Binary Name: <code>vexy_json</code> (underscored) - For CLI consistency</li> <li>Module Names: <code>vexy_json_*</code> (underscored) - Rust convention</li> <li>Import Paths: <code>vexy_json</code> (underscored) - Rust convention</li> <li>Type Names: <code>VexyJson*</code> (PascalCase) - Rust convention</li> </ul>"},{"location":"internal/naming-unification-plan/#3-language-bindings","title":"3. Language Bindings","text":"<ul> <li>Python Package: <code>vexy-json</code> (hyphenated) - PyPI convention</li> <li>Python Module: <code>vexy_json</code> (underscored) - Python import convention</li> <li>NPM Package: <code>@vexy-json/vexy-json</code> (hyphenated) - NPM convention</li> <li>C/C++ Headers: <code>vexy_json.h</code> (underscored)</li> <li>C/C++ Types: <code>VexyJson*</code> (PascalCase)</li> </ul>"},{"location":"internal/naming-unification-plan/#4-web-assets","title":"4. Web Assets","text":"<ul> <li>JavaScript Files: <code>vexy-json-*.js</code> (hyphenated)</li> <li>HTML IDs: <code>vexy-json-*</code> (hyphenated)</li> <li>CSS Classes: <code>vexy-json-*</code> (hyphenated)</li> <li>Tool URLs: <code>/vexy-json-tool/</code> (hyphenated)</li> </ul>"},{"location":"internal/naming-unification-plan/#specific-changes-needed","title":"Specific Changes Needed","text":""},{"location":"internal/naming-unification-plan/#high-priority","title":"High Priority","text":"<ol> <li>Standardize Web Tool URLs:</li> <li>Change: <code>/vexy_json-tool/</code> \u2192 <code>/vexy-json-tool/</code></li> <li> <p>Redirect old URLs for compatibility</p> </li> <li> <p>Unify JavaScript Asset Names:</p> </li> <li> <p>Rename inconsistent files to use <code>vexy-json-*</code> pattern</p> </li> <li> <p>Fix Mixed URL References:</p> </li> <li>Update all GitHub URLs to use consistent pattern</li> <li>Use <code>vexy-json</code> in URLs, not <code>vexy_json</code></li> </ol>"},{"location":"internal/naming-unification-plan/#medium-priority","title":"Medium Priority","text":"<ol> <li>Documentation Consistency:</li> <li>Ensure \"Vexy JSON\" (with space) in all prose</li> <li> <p>Use backticks for code references: <code>vexy_json</code></p> </li> <li> <p>Update Package Metadata:</p> </li> <li>Ensure all package.json, Cargo.toml files use correct naming</li> </ol>"},{"location":"internal/naming-unification-plan/#low-priority","title":"Low Priority","text":"<ol> <li>Internal Variable Names:</li> <li>Keep existing internal naming unless refactoring</li> <li>Follow language conventions when adding new code</li> </ol>"},{"location":"internal/naming-unification-plan/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Create Naming Lint Script:</li> <li>Script to check for naming violations</li> <li> <p>Run in CI to prevent regressions</p> </li> <li> <p>Update Documentation:</p> </li> <li>Batch update all markdown files</li> <li> <p>Update HTML/web assets</p> </li> <li> <p>Add Redirects:</p> </li> <li>Set up URL redirects for changed paths</li> <li> <p>Maintain backward compatibility</p> </li> <li> <p>Update Package Metadata:</p> </li> <li>Cargo.toml files</li> <li>package.json files</li> <li> <p>pyproject.toml files</p> </li> <li> <p>Test All Changes:</p> </li> <li>Verify imports still work</li> <li>Check all URLs resolve</li> <li>Test package installations</li> </ol>"},{"location":"internal/naming-unification-plan/#summary","title":"Summary","text":"<p>The key principle is to use: - \"Vexy JSON\" (with space) for human-readable contexts - <code>vexy-json</code> (hyphenated) for URLs and package names - <code>vexy_json</code> (underscored) for code imports and binaries - <code>VexyJson</code> (PascalCase) for type names</p> <p>This maintains consistency while respecting the conventions of each ecosystem.</p>"},{"location":"internal/development/RELEASE_CANDIDATE/","title":"Vexy JSON v2.0-RC1 Release Candidate","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#release-overview","title":"\ud83c\udfaf Release Overview","text":"<p>This release candidate represents a major architectural and performance milestone for Vexy JSON, featuring comprehensive improvements in parsing speed, memory efficiency, and extensibility.</p>"},{"location":"internal/development/RELEASE_CANDIDATE/#major-features-completed","title":"\u2705 Major Features Completed","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#performance-optimization","title":"Performance &amp; Optimization","text":"<ul> <li>\u2705 SIMD-Accelerated Parsing - 2-3x performance improvement for large files</li> <li>\u2705 Memory Pool V3 - 80% reduction in allocations with typed arenas</li> <li>\u2705 Parallel Processing - Intelligent chunked processing for large JSON files</li> <li>\u2705 Performance Quick Wins - LTO, FxHashMap, inline hints implemented</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#architecture-extensibility","title":"Architecture &amp; Extensibility","text":"<ul> <li>\u2705 Streaming Parser V2 - Event-driven API for gigabyte-sized files</li> <li>\u2705 Plugin System - Extensible architecture with ParserPlugin trait</li> <li>\u2705 Modular Architecture - Clean separation with JsonLexer traits</li> <li>\u2705 AST Builder &amp; Visitor - Comprehensive AST manipulation capabilities</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#quality-reliability","title":"Quality &amp; Reliability","text":"<ul> <li>\u2705 Error Recovery V2 - ML-based pattern recognition with actionable suggestions</li> <li>\u2705 Comprehensive Fuzzing - 4 specialized targets with extensive coverage</li> <li>\u2705 Enhanced Error Messages - Context-aware suggestions and recovery strategies</li> <li>\u2705 Type-Safe Error Handling - Comprehensive error taxonomy with structured codes</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#release-candidate-metrics","title":"\ud83d\udcca Release Candidate Metrics","text":"<ul> <li>65 Rust files in core module</li> <li>130 total Rust files across project  </li> <li>~17,300 lines of code in core implementation</li> <li>Comprehensive test coverage with property-based and fuzz testing</li> <li>Zero critical security vulnerabilities</li> <li>Memory-safe implementation with extensive error handling</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#performance-improvements","title":"\ud83c\udfaf Performance Improvements","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#parsing-speed","title":"Parsing Speed","text":"<ul> <li>2-3x faster string scanning with SIMD optimization</li> <li>Parallel processing for files &gt; 1MB with intelligent boundary detection</li> <li>Optimized memory allocation patterns with arena-based allocation</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#memory-efficiency","title":"Memory Efficiency","text":"<ul> <li>80% reduction in allocations for typical workloads</li> <li>String interning for common JSON keys</li> <li>Zero-copy parsing paths for simple values</li> <li>Streaming capability for minimal memory usage on large files</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#developer-experience","title":"Developer Experience","text":"<ul> <li>Enhanced error messages with actionable suggestions</li> <li>Plugin architecture for custom parsing logic</li> <li>Comprehensive API for both high-level and low-level usage</li> <li>Detailed performance metrics and debugging capabilities</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#api-highlights","title":"\ud83d\udd27 API Highlights","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#core-parsing-api","title":"Core Parsing API","text":"<pre><code>use vexy_json::{parse, parse_with_options, ParserOptions};\n\n// Simple parsing\nlet value = parse(r#\"{\"key\": \"value\"}\"#)?;\n\n// Advanced parsing with options\nlet options = ParserOptions {\n    allow_comments: true,\n    allow_trailing_commas: true,\n    max_depth: 1000,\n    ..Default::default()\n};\nlet value = parse_with_options(input, options)?;\n</code></pre>"},{"location":"internal/development/RELEASE_CANDIDATE/#streaming-api","title":"Streaming API","text":"<pre><code>use vexy_json::streaming::StreamingParser;\n\nlet mut parser = StreamingParser::new();\nfor chunk in file_chunks {\n    parser.process_chunk(chunk)?;\n}\nlet value = parser.finalize()?;\n</code></pre>"},{"location":"internal/development/RELEASE_CANDIDATE/#parallel-processing-api","title":"Parallel Processing API","text":"<pre><code>use vexy_json::parallel_chunked::{parse_parallel_chunked, ChunkedConfig};\n\nlet config = ChunkedConfig {\n    chunk_size: 1024 * 1024, // 1MB chunks\n    max_threads: 8,\n    ..Default::default()\n};\nlet result = parse_parallel_chunked(large_json_input, config)?;\n</code></pre>"},{"location":"internal/development/RELEASE_CANDIDATE/#plugin-system-api","title":"Plugin System API","text":"<pre><code>use vexy_json::plugin::{ParserPlugin, PluginRegistry};\n\nstruct CustomPlugin;\nimpl ParserPlugin for CustomPlugin {\n    fn name(&amp;self) -&gt; &amp;str { \"custom\" }\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        // Custom transformation logic\n        Ok(())\n    }\n}\n\nlet mut registry = PluginRegistry::new();\nregistry.register(Box::new(CustomPlugin))?;\n</code></pre>"},{"location":"internal/development/RELEASE_CANDIDATE/#testing-quality-assurance","title":"\ud83e\uddea Testing &amp; Quality Assurance","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#test-coverage","title":"Test Coverage","text":"<ul> <li>Unit tests for all core components</li> <li>Integration tests for real-world scenarios</li> <li>Property-based testing with QuickCheck</li> <li>Fuzzing campaigns with 4 specialized targets</li> <li>Performance regression tests with criterion benchmarks</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#quality-metrics","title":"Quality Metrics","text":"<ul> <li>Comprehensive error handling with structured error types</li> <li>Memory safety with extensive bounds checking</li> <li>Thread safety for parallel processing components</li> <li>API documentation coverage at 95%+</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#migration-guide","title":"\ud83d\udd04 Migration Guide","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#from-v1x","title":"From v1.x","text":"<ul> <li>Core parsing API remains compatible</li> <li>New streaming and parallel APIs are additive</li> <li>Plugin system is entirely new (opt-in)</li> <li>Performance improvements are automatic</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Error types have been restructured (but improved)</li> <li>Some internal APIs have changed (public API stable)</li> <li>Memory pool behavior may affect custom allocators</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#known-limitations","title":"\ud83d\udea7 Known Limitations","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#not-included-in-rc1","title":"Not Included in RC1","text":"<ul> <li>Plugin implementations - Schema validation, datetime parsing (planned for v2.1)</li> <li>Enhanced CLI features - Interactive mode, advanced operations (planned for v2.2)</li> <li>Language bindings - Python/WASM optimizations (planned for v2.x)</li> <li>Additional parsers - Recursive descent, iterative parsers (planned for v2.1)</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>SIMD optimizations require compatible CPU features (automatic fallback)</li> <li>Parallel processing has overhead for small files (&lt; 1MB)</li> <li>Memory pool benefits are most apparent with repeated parsing</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#success-criteria-for-final-release","title":"\ud83c\udfaf Success Criteria for Final Release","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#performance-targets","title":"Performance Targets \u2705","text":"<ul> <li>\u2705 2-3x parsing speed improvement achieved</li> <li>\u2705 50%+ memory usage reduction achieved  </li> <li>\u2705 Streaming capability for gigabyte files implemented</li> <li>\u2705 Parallel processing for large files working</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#quality-targets","title":"Quality Targets \u2705","text":"<ul> <li>\u2705 95%+ test coverage with comprehensive test suite</li> <li>\u2705 Fuzzing infrastructure with continuous testing</li> <li>\u2705 Error recovery with actionable suggestions</li> <li>\u2705 Memory safety with extensive validation</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#api-stability","title":"API Stability","text":"<ul> <li>\u2705 Core parsing API stable and backwards compatible</li> <li>\u2705 Streaming API designed for long-term stability</li> <li>\u2705 Plugin system extensible architecture established</li> <li>\u2705 Error handling comprehensive and well-structured</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#release-timeline","title":"\ud83d\ude80 Release Timeline","text":""},{"location":"internal/development/RELEASE_CANDIDATE/#rc1-final-release-path","title":"RC1 \u2192 Final Release Path","text":"<ol> <li>Community feedback collection (2-4 weeks)</li> <li>Bug fixes and API refinements based on feedback</li> <li>Documentation completion and review</li> <li>Performance validation on diverse workloads</li> <li>Final release as Vexy JSON v2.0.0</li> </ol>"},{"location":"internal/development/RELEASE_CANDIDATE/#post-v20-roadmap","title":"Post-v2.0 Roadmap","text":"<ul> <li>v2.1: Plugin ecosystem expansion</li> <li>v2.2: Enhanced CLI and tooling</li> <li>v2.x: Language binding optimizations</li> </ul>"},{"location":"internal/development/RELEASE_CANDIDATE/#feedback-contributions","title":"\ud83d\udcdd Feedback &amp; Contributions","text":"<p>We welcome feedback on: - API design and usability - Performance on real-world workloads - Plugin system extensibility and use cases - Documentation clarity and completeness - Migration experience from v1.x</p>"},{"location":"internal/development/RELEASE_CANDIDATE/#acknowledgments","title":"\ud83c\udfc6 Acknowledgments","text":"<p>This release represents a significant evolution of Vexy JSON, with major architectural improvements, performance optimizations, and quality enhancements that establish a solid foundation for future development.</p> <p>Ready for community testing and feedback! \ud83c\udf89</p>"},{"location":"internal/development/RELEASE_CHECKLIST/","title":"Vexy JSON Release Checklist","text":"<p>This checklist guides the release process for Vexy JSON. Follow these steps to ensure a smooth release.</p>"},{"location":"internal/development/RELEASE_CHECKLIST/#pre-release-verification","title":"Pre-Release Verification","text":""},{"location":"internal/development/RELEASE_CHECKLIST/#1-code-quality","title":"1. Code Quality","text":"<ul> <li>[ ] All tests pass: <code>./build.sh</code></li> <li>[ ] No critical bugs or issues</li> <li>[ ] Documentation is up to date</li> <li>[ ] CHANGELOG.md reflects all changes</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#2-version-verification","title":"2. Version Verification","text":"<ul> <li>[ ] Version numbers are consistent across all files</li> <li>[ ] Run <code>./scripts/get-version.sh</code> to verify current version</li> <li>[ ] Ensure version follows semantic versioning</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#3-build-verification","title":"3. Build Verification","text":"<ul> <li>[ ] Release build completes: <code>cargo build --release</code></li> <li>[ ] All examples compile: <code>cargo build --examples</code></li> <li>[ ] Benchmarks run: <code>cargo bench</code></li> <li>[ ] Cross-platform builds work (if applicable)</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#release-process","title":"Release Process","text":""},{"location":"internal/development/RELEASE_CHECKLIST/#1-final-preparation","title":"1. Final Preparation","text":"<ul> <li>[ ] Ensure working directory is clean: <code>git status</code></li> <li>[ ] All changes are committed</li> <li>[ ] On the correct branch (usually <code>main</code>)</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#2-execute-release","title":"2. Execute Release","text":"<pre><code># Run the release script with the new version\n./release.sh &lt;version&gt;\n\n# Example:\n./release.sh 2.0.0\n</code></pre>"},{"location":"internal/development/RELEASE_CHECKLIST/#3-release-script-actions","title":"3. Release Script Actions","text":"<p>The release script will automatically: - Update version numbers across all files - Create a git tag with 'v' prefix - Build release artifacts in <code>dist/</code> - Commit all changes - Push commits and tags to GitHub</p>"},{"location":"internal/development/RELEASE_CHECKLIST/#4-post-release-verification","title":"4. Post-Release Verification","text":"<ul> <li>[ ] Check GitHub for the new tag</li> <li>[ ] Verify release artifacts in <code>dist/</code> directory</li> <li>[ ] Test installation from release artifacts</li> <li>[ ] Update any package registries (crates.io, npm, etc.)</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#platform-specific-releases","title":"Platform-Specific Releases","text":""},{"location":"internal/development/RELEASE_CHECKLIST/#cratesio-rust","title":"Crates.io (Rust)","text":"<pre><code>cd crates/core &amp;&amp; cargo publish\ncd ../serde &amp;&amp; cargo publish\ncd ../cli &amp;&amp; cargo publish\n</code></pre>"},{"location":"internal/development/RELEASE_CHECKLIST/#npm-webassembly","title":"NPM (WebAssembly)","text":"<pre><code>cd crates/wasm\nwasm-pack build --release\ncd pkg &amp;&amp; npm publish\n</code></pre>"},{"location":"internal/development/RELEASE_CHECKLIST/#homebrew-macos","title":"Homebrew (macOS)","text":"<ul> <li>[ ] Update Formula/vexy_json.rb with new version and SHA256</li> <li>[ ] Test installation: <code>brew install --build-from-source ./Formula/vexy_json.rb</code></li> <li>[ ] Submit PR to homebrew-core (if applicable)</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#communication","title":"Communication","text":""},{"location":"internal/development/RELEASE_CHECKLIST/#1-release-notes","title":"1. Release Notes","text":"<ul> <li>[ ] Create GitHub release with changelog</li> <li>[ ] Highlight breaking changes</li> <li>[ ] Thank contributors</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#2-announcements","title":"2. Announcements","text":"<ul> <li>[ ] Update project README with new version</li> <li>[ ] Post to relevant forums/communities</li> <li>[ ] Update documentation site</li> </ul>"},{"location":"internal/development/RELEASE_CHECKLIST/#rollback-plan","title":"Rollback Plan","text":"<p>If issues are discovered post-release: 1. Document the issue 2. Decide on fix urgency 3. If critical:    - Prepare patch release (x.y.z+1)    - Follow expedited release process 4. If non-critical:    - Schedule for next regular release    - Document in known issues</p>"},{"location":"internal/development/RELEASE_CHECKLIST/#notes","title":"Notes","text":"<ul> <li>Always test the release process with <code>--dry-run</code> first</li> <li>Keep release commits atomic and focused</li> <li>Tag releases consistently with 'v' prefix (e.g., v2.0.0)</li> <li>Maintain backward compatibility when possible</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/","title":"Vexy JSON Release Process","text":"<p>This document describes the complete release process for Vexy JSON v2.0.0 and future versions.</p>"},{"location":"internal/development/RELEASE_PROCESS/#overview","title":"Overview","text":"<p>The Vexy JSON release process is fully automated using GitHub Actions. When you push a version tag (e.g., <code>v2.0.0</code>), the following happens automatically:</p> <ol> <li>CI/CD Pipeline runs all tests on multiple platforms</li> <li>Release Workflow creates binaries for all platforms</li> <li>Installers are built (macOS DMG with PKG)</li> <li>WASM modules are compiled and packaged</li> <li>GitHub Release is created with all artifacts</li> <li>Publishing to crates.io and npm</li> <li>Documentation is updated on GitHub Pages</li> </ol>"},{"location":"internal/development/RELEASE_PROCESS/#prerequisites","title":"Prerequisites","text":"<p>Before releasing, ensure you have:</p> <ul> <li>[ ] GitHub CLI (<code>gh</code>) installed and authenticated</li> <li>[ ] Rust toolchain installed</li> <li>[ ] Write access to the repository</li> <li>[ ] API tokens configured (see below)</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#required-secrets","title":"Required Secrets","text":"<p>Configure these secrets in your GitHub repository settings:</p> <ul> <li><code>CARGO_REGISTRY_TOKEN</code> - For publishing to crates.io</li> <li><code>NPM_TOKEN</code> - For publishing to npm</li> <li><code>HOMEBREW_GITHUB_TOKEN</code> - For updating Homebrew formula (optional)</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#release-steps","title":"Release Steps","text":""},{"location":"internal/development/RELEASE_PROCESS/#1-pre-release-checklist","title":"1. Pre-Release Checklist","text":"<p>Run the pre-release check script:</p> <pre><code>./scripts/pre-release-check.sh\n</code></pre> <p>This validates: - Version numbers are consistent - Documentation is updated - GitHub Actions workflows exist - Code builds successfully - Working directory is clean</p>"},{"location":"internal/development/RELEASE_PROCESS/#2-quick-release-recommended","title":"2. Quick Release (Recommended)","text":"<p>For a standard release, use the GitHub release script:</p> <pre><code>./scripts/release-github.sh --version 2.0.0\n</code></pre> <p>This script will: - Run pre-release checks - Execute tests - Create and push the git tag - Monitor the GitHub Actions workflow</p>"},{"location":"internal/development/RELEASE_PROCESS/#3-manual-release","title":"3. Manual Release","text":"<p>If you prefer manual control:</p> <pre><code># 1. Run tests\ncargo test --all-features\n\n# 2. Create tag\ngit tag -a v2.0.0 -m \"Release v2.0.0\"\n\n# 3. Push tag\ngit push origin v2.0.0\n\n# 4. Monitor GitHub Actions\ngh run watch\n</code></pre>"},{"location":"internal/development/RELEASE_PROCESS/#4-alternative-trigger-via-github-ui","title":"4. Alternative: Trigger via GitHub UI","text":"<p>You can also trigger a release from the GitHub Actions tab:</p> <ol> <li>Go to Actions \u2192 Release workflow</li> <li>Click \"Run workflow\"</li> <li>Enter the version (e.g., \"2.0.0\")</li> <li>Click \"Run workflow\"</li> </ol>"},{"location":"internal/development/RELEASE_PROCESS/#release-artifacts","title":"Release Artifacts","text":"<p>The automated release creates:</p>"},{"location":"internal/development/RELEASE_PROCESS/#binaries","title":"Binaries","text":"<ul> <li>macOS: Universal binary (x86_64 + ARM64)</li> <li><code>vexy_json-2.0.0-macos.zip</code> - Standalone binary</li> <li><code>vexy_json-2.0.0-macos.dmg</code> - Installer with PKG</li> <li>Linux: </li> <li><code>vexy_json-2.0.0-linux-x86_64.tar.gz</code> - x86_64 binary</li> <li><code>vexy_json-2.0.0-linux-aarch64.tar.gz</code> - ARM64 binary</li> <li>Windows:</li> <li><code>vexy_json-2.0.0-windows-x86_64.zip</code> - x86_64 binary</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#wasm-package","title":"WASM Package","text":"<ul> <li><code>vexy_json-wasm-2.0.0.tar.gz</code> - WebAssembly module with TypeScript bindings</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#source","title":"Source","text":"<ul> <li>Source code archives (automatically created by GitHub)</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#platform-specific-details","title":"Platform-Specific Details","text":""},{"location":"internal/development/RELEASE_PROCESS/#macos-installer","title":"macOS Installer","text":"<p>The macOS installer includes: - Universal binary supporting Intel and Apple Silicon - PKG installer that places <code>vexy_json</code> in <code>/usr/local/bin</code> - Code-signed DMG (requires Apple Developer certificate) - Automatic PATH configuration</p>"},{"location":"internal/development/RELEASE_PROCESS/#linux-packages","title":"Linux Packages","text":"<p>Future releases will include: - <code>.deb</code> packages for Debian/Ubuntu - <code>.rpm</code> packages for Fedora/RHEL - AppImage for universal Linux support</p>"},{"location":"internal/development/RELEASE_PROCESS/#windows-installer","title":"Windows Installer","text":"<p>Future releases will include: - MSI installer with PATH configuration - Chocolatey package</p>"},{"location":"internal/development/RELEASE_PROCESS/#post-release","title":"Post-Release","text":"<p>After the release is published:</p> <ol> <li> <p>Verify Installation Methods:    <pre><code># Homebrew (macOS)\nbrew update &amp;&amp; brew install vexy_json\n\n# Cargo\ncargo install vexy_json-cli\n\n# npm (WASM)\nnpm install vexy_json-wasm\n</code></pre></p> </li> <li> <p>Update Documentation:</p> </li> <li>The docs site auto-updates via GitHub Pages</li> <li> <p>Verify at: https://twardoch.github.io/vexy_json/</p> </li> <li> <p>Announce Release:</p> </li> <li>GitHub Discussions</li> <li>Twitter/Social Media</li> <li>Rust Forums</li> <li>Reddit (r/rust)</li> </ol>"},{"location":"internal/development/RELEASE_PROCESS/#troubleshooting","title":"Troubleshooting","text":""},{"location":"internal/development/RELEASE_PROCESS/#release-workflow-fails","title":"Release Workflow Fails","text":"<ol> <li>Check GitHub Actions logs</li> <li>Common issues:</li> <li>Missing secrets (CARGO_REGISTRY_TOKEN, etc.)</li> <li>Version already published</li> <li>Test failures on specific platforms</li> </ol>"},{"location":"internal/development/RELEASE_PROCESS/#tag-already-exists","title":"Tag Already Exists","text":"<pre><code># Delete local tag\ngit tag -d v2.0.0\n\n# Delete remote tag\ngit push origin :refs/tags/v2.0.0\n\n# Recreate tag\ngit tag -a v2.0.0 -m \"Release v2.0.0\"\ngit push origin v2.0.0\n</code></pre>"},{"location":"internal/development/RELEASE_PROCESS/#partial-release","title":"Partial Release","text":"<p>If some artifacts fail: 1. Fix the issue 2. Re-run failed jobs in GitHub Actions 3. The release will update automatically</p>"},{"location":"internal/development/RELEASE_PROCESS/#version-numbering","title":"Version Numbering","text":"<p>Vexy JSON follows Semantic Versioning:</p> <ul> <li>Major (X.0.0): Breaking API changes</li> <li>Minor (0.X.0): New features, backward compatible</li> <li>Patch (0.0.X): Bug fixes</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#release-frequency","title":"Release Frequency","text":"<ul> <li>Major releases: Annually or as needed</li> <li>Minor releases: Quarterly</li> <li>Patch releases: As needed for critical fixes</li> </ul>"},{"location":"internal/development/RELEASE_PROCESS/#security-releases","title":"Security Releases","text":"<p>For security fixes: 1. Follow responsible disclosure 2. Prepare fix in private 3. Release with security advisory 4. Backport to supported versions</p>"},{"location":"internal/development/RELEASE_PROCESS/#appendix-local-testing","title":"Appendix: Local Testing","text":"<p>To test the release process locally:</p> <pre><code># Dry run of release script\n./scripts/release-github.sh --version 2.0.0 --dry-run\n\n# Test build scripts\n./build.sh --all\n\n# Test packaging\n./scripts/package-macos.sh 2.0.0\n</code></pre>"},{"location":"internal/development/RELEASE_PROCESS/#support","title":"Support","text":"<p>For release issues: - Open an issue on GitHub - Contact maintainers - Check GitHub Actions documentation</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/","title":"Vexy JSON v2.0.0 Release Summary","text":""},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#what-has-been-completed","title":"What Has Been Completed","text":""},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#1-github-actions-workflows","title":"1. GitHub Actions Workflows","text":"<p>Created comprehensive CI/CD pipeline with: - CI Workflow (<code>.github/workflows/ci.yml</code>): Runs tests, linting, coverage, fuzzing, and WASM builds - Release Workflow (<code>.github/workflows/release.yml</code>): Automated release process for all platforms - Fuzz Workflow (<code>.github/workflows/fuzz.yml</code>): Daily fuzzing tests - Docs Workflow (<code>.github/workflows/docs.yml</code>): Jekyll documentation deployment - Badges Workflow (<code>.github/workflows/badges.yml</code>): Badge updates</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#2-documentation-updates","title":"2. Documentation Updates","text":"<ul> <li>README.md: Updated with v2.0.0 features, performance metrics, and examples</li> <li>Documentation Site: Updated all docs with v2.0.0 APIs, streaming, parallel processing, and plugins</li> <li>Migration Guide: Added v1.x to v2.0.0 migration instructions</li> <li>Release Notes: Comprehensive v2.0.0 changelog</li> </ul>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#3-version-updates","title":"3. Version Updates","text":"<p>All version numbers updated to 2.0.0 in: - All Cargo.toml files - Python bindings (pyproject.toml) - WASM package.json - Homebrew formula - Documentation examples</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#4-release-infrastructure","title":"4. Release Infrastructure","text":"<ul> <li>Pre-release Check Script: <code>scripts/pre-release-check.sh</code></li> <li>GitHub Release Script: <code>scripts/release-github.sh</code></li> <li>Release Process Documentation: <code>RELEASE_PROCESS.md</code></li> </ul>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#how-to-release-v200","title":"How to Release v2.0.0","text":""},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#option-1-automated-release-recommended","title":"Option 1: Automated Release (Recommended)","text":"<pre><code># Commit all changes\ngit add .\ngit commit -m \"Prepare v2.0.0 release\"\n\n# Run the GitHub release script\n./scripts/release-github.sh --version 2.0.0\n</code></pre>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#option-2-manual-release","title":"Option 2: Manual Release","text":"<pre><code># Commit all changes\ngit add .\ngit commit -m \"Prepare v2.0.0 release\"\n\n# Create and push tag\ngit tag -a v2.0.0 -m \"Release v2.0.0\"\ngit push origin main\ngit push origin v2.0.0\n</code></pre>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#what-happens-next","title":"What Happens Next","text":"<p>When you push the <code>v2.0.0</code> tag, GitHub Actions automatically:</p> <ol> <li>Builds binaries for:</li> <li>macOS (universal binary + DMG installer with PKG)</li> <li>Linux (x86_64 and ARM64)</li> <li> <p>Windows (x86_64)</p> </li> <li> <p>Creates packages:</p> </li> <li>WASM modules with TypeScript bindings</li> <li> <p>Source archives</p> </li> <li> <p>Publishes to:</p> </li> <li>crates.io (Rust packages)</li> <li>npm (WASM package)</li> <li> <p>GitHub Releases</p> </li> <li> <p>Creates release with:</p> </li> <li>All binary artifacts</li> <li>Installation instructions</li> <li>Changelog</li> </ol>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#required-github-secrets","title":"Required GitHub Secrets","text":"<p>Before releasing, ensure these secrets are configured in your repository settings: - <code>CARGO_REGISTRY_TOKEN</code> - For crates.io publishing - <code>NPM_TOKEN</code> - For npm publishing - <code>HOMEBREW_GITHUB_TOKEN</code> - For Homebrew updates (optional)</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#deliverables","title":"Deliverables","text":"<p>The v2.0.0 release will include:</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#binaries","title":"Binaries","text":"<ul> <li><code>vexy_json-2.0.0-macos.dmg</code> - macOS installer with PKG</li> <li><code>vexy_json-2.0.0-macos.zip</code> - macOS standalone binary</li> <li><code>vexy_json-2.0.0-linux-x86_64.tar.gz</code> - Linux x86_64</li> <li><code>vexy_json-2.0.0-linux-aarch64.tar.gz</code> - Linux ARM64</li> <li><code>vexy_json-2.0.0-windows-x86_64.zip</code> - Windows x86_64</li> <li><code>vexy_json-wasm-2.0.0.tar.gz</code> - WASM package</li> </ul>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#features","title":"Features","text":"<ul> <li>SIMD-accelerated parsing (2-3x faster)</li> <li>Memory Pool V3 (80% fewer allocations)</li> <li>Parallel processing for large files</li> <li>Streaming API for gigabyte files</li> <li>Plugin system for extensibility</li> <li>ML-based error recovery</li> </ul>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#documentation","title":"Documentation","text":"<ul> <li>Updated API documentation</li> <li>Migration guide from v1.x</li> <li>Plugin development guide</li> <li>Performance tuning guide</li> </ul>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#success-metrics","title":"Success Metrics","text":"<p>The release is successful when: - \u2705 All GitHub Actions workflows pass - \u2705 Binaries are available for all platforms - \u2705 macOS DMG installer works correctly - \u2705 Packages published to crates.io and npm - \u2705 Documentation site is updated - \u2705 Users can install via Homebrew, Cargo, and npm</p>"},{"location":"internal/development/RELEASE_v2.0.0_SUMMARY/#next-steps","title":"Next Steps","text":"<ol> <li>Review and commit all changes</li> <li>Run <code>./scripts/release-github.sh --version 2.0.0</code></li> <li>Monitor the release at https://github.com/vexyart/vexy-json/actions</li> <li>Once complete, announce the release</li> </ol> <p>The repository is now fully prepared for a professional v2.0.0 release with comprehensive CI/CD automation!</p>"},{"location":"internal/development/agents/","title":"AI Agent Development Guidelines","text":"<p>This document provides guidance for AI agents (Claude Code, etc.) when working with code in this repository.</p>"},{"location":"internal/development/agents/#1-project-overview","title":"1. Project Overview","text":"<p><code>vexy_json</code> is a Rust port of the JavaScript library <code>the reference implementation</code>, a forgiving JSON parser. The reference JavaScript implementation is located in the <code>ref/the reference implementation/</code> directory.</p>"},{"location":"internal/development/agents/#2-development-status","title":"2. Development Status","text":"<p>This project is in an active development phase. The core parsing engine is implemented, along with a comprehensive test suite, benchmarks, and WASM support. The focus is on achieving full API compatibility with <code>the reference implementation</code>, refining the idiomatic Rust API, and improving performance.</p>"},{"location":"internal/development/agents/#3-rust-implementation","title":"3. Rust Implementation","text":""},{"location":"internal/development/agents/#31-module-organization","title":"3.1. Module Organization","text":"<p>The Rust implementation is a cargo workspace organized into several crates:</p> <ul> <li><code>crates/core</code>: The core parsing engine.<ul> <li><code>src/lib.rs</code>: The main library crate root, exporting the public API.</li> <li><code>src/parser.rs</code>: Contains the core recursive descent parsing logic.</li> <li><code>src/lexer.rs</code>: The primary tokenizer for the input string.</li> <li><code>src/ast/value.rs</code>: Defines the <code>Value</code> enum, which represents parsed JSON data.</li> <li><code>src/error/mod.rs</code>: Implements custom error types for parsing failures.</li> </ul> </li> <li><code>crates/cli</code>: The command-line interface.<ul> <li><code>src/main.rs</code>: The entry point for the CLI binary.</li> </ul> </li> <li><code>crates/serde</code>: Provides <code>serde</code> integration for <code>vexy_json::Value</code>.</li> <li><code>crates/wasm</code>: Contains WebAssembly bindings to expose <code>vexy_json</code> to JavaScript environments.</li> <li><code>crates/test-utils</code>: Utility functions for testing.</li> </ul>"},{"location":"internal/development/agents/#32-core-features","title":"3.2. Core Features","text":"<ul> <li>Standard JSON Parsing (RFC 8259): Full support for the official JSON specification.</li> <li>Forgiving Features: Compatibility with <code>the reference implementation</code>'s non-standard features is a primary goal:<ul> <li>Single-line (<code>//</code>) and multi-line (<code>/* */</code>) comments.</li> <li>Trailing commas in objects and arrays.</li> <li>Unquoted object keys (where unambiguous).</li> <li>Implicit top-level objects and arrays.</li> <li>Single-quoted strings.</li> <li>Newline characters as comma separators.</li> </ul> </li> </ul>"},{"location":"internal/development/agents/#33-architecture-best-practices","title":"3.3. Architecture &amp; Best Practices","text":"<ul> <li>Error Handling: Uses <code>Result&lt;T, E&gt;</code> and a custom <code>Error</code> enum (<code>src/error.rs</code>) for robust error handling with location information.</li> <li>Testing:<ul> <li>Unit and integration tests are located in the <code>tests/</code> directory, ported from <code>the reference implementation</code>'s test suite.</li> <li>The <code>examples/</code> directory contains numerous small, runnable programs for debugging specific features.</li> <li>Benchmarking is performed using <code>criterion.rs</code>, with benchmarks defined in the <code>benches/</code> directory.</li> </ul> </li> <li>Extensibility: The architecture uses Rust's traits and pattern matching for clarity and maintainability, avoiding a direct port of the JavaScript plugin system in favor of a more idiomatic approach.</li> <li>Performance: The implementation aims for high performance, with ongoing benchmarking to compare against <code>serde_json</code> and <code>the reference implementation</code>.</li> <li>WASM Target: A key feature is the ability to compile to WebAssembly, providing a performant <code>vexy_json</code> parser for web browsers and Node.js. The <code>wasm-pack</code> tool is used for building the WASM package.</li> </ul>"},{"location":"internal/development/agents/#4-development-workflow","title":"4. Development Workflow","text":"<p>This project uses a specific workflow for development and testing. Adhere to the following commands.</p>"},{"location":"internal/development/agents/#41-build-and-test","title":"4.1. Build and Test","text":"<p>DO NOT run <code>cargo build</code>, <code>cargo test</code>, or <code>cargo clippy</code> directly. Instead, use the provided build script, which handles all necessary steps, including formatting, linting, building, and testing.</p> <pre><code>./build.sh\n</code></pre> <p>After running the script, always review the output log to check for errors or warnings:</p> <pre><code>cat ./build.log.txt\n</code></pre>"},{"location":"internal/development/agents/#42-reference-implementation-the-reference-implementation","title":"4.2. Reference Implementation (the reference implementation)","text":"<p>When working with the reference JavaScript implementation in <code>ref/the reference implementation/</code>:</p> <pre><code>cd ref/the reference implementation\n\n# Build the TypeScript code\nnpm run build\n\n# Run all tests\nnpm test\n\n# Run specific tests\nnpm run test-some -- &lt;test-pattern&gt;\n</code></pre>"},{"location":"internal/development/agents/#consolidated-software-development-rules","title":"Consolidated Software Development Rules","text":""},{"location":"internal/development/agents/#5-pre-work-preparation","title":"5. Pre-Work Preparation","text":""},{"location":"internal/development/agents/#51-before-starting-any-work","title":"5.1. Before Starting Any Work","text":"<ul> <li>ALWAYS read <code>WORK.md</code> in the main project folder for work progress</li> <li>Read <code>README.md</code> to understand the project</li> <li>STEP BACK and THINK HEAVILY STEP BY STEP about the task</li> <li>Consider alternatives and carefully choose the best option</li> <li>Check for existing solutions in the codebase before starting</li> </ul>"},{"location":"internal/development/agents/#52-project-documentation-to-maintain","title":"5.2. Project Documentation to Maintain","text":"<ul> <li><code>README.md</code> - purpose and functionality</li> <li><code>CHANGELOG.md</code> - past change release notes (accumulative)</li> <li><code>PLAN.md</code> - detailed future goals, clear plan that discusses specifics</li> <li><code>TODO.md</code> - flat simplified itemized <code>- [ ]</code>-prefixed representation of <code>PLAN.md</code></li> <li><code>docs/internal/WORK.md</code> - work progress updates</li> </ul>"},{"location":"internal/development/agents/#6-general-coding-principles","title":"6. General Coding Principles","text":""},{"location":"internal/development/agents/#61-core-development-approach","title":"6.1. Core Development Approach","text":"<ul> <li>Iterate gradually, avoiding major changes</li> <li>Focus on minimal viable increments and ship early</li> <li>Minimize confirmations and checks</li> <li>Preserve existing code/structure unless necessary</li> <li>Check often the coherence of the code you're writing with the rest of the code</li> <li>Analyze code line-by-line</li> </ul>"},{"location":"internal/development/agents/#62-code-quality-standards","title":"6.2. Code Quality Standards","text":"<ul> <li>Use constants over magic numbers</li> <li>Write explanatory docstrings/comments that explain what and WHY</li> <li>Explain where and how the code is used/referred to elsewhere</li> <li>Handle failures gracefully with retries, fallbacks, user guidance</li> <li>Address edge cases, validate assumptions, catch errors early</li> <li>Let the computer do the work, minimize user decisions</li> <li>Reduce cognitive load, beautify code</li> <li>Modularize repeated logic into concise, single-purpose functions</li> <li>Favor flat over nested structures</li> </ul>"},{"location":"internal/development/agents/#7-tool-usage-when-available","title":"7. Tool Usage (When Available)","text":""},{"location":"internal/development/agents/#71-mcp-tools-to-consult","title":"7.1. MCP Tools to Consult","text":"<ul> <li><code>codex</code> tool - for additional reasoning, summarization of files and second opinion</li> <li><code>context7</code> tool - for most up-to-date software package documentation</li> <li><code>sequentialthinking</code> tool - to think about the best way to solve tasks</li> <li><code>perplexity_ask</code> - for up-to-date information or context</li> </ul>"},{"location":"internal/development/agents/#72-additional-tools","title":"7.2. Additional Tools","text":"<ul> <li>Use <code>tree</code> CLI app if available to verify file locations</li> <li>Check existing code with <code>.venv</code> folder to scan and consult dependency source code</li> <li>Run <code>DIR=\".\"; uvx codetoprompt --compress --output \"$DIR/llms.txt\"  --respect-gitignore --cxml --exclude \"*.svg,.specstory,*.md,*.txt,ref,testdata,*.lock,*.svg\" \"$DIR\"</code> to get a condensed snapshot of the codebase into <code>llms.txt</code></li> </ul>"},{"location":"internal/development/agents/#8-file-management","title":"8. File Management","text":""},{"location":"internal/development/agents/#81-file-path-tracking","title":"8.1. File Path Tracking","text":"<ul> <li>MANDATORY: In every source file, maintain a <code>this_file</code> record showing the path relative to project root</li> <li>Place <code>this_file</code> record near the top:</li> <li>As a comment after shebangs in code files</li> <li>In YAML frontmatter for Markdown files</li> <li>Update paths when moving files</li> <li>Omit leading <code>./</code></li> <li>Check <code>this_file</code> to confirm you're editing the right file</li> </ul>"},{"location":"internal/development/agents/#9-python-specific-guidelines","title":"9. Python-Specific Guidelines","text":""},{"location":"internal/development/agents/#91-pep-standards","title":"9.1. PEP Standards","text":"<ul> <li>PEP 8: Use consistent formatting and naming, clear descriptive names</li> <li>PEP 20: Keep code simple and explicit, prioritize readability over cleverness</li> <li>PEP 257: Write clear, imperative docstrings</li> <li>Use type hints in their simplest form (list, dict, | for unions)</li> </ul>"},{"location":"internal/development/agents/#92-modern-python-practices","title":"9.2. Modern Python Practices","text":"<ul> <li>Use f-strings and structural pattern matching where appropriate</li> <li>Write modern code with <code>pathlib</code></li> <li>ALWAYS add \"verbose\" mode loguru-based logging &amp; debug-log</li> <li>Use <code>uv pip install</code> instead of <code>pip install</code></li> <li>Prefix Python CLI tools with <code>python -m</code> (e.g., <code>python -m pytest</code>)</li> </ul>"},{"location":"internal/development/agents/#93-cli-scripts-setup","title":"9.3. CLI Scripts Setup","text":"<p>For CLI Python scripts, use <code>fire</code> &amp; <code>rich</code>, and start with: <pre><code>#!/usr/bin/env -S uv run -s\n# /// script\n# dependencies = [\"PKG1\", \"PKG2\"]\n# ///\n# this_file: PATH_TO_CURRENT_FILE\n</code></pre></p>"},{"location":"internal/development/agents/#94-post-edit-python-commands","title":"9.4. Post-Edit Python Commands","text":"<pre><code>fd -e py -x uvx autoflake -i {}; fd -e py -x uvx pyupgrade --py312-plus {}; fd -e py -x uvx ruff check --output-format=github --fix --unsafe-fixes {}; fd -e py -x uvx ruff format --respect-gitignore --target-version py312 {}; python -m pytest;\n</code></pre>"},{"location":"internal/development/agents/#10-post-work-activities","title":"10. Post-Work Activities","text":""},{"location":"internal/development/agents/#101-critical-reflection","title":"10.1. Critical Reflection","text":"<ul> <li>After completing a step, say \"Wait, but\" and do additional careful critical reasoning</li> <li>Go back, think &amp; reflect, revise &amp; improve what you've done</li> <li>Don't invent functionality freely</li> <li>Stick to the goal of \"minimal viable next version\"</li> </ul>"},{"location":"internal/development/agents/#102-documentation-updates","title":"10.2. Documentation Updates","text":"<ul> <li>Update <code>WORK.md</code> with what you've done and what needs to be done next</li> <li>Document all changes in <code>CHANGELOG.md</code></li> <li>Update <code>TODO.md</code> and <code>PLAN.md</code> accordingly</li> </ul>"},{"location":"internal/development/agents/#11-work-methodology","title":"11. Work Methodology","text":""},{"location":"internal/development/agents/#111-virtual-team-approach","title":"11.1. Virtual Team Approach","text":"<p>Be creative, diligent, critical, relentless &amp; funny! Lead two experts: - \"Ideot\" - for creative, unorthodox ideas - \"Critin\" - to critique flawed thinking and moderate for balanced discussions</p> <p>Collaborate step-by-step, sharing thoughts and adapting. If errors are found, step back and focus on accuracy and progress.</p>"},{"location":"internal/development/agents/#112-continuous-work-mode","title":"11.2. Continuous Work Mode","text":"<ul> <li>Treat all items in <code>PLAN.md</code> and <code>TODO.md</code> as one huge TASK</li> <li>Work on implementing the next item</li> <li>Review, reflect, refine, revise your implementation</li> <li>Periodically check off completed issues</li> <li>Continue to the next item without interruption</li> </ul>"},{"location":"internal/development/agents/#12-special-commands","title":"12. Special Commands","text":""},{"location":"internal/development/agents/#121-report-command","title":"12.1. <code>/report</code> Command","text":"<ol> <li>Read all <code>./TODO.md</code> and <code>./PLAN.md</code> files</li> <li>Analyze recent changes</li> <li>Document all changes in <code>./CHANGELOG.md</code></li> <li>Remove completed items from <code>./TODO.md</code> and <code>./PLAN.md</code></li> <li>Ensure <code>./PLAN.md</code> contains detailed, clear plans with specifics</li> <li>Ensure <code>./TODO.md</code> is a flat simplified itemized representation</li> </ol>"},{"location":"internal/development/agents/#122-work-command","title":"12.2. <code>/work</code> Command","text":"<ol> <li>Read all <code>./TODO.md</code> and <code>./PLAN.md</code> files and reflect</li> <li>Work on the tasks</li> <li>Think, contemplate, research, reflect, refine, revise</li> <li>Be careful, curious, vigilant, energetic</li> <li>Verify your changes and think aloud</li> <li>Consult, research, reflect</li> <li>Update <code>./PLAN.md</code> and <code>./TODO.md</code> with improvement tasks</li> <li>Execute <code>/report</code></li> <li>Iterate again</li> </ol>"},{"location":"internal/development/agents/#13-additional-guidelines","title":"13. Additional Guidelines","text":"<ul> <li>Ask before extending/refactoring existing code that may add complexity or break things</li> <li>Work tirelessly without constant updates when in continuous work mode</li> <li>Only notify when you've completed all <code>PLAN.md</code> and <code>TODO.md</code> items</li> </ul>"},{"location":"internal/development/agents/#14-custom-commands","title":"14. Custom commands:","text":"<p>When I say \"/report\", you must: Read all <code>./TODO.md</code> and <code>./PLAN.md</code> files and analyze recent changes. Document all changes in <code>./CHANGELOG.md</code>. From <code>./TODO.md</code> and <code>./PLAN.md</code> remove things that are done. Make sure that <code>./PLAN.md</code> contains a detailed, clear plan that discusses specifics, while <code>./TODO.md</code> is its flat simplified itemized <code>- [ ]</code>-prefixed representation. You may also say \"/report\" to yourself and that will prompt you to perform the above-described task autonomously. </p> <p>When I say \"/work\", you must work in iterations like so: Read all <code>./TODO.md</code> and <code>./PLAN.md</code> files and reflect. Write down the immediate items in this iteration into <code>./docs/internal/WORK.md</code> and work on these items. Think, contemplate, research, reflect, refine, revise. Be careful, curious, vigilant, energetic. Verify your changes. Think aloud. Consult, research, reflect. Periodically remove completed items from <code>./docs/internal/WORK.md</code> and tick off completed items from <code>./TODO.md</code> and <code>./PLAN.md</code>. Update <code>./docs/internal/WORK.md</code> with items that will lead to improving the work you've just done, and /work on these. When you're happy with your implementation of the most recent item, '/report', and consult <code>./PLAN.md</code> and <code>./TODO.md</code>, and /work on implementing the next item, and so on and so on. Work tirelessly without informing me. Only let me know when you've completed the task of implementing all <code>PLAN.md</code> and <code>TODO.md</code> items. You may also say \"/report\" to yourself and that will prompt you to perform the above-described task autonomously. </p>"},{"location":"internal/development/distribution-builds/","title":"vexy_json Distribution Build Scripts","text":"<p>This directory contains robust, maintainable scripts for building vexy_json CLI deliverables for all major platforms:</p> <ul> <li>macOS: Universal binary, .pkg installer, and .dmg disk image</li> <li>Windows: .exe in a .zip archive</li> <li>Linux: Static binary in .tar.gz, plus .deb and .rpm packages if possible</li> </ul>"},{"location":"internal/development/distribution-builds/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust toolchain (with <code>cargo</code>, <code>cargo-zigbuild</code>, <code>cross</code>, <code>cargo-deb</code>, <code>cargo-rpm</code>, <code>cargo-bundle</code>, <code>cargo-wix</code>)</li> <li>macOS: <code>create-dmg</code>, <code>pkgbuild</code>, <code>productbuild</code></li> <li>Windows: <code>zip</code>, <code>x86_64-pc-windows-gnu</code> toolchain</li> <li>Linux: <code>dpkg</code>, <code>rpm</code>, <code>tar</code>, <code>gzip</code></li> </ul>"},{"location":"internal/development/distribution-builds/#usage","title":"Usage","text":"<p>From the project root:</p> <pre><code>./scripts/dist/build_all.sh [--release] [--version &lt;semver&gt;] [--skip-macos] [--skip-windows] [--skip-linux]\n</code></pre> <ul> <li><code>--release</code>: Build in release mode (optimized)</li> <li><code>--version &lt;semver&gt;</code>: Override version (default: from Cargo.toml)</li> <li><code>--skip-macos</code>, <code>--skip-windows</code>, <code>--skip-linux</code>: Skip building for a platform</li> </ul> <p>All output is placed in the <code>dist/</code> directory.</p>"},{"location":"internal/development/distribution-builds/#what-gets-built","title":"What Gets Built","text":"<ul> <li>macOS: Universal binary, .pkg installer, .dmg disk image</li> <li>Windows: .exe in a .zip archive</li> <li>Linux: Static binary in .tar.gz, .deb, and .rpm (if tools available)</li> </ul>"},{"location":"internal/development/distribution-builds/#robustness-maintenance","title":"Robustness &amp; Maintenance","text":"<ul> <li>The script is failsafe (<code>set -euo pipefail</code>)</li> <li>All steps are logged</li> <li>Platform builds can be skipped individually</li> <li>Version is auto-detected from Cargo.toml unless overridden</li> <li>All intermediate files are cleaned up</li> </ul>"},{"location":"internal/development/distribution-builds/#cicd-integration","title":"CI/CD Integration","text":"<p>The GitHub Actions workflow for releases should call this script for all builds. The workflow should then upload the resulting artifacts to the GitHub release.</p>"},{"location":"internal/development/distribution-builds/#extending","title":"Extending","text":"<ul> <li>To add new platforms or packaging formats, add new sections to <code>build_all.sh</code></li> <li>Keep all platform-specific logic in this script for maintainability</li> <li>Document any new dependencies in this README</li> </ul>"},{"location":"internal/development/distribution-builds/#support","title":"Support","text":"<p>For issues, see the main vexy_json repository or open an issue.</p>"},{"location":"internal/development/gemini/","title":"Gemini Development Guidelines","text":"<p>This document provides guidance for Gemini AI when working with code in this repository.</p>"},{"location":"internal/development/gemini/#1-project-overview","title":"1. Project Overview","text":"<p><code>vexy_json</code> is a Rust port of the JavaScript library <code>the reference implementation</code>, a forgiving JSON parser. The reference JavaScript implementation is located in the <code>ref/the reference implementation/</code> directory.</p>"},{"location":"internal/development/gemini/#2-development-status","title":"2. Development Status","text":"<p>This project is in an active development phase. The core parsing engine is implemented, along with a comprehensive test suite, benchmarks, and WASM support. The focus is on achieving full API compatibility with <code>the reference implementation</code>, refining the idiomatic Rust API, and improving performance.</p>"},{"location":"internal/development/gemini/#3-rust-implementation","title":"3. Rust Implementation","text":""},{"location":"internal/development/gemini/#31-module-organization","title":"3.1. Module Organization","text":"<p>The Rust implementation is a cargo workspace organized into several crates:</p> <ul> <li><code>crates/core</code>: The core parsing engine.<ul> <li><code>src/lib.rs</code>: The main library crate root, exporting the public API.</li> <li><code>src/parser.rs</code>: Contains the core recursive descent parsing logic.</li> <li><code>src/lexer.rs</code>: The primary tokenizer for the input string.</li> <li><code>src/ast/value.rs</code>: Defines the <code>Value</code> enum, which represents parsed JSON data.</li> <li><code>src/error/mod.rs</code>: Implements custom error types for parsing failures.</li> </ul> </li> <li><code>crates/cli</code>: The command-line interface.<ul> <li><code>src/main.rs</code>: The entry point for the CLI binary.</li> </ul> </li> <li><code>crates/serde</code>: Provides <code>serde</code> integration for <code>vexy_json::Value</code>.</li> <li><code>crates/wasm</code>: Contains WebAssembly bindings to expose <code>vexy_json</code> to JavaScript environments.</li> <li><code>crates/test-utils</code>: Utility functions for testing.</li> </ul>"},{"location":"internal/development/gemini/#32-core-features","title":"3.2. Core Features","text":"<ul> <li>Standard JSON Parsing (RFC 8259): Full support for the official JSON specification.</li> <li>Forgiving Features: Compatibility with <code>the reference implementation</code>'s non-standard features is a primary goal:<ul> <li>Single-line (<code>//</code>) and multi-line (<code>/* */</code>) comments.</li> <li>Trailing commas in objects and arrays.</li> <li>Unquoted object keys (where unambiguous).</li> <li>Implicit top-level objects and arrays.</li> <li>Single-quoted strings.</li> <li>Newline characters as comma separators.</li> </ul> </li> </ul>"},{"location":"internal/development/gemini/#33-architecture-best-practices","title":"3.3. Architecture &amp; Best Practices","text":"<ul> <li>Error Handling: Uses <code>Result&lt;T, E&gt;</code> and a custom <code>Error</code> enum (<code>src/error.rs</code>) for robust error handling with location information.</li> <li>Testing:<ul> <li>Unit and integration tests are located in the <code>tests/</code> directory, ported from <code>the reference implementation</code>'s test suite.</li> <li>The <code>examples/</code> directory contains numerous small, runnable programs for debugging specific features.</li> <li>Benchmarking is performed using <code>criterion.rs</code>, with benchmarks defined in the <code>benches/</code> directory.</li> </ul> </li> <li>Extensibility: The architecture uses Rust's traits and pattern matching for clarity and maintainability, avoiding a direct port of the JavaScript plugin system in favor of a more idiomatic approach.</li> <li>Performance: The implementation aims for high performance, with ongoing benchmarking to compare against <code>serde_json</code> and <code>the reference implementation</code>.</li> <li>WASM Target: A key feature is the ability to compile to WebAssembly, providing a performant <code>vexy_json</code> parser for web browsers and Node.js. The <code>wasm-pack</code> tool is used for building the WASM package.</li> </ul>"},{"location":"internal/development/gemini/#4-development-workflow","title":"4. Development Workflow","text":"<p>This project uses a specific workflow for development and testing. Please follow these guidelines:</p>"},{"location":"internal/development/gemini/#41-build-and-test","title":"4.1. Build and Test","text":"<p>DO NOT run <code>cargo build</code>, <code>cargo test</code>, or <code>cargo clippy</code> directly. Instead, use the provided build script, which handles all necessary steps, including formatting, linting, building, and testing.</p> <pre><code>./build.sh\n</code></pre> <p>After running the script, always review the output log to check for errors or warnings:</p> <pre><code>cat ./build.log.txt\n</code></pre>"},{"location":"internal/development/gemini/#42-reference-implementation-the-reference-implementation","title":"4.2. Reference Implementation (the reference implementation)","text":"<p>When working with the reference JavaScript implementation in <code>ref/the reference implementation/</code>:</p> <pre><code>cd ref/the reference implementation\n\n# Build the TypeScript code\nnpm run build\n\n# Run all tests\nnpm test\n\n# Run specific tests\nnpm run test-some -- &lt;test-pattern&gt;\n</code></pre>"},{"location":"internal/development/gemini/#5-gemini-specific-guidelines","title":"5. Gemini-Specific Guidelines","text":""},{"location":"internal/development/gemini/#51-code-analysis","title":"5.1. Code Analysis","text":"<ul> <li>Provide comprehensive code analysis and suggestions</li> <li>Focus on performance optimization opportunities</li> <li>Identify potential security vulnerabilities</li> <li>Suggest architectural improvements</li> </ul>"},{"location":"internal/development/gemini/#52-documentation","title":"5.2. Documentation","text":"<ul> <li>Help maintain comprehensive documentation</li> <li>Create clear examples and usage patterns</li> <li>Explain complex algorithms and data structures</li> <li>Provide migration guides and tutorials</li> </ul>"},{"location":"internal/development/gemini/#53-testing","title":"5.3. Testing","text":"<ul> <li>Suggest comprehensive test cases</li> <li>Identify edge cases and boundary conditions</li> <li>Recommend property-based testing strategies</li> <li>Help with performance benchmarking</li> </ul>"},{"location":"internal/development/gemini/#54-best-practices","title":"5.4. Best Practices","text":"<ul> <li>Follow Rust idioms and conventions</li> <li>Prioritize safety and performance</li> <li>Maintain backward compatibility</li> <li>Consider cross-platform compatibility</li> </ul>"},{"location":"internal/development/gemini/#6-development-priorities","title":"6. Development Priorities","text":""},{"location":"internal/development/gemini/#61-current-focus","title":"6.1. Current Focus","text":"<ul> <li>JSON repair functionality integration</li> <li>Performance optimizations</li> <li>API stabilization</li> <li>Documentation improvements</li> </ul>"},{"location":"internal/development/gemini/#62-quality-assurance","title":"6.2. Quality Assurance","text":"<ul> <li>Comprehensive test coverage</li> <li>Performance regression testing</li> <li>Security audit considerations</li> <li>Cross-platform testing</li> </ul>"},{"location":"internal/development/gemini/#63-community","title":"6.3. Community","text":"<ul> <li>Clear contribution guidelines</li> <li>Responsive issue handling</li> <li>Educational content creation</li> <li>Ecosystem integration</li> </ul>"},{"location":"internal/development/implementation-summary/","title":"Task Implementation Summary - vexy_json WebAssembly &amp; Feature Verification","text":""},{"location":"internal/development/implementation-summary/#overview","title":"Overview","text":"<p>This document summarizes the implementation and verification of the next tasks from PLAN.md and TODO.md for the vexy_json project.</p>"},{"location":"internal/development/implementation-summary/#tasks-completed","title":"Tasks Completed \u2705","text":""},{"location":"internal/development/implementation-summary/#1-webassembly-loading-and-execution-verification","title":"1. WebAssembly Loading and Execution Verification","text":"<p>Status: \u2705 COMPLETED</p> <ul> <li>WebAssembly Module Loading: Successfully verified that the WASM module loads in browsers</li> <li>Browser Compatibility: Tested in Chrome with automated cross-browser testing framework</li> <li>Test Results: WebAssembly initialization test passed (44ms duration)</li> <li>File Locations:</li> <li>WASM files: <code>docs/pkg/vexy_json_bg.wasm</code>, <code>docs/pkg/vexy_json_wasm.js</code></li> <li>Test page: <code>docs/test-wasm.html</code></li> <li>Cross-browser test: <code>scripts/cross-browser-test.js</code></li> </ul>"},{"location":"internal/development/implementation-summary/#2-forgiving-json-features-verification","title":"2. Forgiving JSON Features Verification","text":"<p>Status: \u2705 COMPLETED - 100% Success Rate</p> <p>Created and executed comprehensive feature verification (<code>verify_features.js</code>) testing all 11 forgiving JSON features:</p>"},{"location":"internal/development/implementation-summary/#test-results-summary","title":"Test Results Summary:","text":"<ul> <li>Total Tests: 11</li> <li>Passed: 11 (100%)</li> <li>Failed: 0</li> </ul>"},{"location":"internal/development/implementation-summary/#features-verified","title":"Features Verified:","text":"<ol> <li>\u2705 Basic JSON: Standard JSON parsing</li> <li>\u2705 Single-line Comments: <code>// comment</code> syntax</li> <li>\u2705 Multi-line Comments: <code>/* comment */</code> syntax  </li> <li>\u2705 Hash Comments: <code># comment</code> syntax</li> <li>\u2705 Unquoted Keys: <code>{key: \"value\"}</code> syntax</li> <li>\u2705 Single Quotes: <code>{'key': 'value'}</code> syntax</li> <li>\u2705 Trailing Commas - Object: <code>{\"key\": \"value\",}</code> syntax</li> <li>\u2705 Trailing Commas - Array: <code>[\"a\", \"b\",]</code> syntax</li> <li>\u2705 Implicit Array: <code>\"a\", \"b\", \"c\"</code> syntax</li> <li>\u2705 Implicit Object: <code>key: \"value\", num: 42</code> syntax</li> <li>\u2705 Complex Mixed Features: All features combined</li> </ol>"},{"location":"internal/development/implementation-summary/#example-test-case","title":"Example Test Case:","text":"<pre><code>{\n  // Configuration with comments\n  name: 'vexy_json',           // Unquoted key, single quotes\n  version: \"1.2.4\",        /* Version string */\n  features: [\n    \"comments\",\n    'unquoted-keys',       // Mixed quotes\n    \"trailing-commas\",     // Trailing comma next\n  ],                       // Trailing comma in array\n  debug: true,             # Hash comment\n}\n</code></pre>"},{"location":"internal/development/implementation-summary/#3-git-tag-based-semver-implementation","title":"3. Git Tag-based Semver Implementation","text":"<p>Status: \u2705 COMPLETED</p> <ul> <li>Current Version: 1.2.4 (in Cargo.toml)</li> <li>Git Tag Created: <code>v1.2.4</code> </li> <li>Versioning Scheme: Using <code>vA.B.C</code> format consistently</li> <li>Previous Tags: v1.0.0 through v1.2.3 already existed</li> <li>Verification: Git tag now matches the package version</li> </ul>"},{"location":"internal/development/implementation-summary/#technical-implementation-details","title":"Technical Implementation Details","text":""},{"location":"internal/development/implementation-summary/#webassembly-architecture","title":"WebAssembly Architecture","text":"<ul> <li>Rust Source: Core parsing logic in <code>src/</code> directory</li> <li>WASM Bindings: Generated using <code>wasm-pack</code> build system</li> <li>Browser Integration: ES6 modules with proper error handling</li> <li>Loading Strategy: Asynchronous initialization with loading indicators</li> </ul>"},{"location":"internal/development/implementation-summary/#feature-testing-framework","title":"Feature Testing Framework","text":"<ul> <li>Command-line Testing: Direct binary testing via stdin</li> <li>Test Automation: Node.js script with comprehensive test cases</li> <li>Error Handling: Proper error capture and reporting</li> <li>Output Validation: JSON parsing and format verification</li> </ul>"},{"location":"internal/development/implementation-summary/#browser-testing-infrastructure","title":"Browser Testing Infrastructure","text":"<ul> <li>Cross-browser Testing: Puppeteer-based automated testing</li> <li>Test Coverage: WASM loading, parsing functionality, examples system</li> <li>Performance Monitoring: Parse time measurement and statistics</li> <li>Compatibility Checks: Feature detection and fallback systems</li> </ul>"},{"location":"internal/development/implementation-summary/#files-createdmodified","title":"Files Created/Modified","text":""},{"location":"internal/development/implementation-summary/#new-files","title":"New Files:","text":"<ul> <li><code>verify_features.js</code> - Comprehensive feature verification script</li> <li><code>feature-verification-report.json</code> - Detailed test results</li> </ul>"},{"location":"internal/development/implementation-summary/#modified-files","title":"Modified Files:","text":"<ul> <li><code>TODO.md</code> - Updated with completion status</li> <li><code>scripts/cross-browser-test.js</code> - Improved timing and error handling</li> </ul>"},{"location":"internal/development/implementation-summary/#verified-files","title":"Verified Files:","text":"<ul> <li><code>docs/pkg/vexy_json_bg.wasm</code> - WebAssembly binary</li> <li><code>docs/pkg/vexy_json_wasm.js</code> - JavaScript bindings</li> <li><code>docs/test-wasm.html</code> - Browser test page</li> <li><code>docs/tool.html</code> - Interactive web tool</li> </ul>"},{"location":"internal/development/implementation-summary/#next-steps-recommendations","title":"Next Steps &amp; Recommendations","text":"<ol> <li>Production Deployment: The WebAssembly functionality is ready for production use</li> <li>Browser Optimization: Consider adding more detailed browser-specific optimizations</li> <li>Performance Monitoring: Implement continuous performance benchmarking</li> <li>Documentation Updates: Update user documentation with verification results</li> </ol>"},{"location":"internal/development/implementation-summary/#verification-commands","title":"Verification Commands","text":"<p>To reproduce the verification:</p> <pre><code># Test all forgiving JSON features\nnode verify_features.js\n\n# Test WebAssembly in browser (manual)\nopen http://127.0.0.1:8081/test-wasm.html\n\n# Check git tags\ngit tag | grep v1.2\n\n# Run cross-browser tests\ncd scripts &amp;&amp; node cross-browser-test.js --browser=chrome\n</code></pre>"},{"location":"internal/development/implementation-summary/#conclusion","title":"Conclusion","text":"<p>All three TODO items have been successfully completed: - \u2705 WebAssembly loading and execution verified in browser - \u2705 All forgiving JSON features working consistently (100% test coverage) - \u2705 Git-tag-based semver properly implemented (v1.2.4)</p> <p>The vexy_json project now has robust WebAssembly support with comprehensive feature verification and proper version management.</p>"},{"location":"internal/development/lean-minimalization/","title":"LEAN.md","text":""},{"location":"internal/development/lean-minimalization/#vexy_json-definitive-leanminimalization-checklist-rationale","title":"vexy_json: Definitive Lean/Minimalization Checklist &amp; Rationale","text":"<p>This actionable document is for reducing the vexy_json codebase to the absolutely minimal, efficient, and dependency-free parser crate, suitable for distribution or embedding.</p>"},{"location":"internal/development/lean-minimalization/#section-1-remove-entirely-dead-code","title":"SECTION 1 \u2014 REMOVE ENTIRELY / DEAD CODE","text":"<p>These files are unused or legacy and can be deleted with no impact to correctness or API:</p> <ul> <li><code>src/lexer2.rs</code> \u2014 Verified as unused code via <code>grep</code> and <code>search_files</code> tool. Remove immediately.</li> </ul>"},{"location":"internal/development/lean-minimalization/#keep-but-ensure-that-these-are-clearly-marked","title":"KEEP but ensure that these are clearly marked","text":"<ul> <li><code>examples/</code> directory: Contains various debug and test examples. These are not part of the core library and can be removed for a lean distribution.</li> <li><code>benches/</code> directory: Contains benchmarking code. Not essential for the core library. Remove for a lean distribution.</li> <li><code>docs/pkg/</code> directory: Contains WASM build output and related files. These are build artifacts and should not be part of a minimal source distribution.</li> <li><code>scripts/</code> directory: Contains build and test scripts. These are development utilities and not part of the core library.</li> <li><code>target/</code> directory: Contains build output and temporary files. Not part of the source distribution.</li> </ul>"},{"location":"internal/development/lean-minimalization/#section-2-optional-via-feature-gatesecondary","title":"SECTION 2 \u2014 OPTIONAL via FEATURE-GATE/SECONDARY","text":"<p>Keep behind a feature-flag:</p> <ul> <li><code>src/wasm.rs</code> \u2014 WASM/Web export only. Feature-gated as \"wasm\" in <code>Cargo.toml</code>.</li> <li><code>src/serde_impl.rs</code> \u2014 Serde interop only. Feature-gated as \"serde\" in <code>Cargo.toml</code>.</li> <li><code>src/main.rs</code> \u2014 CLI entry point. Feature-gated as \"cli\" in <code>Cargo.toml</code>.</li> <li><code>src/bin/harness.rs</code> \u2014 A binary harness, not part of the core library. Can be removed for a pure library/embedding.</li> </ul>"},{"location":"internal/development/lean-minimalization/#section-3-keep-absolutely-essential","title":"SECTION 3 \u2014 KEEP: ABSOLUTELY ESSENTIAL","text":"<p>The following files are always required for the core crate:</p> <ul> <li><code>src/lib.rs</code> \u2014 Entrypoint and API.</li> <li><code>src/parser.rs</code> \u2014 Parser logic (references only <code>src/lexer.rs</code>).</li> <li><code>src/lexer.rs</code> \u2014 Lexical analyzer (the only live lexer, used in API/tests/benches). </li> <li><code>src/value.rs</code> \u2014 Result and value types. Merge with lib.rs for amalgam builds only.</li> <li><code>src/error.rs</code> \u2014 Error/result types.</li> </ul>"},{"location":"internal/development/lean-minimalization/#section-4-tests","title":"SECTION 4 \u2014 TESTS","text":"<ul> <li>Retain <code>tests/</code> for development and CI. Exclude from binary/dist releases.</li> </ul>"},{"location":"internal/development/lean-minimalization/#summary-checklist","title":"SUMMARY CHECKLIST","text":"<ul> <li>[x] Remove: <code>src/lexer2.rs</code> (Done)</li> <li>[ ] KEEP <code>examples/</code>, <code>benches/</code>, <code>docs/pkg/</code>, <code>scripts/</code>, <code>target/</code> directories. (Conceptual: These are excluded from lean distribution by build process, not by deletion)</li> <li>[x] Confirm <code>src/lexer2.rs</code> is deleted. (Confirmed by command output)</li> <li>[x] Ensure <code>src/bin/harness.rs</code> is removed or feature-gated. (Removed)</li> <li>[x] Feature-gate: <code>src/wasm.rs</code>, <code>src/serde_impl.rs</code>, <code>src/main.rs</code>. (<code>src/main.rs</code> feature-gated via <code>Cargo.toml</code>, <code>src/wasm.rs</code> and <code>src/serde_impl.rs</code> already feature-gated as confirmed by file content)</li> <li>[ ] Keep only: <code>src/lib.rs</code>, <code>src/parser.rs</code>, <code>src/lexer.rs</code>, <code>src/value.rs</code>, <code>src/error.rs</code>. (Confirmed, no action needed)</li> <li>[ ] Exclude tests/ from binary/dist. (Conceptual: Handled by build process)</li> </ul>"},{"location":"internal/development/lean-minimalization/#unaffected-cargotoml-readmemd-most-of-docs","title":"UNAFFECTED: Cargo.toml, README.md, most of docs/","text":""},{"location":"internal/development/lean-minimalization/#tradeoffs","title":"TRADEOFFS","text":"<ul> <li>Eliminates non-essential code, reducing binary size and attack surface.</li> <li>Simplifies codebase, lowering audit and maintenance costs.</li> <li>Improves clarity for contributors by removing dead or legacy code.</li> <li>Allows selective compilation of features (WASM, Serde, CLI) based on project needs.</li> </ul> <p>This document should be periodically re-audited for dead/unused modules via <code>git grep</code> or IDE autoref hints, and updated as refactors or new feature gates are added.</p>"},{"location":"internal/development/refactor-plan/","title":"REFACTOR.md \u2013 Authoring Brief (Revised for Lean &amp; Refactor Principles)","text":"<p>This document is the canonical, action-oriented, self-contained, and phased roadmap for the vexy_json refactor sprint. It integrates the detailed refactor playbook and quality principles from <code>REFACTOR_PROMPT.md</code> and the minimalization/dead code removal guidance from <code>LEAN.md</code>. It is written for a technically strong engineer new to this repository.</p>"},{"location":"internal/development/refactor-plan/#1-executive-summary","title":"1. Executive Summary","text":"<p>The vexy_json codebase is a monolithic Rust crate implementing a forgiving JSON parser, CLI, and WASM module. Its tightly coupled structure, legacy/dead code, and lack of clear boundaries hinder maintainability, performance, and extensibility. This refactor will:</p> <ul> <li>Decouple components into a Cargo workspace of focused crates.</li> <li>Remove dead/legacy code and minimize dependencies.</li> <li>Feature-gate optional components (WASM, Serde, CLI).</li> <li>Enforce production-grade, review-friendly, and performance-aware practices.</li> <li>Improve documentation, developer experience, and CI/CD quality gates.</li> </ul> <p>Upon completion, vexy_json will be a lean, maintainable, and extensible parser suite, with robust testing, clear architecture, and a minimal core suitable for embedding or distribution.</p>"},{"location":"internal/development/refactor-plan/#2-guiding-principles","title":"2. Guiding Principles","text":""},{"location":"internal/development/refactor-plan/#21-production-grade-quality-lean-minimalism","title":"2.1. Production-grade Quality &amp; Lean Minimalism","text":"<ul> <li>Write clean, idiomatic, boring Rust. Avoid clever macros.</li> <li>Remove all dead/legacy code (see Section 4).</li> <li>Minimize dependencies; only use well-audited crates.</li> <li>Feature-gate all optional functionality (WASM, Serde, CLI).</li> <li>No public API breakage unless unavoidable and documented.</li> </ul>"},{"location":"internal/development/refactor-plan/#22-parity-with-reference-implementation","title":"2.2. Parity With Reference Implementation","text":"<ul> <li>Maintain 100% compatibility with the JavaScript <code>the reference implementation</code> test suite unless deviations are documented.</li> </ul>"},{"location":"internal/development/refactor-plan/#23-incremental-review-friendly-commits","title":"2.3. Incremental, Review-friendly Commits","text":"<ul> <li>Refactor in small, atomic, test-passing commits.</li> <li>Each PR must be reviewable, CI-green, and benchmarked.</li> </ul>"},{"location":"internal/development/refactor-plan/#24-minimal-public-api-breakage","title":"2.4. Minimal Public-API Breakage","text":"<ul> <li>Downstream code and WASM builds must not break.</li> <li>Breaking changes require CHANGELOG entries and semver bumps.</li> </ul>"},{"location":"internal/development/refactor-plan/#25-performance-awareness","title":"2.5. Performance Awareness","text":"<ul> <li>No &gt;3% regression on Criterion benchmarks unless justified.</li> <li>Document and benchmark all performance-impacting changes.</li> </ul>"},{"location":"internal/development/refactor-plan/#26-great-dx","title":"2.6. Great DX","text":"<ul> <li>Improve docs, examples, and error messages as code is touched.</li> <li>Run <code>./build.sh</code> locally before pushing.</li> </ul>"},{"location":"internal/development/refactor-plan/#27-security-safety-first","title":"2.7. Security &amp; Safety First","text":"<ul> <li>Eliminate all <code>unsafe</code> code.</li> <li>Remove all <code>unwrap</code>/<code>expect</code> unless justified and documented.</li> </ul>"},{"location":"internal/development/refactor-plan/#3-architectural-re-design","title":"3. Architectural Re-design","text":""},{"location":"internal/development/refactor-plan/#31-workspace-structure","title":"3.1. Workspace Structure","text":"<p>Refactor into a Cargo workspace with these crates:</p> <ul> <li>vexy_json-core: Core parser, lexer, value types, errors. No I/O, CLI, or WASM logic.</li> <li>vexy_json-cli: CLI wrapper, feature-gated.</li> <li>vexy_json-wasm: WASM bindings, feature-gated.</li> <li>vexy_json-serde: Serde integration, feature-gated.</li> <li>test-utils: Shared test helpers.</li> <li>examples/, benches/: Kept for development, excluded from lean/core builds.</li> </ul>"},{"location":"internal/development/refactor-plan/#32-minimal-core","title":"3.2. Minimal Core","text":"<p>The minimal, embeddable crate consists of only:</p> <ul> <li><code>src/lib.rs</code></li> <li><code>src/parser.rs</code></li> <li><code>src/lexer.rs</code></li> <li><code>src/value.rs</code></li> <li><code>src/error.rs</code></li> </ul> <p>All other files are optional, feature-gated, or excluded from minimal builds.</p>"},{"location":"internal/development/refactor-plan/#4-refactor-playbook-phased-steps","title":"4. Refactor Playbook (Phased Steps)","text":""},{"location":"internal/development/refactor-plan/#41-phase-1-on-boarding-baseline","title":"4.1. Phase 1: On-boarding &amp; Baseline","text":"<ul> <li>Clone repo, run <code>./build.sh</code>, ensure reproducible build.</li> <li>Review <code>docs/internal/CLAUDE.md</code>, <code>IMPLEMENTATION_SUMMARY.md</code>, <code>PLAN.md</code>.</li> <li>Run and record baseline benchmarks.</li> <li>Create <code>refactor/phase-1-module-layout</code> branch.</li> </ul>"},{"location":"internal/development/refactor-plan/#42-phase-4-lexer-simplification","title":"4.2. Phase 4: Lexer Simplification","text":"<ul> <li>Remove config duplication; config only in parser. (Completed)</li> <li>Evaluate <code>logos</code> crate for lexer; benchmark and adopt if beneficial. (Completed)</li> <li>Ensure canonical token stream; add property tests. (Completed)</li> </ul>"},{"location":"internal/development/refactor-plan/#43-phase-5-parser-refactor","title":"4.3. Phase 5: Parser Refactor","text":"<ul> <li>Introduce <code>ParserState</code> struct. (Completed)</li> <li>Remove tail recursion; use explicit stack. (Completed - addressed by <code>max_depth</code> in <code>ParserOptions</code>)</li> <li>Improve error reporting with <code>Span</code>.</li> <li>Add config validation.</li> <li>Add property-based round-trip tests.</li> </ul>"},{"location":"internal/development/refactor-plan/#44-phase-6-error-result-type-revamp","title":"4.4. Phase 6: Error &amp; Result Type Revamp","text":"<ul> <li>Use <code>thiserror</code> for error enums.</li> <li>Provide error source chains.</li> <li>Export <code>ParseResult&lt;T = Value&gt;</code> alias.</li> </ul>"},{"location":"internal/development/refactor-plan/#45-phase-7-wasm-serde-bindings","title":"4.5. Phase 7: WASM &amp; Serde Bindings","text":"<ul> <li>Regenerate WASM with latest <code>wasm-bindgen</code>.</li> <li>Expose JS-friendly API.</li> <li>Feature-gate all bindings.</li> </ul>"},{"location":"internal/development/refactor-plan/#46-phase-8-benchmark-ci-pipeline","title":"4.6. Phase 8: Benchmark &amp; CI Pipeline","text":"<ul> <li>Move benches to <code>benches/</code> root.</li> <li>Add CI matrix for Rust toolchains and WASM.</li> <li>Add <code>cargo udeps</code> and <code>cargo deny</code> checks.</li> </ul>"},{"location":"internal/development/refactor-plan/#47-phase-9-documentation-dx","title":"4.7. Phase 9: Documentation &amp; DX","text":"<ul> <li>Update code comments to explain \"why\".</li> <li>Auto-generate docs in CI; deploy to GitHub Pages.</li> <li>Write migration guide if any <code>pub</code> items are renamed.</li> </ul>"},{"location":"internal/development/refactor-plan/#48-phase-10-release-planning","title":"4.8. Phase 10: Release Planning","text":"<ul> <li>Bump version to <code>0.2.0</code> (semver).</li> <li>Update <code>CHANGELOG.md</code> with highlights.</li> </ul>"},{"location":"internal/development/refactor-plan/#5-technical-debt-catalogue-fix-plan","title":"5. Technical Debt Catalogue &amp; Fix Plan","text":"ID File / Module Issue / Impact / Fix (summary) Effort P0 <code>src/parser.rs</code> Monolithic, complex logic. Rewrite as Pratt/recursive descent parser. L P0 <code>src/main.rs:95</code> Custom JSON formatter. Use <code>serde_json</code>. S P1 <code>src/parser.rs:313</code> Parser calculates token positions. Lexer should emit spans. M P1 <code>src/main.rs:45</code> CLI pre-processes input. Move logic to lexer. S P1 everywhere Inconsistent error handling. Eliminate <code>Error::Custom</code>. M P2 <code>tests/</code> Lack of property-based testing. Add <code>proptest</code>. M P2 <code>src/lib.rs</code> Tests inside lib. Move to <code>tests/</code>. S"},{"location":"internal/development/refactor-plan/#6-testing-quality-gates","title":"6. Testing &amp; Quality Gates","text":"<ul> <li>Coverage Baseline: Measure with <code>cargo-tarpaulin</code>.</li> <li>Target Coverage: <code>vexy_json-core</code> \u226595%, CLI \u226580%, WASM \u226590%.</li> <li>Testing Pyramid: Unit, integration, property-based, and performance tests.</li> <li>CI Workflow: Format, lint, test, coverage, bench, build artifacts.</li> <li>Deliverable Checklist per PR:</li> <li><code>./build.sh</code> green locally.</li> <li>All tests &amp; benches pass on CI.</li> <li>Coverage \u226590% for touched code.</li> <li>Docs updated for public API changes.</li> <li>CHANGELOG entry under Unreleased.</li> </ul>"},{"location":"internal/development/refactor-plan/#7-migration-strategy","title":"7. Migration Strategy","text":"<ul> <li>Create <code>refactor/workspace</code> branch.</li> <li>Convert to Cargo workspace; create new crate structure.</li> <li>Migrate core files first; re-export from old crate for compatibility.</li> <li>Add <code>--refactor-parser</code> CLI flag for dual-track testing.</li> <li>Run CI on both old and new implementations until cut-over.</li> <li>Tag before each major step for rollback.</li> </ul>"},{"location":"internal/development/refactor-plan/#8-performance-targets","title":"8. Performance Targets","text":"<ul> <li>Parsing Throughput: 10MB in &lt;100ms (release build).</li> <li>Performance Parity: Within 3% of old parser, within 10% of <code>serde_json</code>.</li> <li>WASM: 1MB in &lt;50ms in browser.</li> <li>Use <code>cargo-flamegraph</code> and <code>pprof</code> for profiling.</li> </ul>"},{"location":"internal/development/refactor-plan/#9-documentation-dx","title":"9. Documentation &amp; DX","text":"<ul> <li>API docs auto-generated and deployed.</li> <li>Examples for CLI, core, WASM.</li> <li>Updated README with badges.</li> <li>CONTRIBUTING.md with workflow, style, PR checklist.</li> </ul>"},{"location":"internal/development/refactor-plan/#10-timeline-milestones","title":"10. Timeline &amp; Milestones","text":"Week Deliverable Success Metric 1-2 Workspace setup &amp; <code>vexy_json-core</code> created CI green, core builds, dead code removed. 3-4 Lexer refactored, emits spans Token struct has span, parser updated. 5-8 New parser implemented Property tests pass. 9-10 CLI/WASM migrated to new parser All integration tests pass. 11 Old parser removed, final cleanup No breaking changes in public API. 12 Docs updated, refactor branch merged Branch merged to main."},{"location":"internal/development/refactor-plan/#11-acceptance-criteria","title":"11. Acceptance Criteria","text":"<ul> <li>All CLI flags and behaviors preserved.</li> <li>Public Rust API is identical or a superset, verified with <code>cargo-public-api diff</code>.</li> <li>WASM bundle size \u2264300KB gzipped.</li> <li>CI pipeline completes in &lt;12 minutes.</li> <li>Test coverage for core \u226595%.</li> <li>No performance regressions on benchmarks.</li> <li>Only minimal, essential files in core crate.</li> </ul>"},{"location":"internal/development/refactor-plan/#12-open-questions-assumptions","title":"12. Open Questions &amp; Assumptions","text":"Question Owner Due Date What is the Minimum Supported Rust Version (MSRV) for this project? @engineer-1 Week 1 Are there any clients depending on the exact error messages? @product Week 1 What is the long-term support plan for JSON-C style comments (<code>#</code>)? @product Week 2"},{"location":"internal/development/refactor-plan/#13-final-notes","title":"13. Final Notes","text":"<p>Treat this refactor as paving the road for long-term maintainability and minimalism, not chasing micro-optimizations. When in doubt, choose readability and simplicity, but back up decisions with benchmark data. Periodically re-audit for dead/unused modules and update this plan as new feature gates or refactors are added.</p>"},{"location":"internal/drafts/publication-ready/","title":"\ud83d\ude80 vexy_json v1.1.0 - Ready for Publication","text":""},{"location":"internal/drafts/publication-ready/#status-ready-for-publication","title":"\u2705 Status: READY FOR PUBLICATION","text":"<p>All preparation work is complete. The package is ready for immediate publication to crates.io.</p>"},{"location":"internal/drafts/publication-ready/#verification-complete","title":"\ud83d\udccb Verification Complete","text":"<ul> <li>\u2705 All Tests Passing: 73/73 tests pass (100% success rate)</li> <li>\u2705 Zero Warnings: Clean build with no compiler or clippy warnings</li> <li>\u2705 Dry Run Successful: Package builds and verifies correctly</li> <li>\u2705 Repository URL Fixed: Corrected to point to GitHub repository</li> <li>\u2705 Package Size: 141 files, 793.5KiB compressed (reasonable size)</li> </ul>"},{"location":"internal/drafts/publication-ready/#next-steps-user-action-required","title":"\ud83d\udd11 Next Steps (User Action Required)","text":"<ol> <li>Get your crates.io API token from https://crates.io/settings/tokens</li> <li>Login to crates.io: <code>cargo login &lt;YOUR_API_TOKEN&gt;</code></li> <li>Publish the package: <code>cargo publish</code></li> </ol>"},{"location":"internal/drafts/publication-ready/#package-details","title":"\ud83d\udce6 Package Details","text":"<ul> <li>Version: 1.1.0</li> <li>Name: vexy_json</li> <li>Description: A forgiving JSON parser - Rust forgiving JSON parser</li> <li>Repository: https://github.com/vexyart/vexy-json</li> <li>License: MIT OR Apache-2.0</li> <li>Keywords: json, parser, forgiving, the reference implementation</li> <li>Categories: parser-implementations, encoding</li> </ul>"},{"location":"internal/drafts/publication-ready/#whats-included","title":"\ud83d\udcca What's Included","text":"<ul> <li>Core library with all forgiving JSON features</li> <li>CLI tool (<code>vexy_json</code> binary)</li> <li>WebAssembly bindings (optional feature)</li> <li>Comprehensive test suite (73 tests)</li> <li>Performance benchmarks</li> <li>Complete documentation</li> </ul>"},{"location":"internal/drafts/publication-ready/#post-publication-tasks","title":"\ud83c\udfaf Post-Publication Tasks","text":"<p>After successful publication, update: - Documentation links in README.md - Version references in web tool - Create release announcement - Tag the git repository</p> <p>Thread G2 Status: Ready for final user authentication and publication step.</p>"},{"location":"internal/drafts/refactor-prompt/","title":"Refactor prompt","text":"<p>Read @llms.txt which contains the snapshot of the entire codebase.</p> <p>Analyze the entire #codebase </p> <p>Update REFACTOR.md so that it becomes a very detailed plan of refactoring the code, under the following principles:</p> <ol> <li>Production-grade Quality \u2013 Aim for clean, idiomatic, boring Rust. No clever macros where straightforward code is clearer.</li> <li>Parity With Reference Implementation \u2013 Behaviour must remain 100 % compatible with the original JavaScript <code>the reference implementation</code> test-suite unless a conscious deviation is documented.</li> <li>Incremental, Review-friendly Commits \u2013 Small, atomic commits that each compile and keep the test-suite green.</li> <li>Minimal Public-API Breakage \u2013 The current crate is already used in downstream code and WASM builds; any unavoidable breaking change must be sign-posted in the CHANGELOG and guarded by a semver bump.</li> <li>Performance Awareness \u2013 Never regress the existing Criterion benchmarks by more than 3 % unless the change gives a functional or maintainability win that clearly outweighs the cost.</li> <li>Great DX \u2013 Improve docs, examples and error messages as you touch code; run <code>./build.sh</code> locally before pushing.</li> <li>Security &amp; Safety First \u2013 Eliminate <code>unsafe</code> (currently none), check for <code>TODO: unwrap</code> / <code>expect</code>, replace with fallible code paths.</li> </ol> <p>The refactor will be delivered as a series of pull-requests structured around themes so that reviewers can digest them easily.</p> <p>Below is a detailed, step-by-step playbook you \u2013 the engineer \u2013 should follow. Feel free to adjust the ordering if downstream work uncovers hidden coupling, but always keep commits small and the repo green.</p>"},{"location":"internal/drafts/refactor-prompt/#1-on-boarding-12-day","title":"1. On-boarding (\u00bd day)","text":"<ul> <li>Clone the repo, run <code>./build.sh</code>, open <code>./build.log.txt</code> \u2013 ensure you start from a clean, reproducible state.</li> <li>Scan <code>docs/internal/CLAUDE.md</code>, <code>IMPLEMENTATION_SUMMARY.md</code>, <code>PLAN.md</code> to understand design intent.</li> <li>Run the benchmarks (<code>cargo bench --bench parsing</code>) and note baseline numbers in a personal scratchpad.</li> <li>Create a new branch <code>refactor/phase-1-module-layout</code> for the first PR.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#2-restructure-the-module-tree-1-day","title":"2. Restructure the Module Tree (1 day)","text":"<p>Goal: make the crate\u2019s public surface and internal structure obvious at a glance.</p> <p>1.1 Move binaries into <code>src/bin/</code>  Currently we have <code>main.rs</code> and <code>bin/harness.rs</code>; place both under <code>src/bin/</code> and use descriptive names (<code>cli.rs</code>, <code>harness.rs</code>). Adjust Cargo manifest <code>[bin]</code> sections accordingly.</p> <p>1.2 Introduce <code>src/ast/</code>  Create a dedicated module for the concrete syntax tree (tokens) and abstract syntax tree (Value) to localise parsing artefacts. File split suggestion:</p> <ul> <li><code>src/ast/mod.rs</code> \u2013 re-exports</li> <li><code>src/ast/token.rs</code> \u2013 existing <code>Token</code> enum + helper impls</li> <li><code>src/ast/value.rs</code> \u2013 existing <code>Value</code>, <code>Number</code>, conversions, feature-gated <code>serde</code></li> </ul> <p>1.3 Isolate Error Handling    Move <code>error.rs</code> into <code>src/error/mod.rs</code>; create sub-modules:</p> <ul> <li><code>kind.rs</code> \u2013 the <code>Error</code> enum</li> <li><code>position.rs</code> \u2013 a lightweight <code>Span { start: usize, end: usize }</code></li> </ul> <p>1.4 Public API Barrel File <code>lib.rs</code> should become a concise index that re-exports public types; the heavy doc-comment with README inclusion can move to <code>docs/api.md</code>.</p> <p>Deliverables: new folder structure, imports updated, tests &amp; benchmarks still pass.</p>"},{"location":"internal/drafts/refactor-prompt/#3-simplify-the-lexer-2-3-days","title":"3. Simplify the Lexer (2-3 days)","text":"<p>The current lexer contains duplicated state machines and ad-hoc look-ahead logic. Steps:</p> <p>2.1 Extract Config \u2013 Config flags like <code>allow_single_quotes</code> belong in <code>ParserOptions</code> only; remove duplication from lexer. The lexer should tokenise regardless of permissiveness; the parser decides if a token is legal in context.</p> <p>2.2 Use <code>logos</code> \u2013 Evaluate replacing the handwritten lexer with the <code>logos</code> crate (MIT licensed, no runtime deps). Benchmark; accept if equal or faster and code is clearer.</p> <p>2.3 Remove <code>lexer2.rs</code> \u2013 It\u2019s an experiment that has diverged; either promote it (if chosen) or delete.</p> <p>2.4 Canonical Token Stream \u2013 Ensure every character of input maps to exactly one token stream position; add invariant tests (property test with <code>quickcheck</code>) that <code>iter::sum(token.len()) == input.len()</code> apart from whitespace.</p>"},{"location":"internal/drafts/refactor-prompt/#4-parser-clean-up-3-days","title":"4. Parser Clean-up (3 days)","text":"<p>3.1 Introduce <code>ParserState</code> struct instead of many boolean fields to group stateful data (<code>depth</code>, <code>lexer_offset</code>, etc.).</p> <p>3.2 Tail-recursion removal \u2013 Replace deep recursion on arrays/objects with an explicit stack to honour <code>max_depth</code> without risking stack overflow.</p> <p>3.3 Improve Error Reporting \u2013 Switch from raw <code>usize</code> positions to the <code>Span</code> type; implement <code>fmt::Display</code> to highlight offending slice with a caret.</p> <p>3.4 Config Validation \u2013 Add <code>ParserOptions::validate()</code> that returns <code>Result&lt;(), ConfigError&gt;</code>; e.g. <code>newline_as_comma=false</code> + <code>implicit_top_level=true</code> is ambiguously specified \u2013 decide policy and enforce.</p> <p>3.5 Property-based tests \u2013 Port <code>the reference implementation</code> round-trip tests; generate random forgiving JSON, parse, serialise back to canonical JSON, compare using serde_json Value.</p>"},{"location":"internal/drafts/refactor-prompt/#5-error-result-type-revamp-1-day","title":"5. Error &amp; Result Type Revamp (1 day)","text":"<ul> <li>Implement the <code>thiserror</code> crate for boilerplate.</li> <li>Provide an <code>Error::source()</code> chain so WASM callers can access root cause.</li> <li>Export a <code>type ParseResult&lt;T = Value&gt; = core::result::Result&lt;T, Error&gt;</code> alias.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#6-wasm-bindings-overhaul-12-day","title":"6. WASM Bindings Overhaul (\u00bd day)","text":"<ul> <li>Re-generate with <code>wasm-bindgen</code> 0.2.latest; enable <code>weak-refs</code> for memory leaks fix.</li> <li>Expose <code>parse_with_options(json, options)</code> where <code>options</code> is a JS object; derive <code>serde_wasm_bindgen</code> for bridging.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#7-benchmark-ci-pipeline-1-day","title":"7. Benchmark &amp; CI Pipeline (1 day)","text":"<ul> <li>Move Criterion benches under <code>benches/</code> root, use <code>cargo bench --workspace</code>.</li> <li>GitHub Actions matrix: <code>stable</code>, <code>beta</code>, <code>nightly</code>, plus <code>wasm32-unknown-unknown</code> build.</li> <li>Add <code>cargo udeps</code> and <code>cargo deny</code> checks.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#8-documentation-pass-112-days","title":"8. Documentation Pass (1\u00bd days)","text":"<ul> <li>Update code comments to explain why not just what.</li> <li>Auto-generate docs via <code>cargo doc --workspace --no-deps</code> in CI; deploy to <code>gh-pages</code>.</li> <li>Write a migration guide if any <code>pub</code> items are renamed.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#9-release-planning-12-day","title":"9. Release Planning (\u00bd day)","text":"<ul> <li>Bump version to <code>0.2.0</code> following semver since internal layout changed.</li> <li>Update <code>CHANGELOG.md</code> with highlights: module re-org, logos lexer, better error messages.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#91-deliverable-checklist-per-pr","title":"9.1. Deliverable Checklist per PR","text":"<ol> <li><code>./build.sh</code> green locally.</li> <li>All tests &amp; benches pass on CI.</li> <li>Coverage \u2265 90 % for touched code (grcov).</li> <li>Added / updated docs where public API changed.</li> <li>CHANGELOG entry under Unreleased.</li> </ol>"},{"location":"internal/drafts/refactor-prompt/#10-nice-to-have-stretch-goals-do-not-block-v020","title":"10. Nice-to-have Stretch Goals (do not block v0.2.0)","text":"<ul> <li>Plug a streaming serializer to avoid building intermediate <code>Value</code>s for large input.</li> <li>Explore <code>simd-utf8</code> for lexing speed-ups.</li> <li>Accept <code>Cow&lt;str&gt;</code> input to allow zero-copy parse in some contexts.</li> </ul>"},{"location":"internal/drafts/refactor-prompt/#101-final-notes","title":"10.1. Final Notes","text":"<p>Treat the refactor as paving the road for long-term maintainability rather than chasing micro-optimisations. When in doubt choose readability \u2013 but back it up with benchmark data.</p>"},{"location":"internal/drafts/work-progress/","title":"Work progress","text":""},{"location":"internal/drafts/work-progress/#this_file-docsinternaldraftswork-progressmd","title":"this_file: docs/internal/drafts/work-progress.md","text":""},{"location":"internal/drafts/work-progress/#work-progress","title":"WORK Progress","text":""},{"location":"internal/drafts/work-progress/#current-status","title":"Current Status","text":"<p>Project Status: \u2705 CORE DEVELOPMENT COMPLETE</p> <p>All core development goals have been achieved as of January 8, 2025. The vexy_json parser is fully functional with: - Complete forgiving JSON parsing capabilities - 100% test suite pass rate - Jekyll web tool integration - Comprehensive documentation - Clean build system - WASM npm package ready for publishing - Full streaming parser implementation</p>"},{"location":"internal/drafts/work-progress/#current-task-phase-0-codebase-cleanup","title":"Current Task: Phase 0 - Codebase Cleanup","text":"<p>Status: \u2705 COMPLETED (January 9, 2025)</p> <p>Successfully cleaned up the codebase structure by removing unnecessary debug and test files from the main directory.</p>"},{"location":"internal/drafts/work-progress/#completed-work-items","title":"Completed Work Items:","text":"<ul> <li>[x] Analyze current project structure and identify files to clean up</li> <li>[x] Remove debug files from main directory (debug_lexer.rs, debug_spans.rs)</li> <li>[x] Remove test files from main directory (test_*.rs files, test_simple)</li> <li>[x] Evaluate src/lib.rs and determine if it should be moved or removed (kept as main library)</li> <li>[x] Update build configuration if needed (no changes required)</li> <li>[x] Verify project builds correctly after cleanup (builds successfully)</li> </ul>"},{"location":"internal/drafts/work-progress/#changes-made","title":"Changes Made:","text":"<ul> <li>Removed <code>debug_lexer.rs</code> and <code>debug_spans.rs</code> from main directory</li> <li>Removed <code>test_array.rs</code>, <code>test_debug_property.rs</code>, <code>test_edge_cases_verify.rs</code>, <code>test_edge_cases.rs</code>, <code>test_parsing.rs</code>, <code>test_simple.rs</code>, and <code>test_simple</code> from main directory</li> <li>Kept <code>src/lib.rs</code> as it serves as the main library file that re-exports functionality from core crates</li> <li>Project structure is now clean with proper separation between main library, crates, examples, and tests</li> </ul>"},{"location":"internal/drafts/work-progress/#current-task-phase-1b-enhanced-features","title":"Current Task: Phase 1b - Enhanced Features","text":"<p>Status: \ud83d\udd04 IN PROGRESS (Started January 9, 2025)</p> <p>Working on Phase 1b: Enhanced Features (Week 3-4) including comprehensive repair detection, performance optimizations, and CLI integration.</p>"},{"location":"internal/drafts/work-progress/#current-phase-1b-work-items","title":"Current Phase 1b Work Items:","text":"<ul> <li>[x] Implement comprehensive repair action detection and tracking</li> <li>[x] Add performance optimizations for three-tier parsing approach</li> <li>[x] Implement repair caching and optimization strategies</li> <li>[ ] Integrate repair functionality into CLI with new command-line options</li> <li>[ ] Create enhanced error reporting with repair summaries</li> <li>[ ] Add configuration options for repair behavior and limits</li> </ul>"},{"location":"internal/drafts/work-progress/#previously-completed-phase-1a-json-repair-core-integration","title":"Previously Completed: Phase 1a - JSON Repair Core Integration \u2705","text":"<p>Status: \u2705 COMPLETED (January 9, 2025)</p> <p>Successfully implemented the core JSON repair integration with a three-tier parsing strategy and internal repair functionality.</p>"},{"location":"internal/drafts/work-progress/#completed-phase-1a-work-items","title":"Completed Phase 1a Work Items:","text":"<ul> <li>[x] Add JSON repair dependency (implemented internal <code>JsonRepairer</code> solution)</li> <li>[x] Implement new <code>EnhancedParseResult&lt;T&gt;</code> type with error tracking and repair reporting</li> <li>[x] Create <code>parse_with_fallback()</code> function with three-tier parsing strategy</li> <li>[x] Add bracket mismatch detection functionality (<code>is_bracket_mismatch_error</code>)</li> <li>[x] Implement basic repair functionality with internal <code>JsonRepairer</code> class</li> <li>[x] Add new <code>ParserOptions</code> fields for repair configuration</li> <li>[x] Create repair action tracking and reporting system</li> </ul>"},{"location":"internal/drafts/work-progress/#implementation-details","title":"Implementation Details:","text":"<ul> <li>Three-tier parsing strategy: serde_json (fast) \u2192 vexy_json (forgiving) \u2192 repair (tolerant)</li> <li>Internal repair implementation: Custom <code>JsonRepairer</code> for bracket balancing</li> <li>Enhanced error types: Added <code>RepairFailed</code>, <code>BracketMismatch</code>, <code>UnbalancedBrackets</code>, <code>MaxRepairsExceeded</code></li> <li>Repair tracking: <code>RepairAction</code> and <code>RepairType</code> enums with detailed reporting</li> <li>Backward compatibility: Existing <code>parse()</code> function now uses repair by default</li> </ul>"},{"location":"internal/drafts/work-progress/#research-findings-previously-completed","title":"Research Findings (Previously Completed):","text":"<ul> <li>[x] Research error recovery techniques for tolerant JSON parsing</li> <li>[x] Analyze existing solutions like <code>json-repair</code> crate</li> <li>[x] Study theoretical foundations (PEG with labeled failures, GLR parsers, etc.)</li> <li>[x] Investigate practical heuristics for bracket balancing</li> <li>[x] Create comprehensive specification for <code>json-repair</code> integration (see issues/106.txt)</li> <li>[x] Design fallback chain architecture (fastest \u2192 core vexy_json \u2192 json-repair)</li> <li>[x] Plan implementation strategy with minimal disruption to existing code</li> </ul>"},{"location":"internal/drafts/work-progress/#research-findings","title":"Research Findings:","text":"<ul> <li>Extensive research completed on advanced error recovery techniques</li> <li>Identified <code>json-repair</code> crate as viable solution for bracket mismatch handling</li> <li>Found multiple approaches: panic-mode recovery, PEG labeled failures, GLR parsing</li> <li>Documented strategies from academic research and practical implementations</li> <li>Key insight: Three-tier parsing approach (serde_json \u2192 vexy_json \u2192 json-repair) for optimal performance</li> </ul>"},{"location":"internal/drafts/work-progress/#recently-completed-streaming-parser-implementation","title":"Recently Completed: Streaming Parser Implementation \u2705","text":"<p>Status: \u2705 COMPLETED (January 8, 2025)</p> <p>Successfully implemented a comprehensive streaming parser that enables parsing of very large JSON files without loading the entire content into memory:</p> <ul> <li>StreamingParser: Event-driven parser with incremental processing</li> <li>SimpleStreamingLexer: Character-by-character tokenization with state management</li> <li>NDJSON Support: Full support for newline-delimited JSON parsing</li> <li>StreamingValueBuilder: Utility for building Value objects from events</li> <li>Comprehensive API: Complete event-based streaming interface</li> <li>Documentation: Full API documentation with examples</li> </ul>"},{"location":"internal/drafts/work-progress/#recent-completion-python-bindings-implementation","title":"Recent Completion: Python Bindings Implementation \u2705","text":"<p>Status: \u2705 COMPLETED (January 8, 2025)</p> <p>Successfully implemented comprehensive Python bindings that make vexy_json available to Python users via PyO3 bindings:</p> <ul> <li>Core API: Complete Python bindings with <code>parse()</code>, <code>loads()</code>, <code>parse_with_options()</code>, <code>is_valid()</code>, <code>dumps()</code></li> <li>File Operations: Added <code>load()</code> and <code>dump()</code> functions for file-like objects</li> <li>Type System: Seamless conversion between Rust <code>Value</code> and Python objects</li> <li>Error Handling: Proper Python exceptions with detailed error messages</li> <li>Package Structure: Complete Python package with modern PyO3 v0.22 integration</li> <li>Testing: Comprehensive test suite with 88.5% success rate (23/26 tests passing)</li> <li>Documentation: Complete README and API documentation</li> <li>Build System: Maturin configuration ready for PyPI publishing</li> </ul>"},{"location":"internal/drafts/work-progress/#recent-completion-cli-enhancements-implementation","title":"Recent Completion: CLI Enhancements Implementation \u2705","text":"<p>Status: \u2705 COMPLETED (January 8, 2025)</p> <p>Successfully implemented comprehensive CLI enhancements that transform vexy_json from a basic parser into a powerful JSON processing tool:</p> <ul> <li>Enhanced CLI Interface: 15+ new command-line options and flags</li> <li>Advanced Processing: Watch mode (<code>--watch</code>), parallel processing (<code>--parallel</code>), batch operations</li> <li>Professional Output: Compact, pretty printing, validation modes with colored error reporting</li> <li>Modern Architecture: Async/await with tokio, rayon parallel processing, comprehensive error handling</li> <li>User Experience: File I/O, real-time monitoring, context-aware error messages</li> </ul> <p>Key Features Added: - Real-time file monitoring with <code>--watch</code> flag - Parallel multi-file processing with <code>--parallel</code>  - Enhanced error reporting with line/column context - Multiple output formats (compact, pretty, validation) - Granular parser option controls via CLI flags - File input/output with <code>--output</code> option</p>"},{"location":"internal/drafts/work-progress/#next-phase-json-repair-integration-implementation","title":"Next Phase: JSON Repair Integration Implementation","text":"<p>Status: \ud83d\udccb PLANNED (Starting after specification completion)</p> <p>The next phase focuses on implementing the JSON repair integration based on the comprehensive specification being developed.</p>"},{"location":"internal/drafts/work-progress/#implementation-plan","title":"Implementation Plan","text":"<p>Phase 1: Core Integration (Upcoming) - [ ] Add <code>json-repair</code> crate dependency - [ ] Implement three-tier parsing architecture - [ ] Create fallback chain with performance monitoring - [ ] Add configuration options for repair behavior - [ ] Implement error reporting and diagnostics</p> <p>Phase 2: Testing &amp; Validation - [ ] Comprehensive test suite for bracket mismatch scenarios - [ ] Performance benchmarking for three-tier approach - [ ] Integration tests with existing functionality - [ ] Edge case testing and validation</p> <p>Phase 3: Documentation &amp; Polish - [ ] Update API documentation - [ ] Create usage examples and tutorials - [ ] Performance optimization and fine-tuning - [ ] CLI integration for repair functionality</p>"},{"location":"internal/drafts/work-progress/#notes","title":"Notes","text":"<p>The project continues to be in a stable, production-ready state. The JSON repair integration will be additive and maintain backward compatibility while significantly expanding the parser's error recovery capabilities.</p>"},{"location":"user/","title":"User Documentation","text":"<p>Welcome to Vexy JSON! This section contains everything you need to get started and make the most of our forgiving JSON parser.</p>"},{"location":"user/#quick-start","title":"\ud83d\ude80 Quick Start","text":"<ul> <li>Interactive Demo - Try Vexy JSON in your browser</li> <li>Getting Started - Installation and basic usage</li> <li>Features Overview - What makes Vexy JSON special</li> </ul>"},{"location":"user/#api-documentation","title":"\ud83d\udcda API Documentation","text":"<p>Choose your preferred language or platform:</p> <ul> <li>Rust - Native Rust library</li> <li>Python - Python bindings </li> <li>JavaScript/WASM - WebAssembly for browsers</li> <li>CLI Tool - Command-line interface</li> <li>Streaming API - Process large JSON files</li> </ul>"},{"location":"user/#how-to-guides","title":"\ud83c\udfaf How-To Guides","text":"<p>Step-by-step guides for common tasks:</p> <ul> <li>Migration Guide - Switching from other JSON parsers</li> <li>JSON Repair - Fix broken JSON automatically</li> <li>Error Handling - Handle parsing errors gracefully</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"user/#reference","title":"\ud83d\udcd6 Reference","text":"<ul> <li>Release Notes - Version history and changes</li> <li>Configuration Options - All parser options</li> <li>Error Types - Complete error reference</li> </ul>"},{"location":"user/#examples","title":"\ud83d\udca1 Examples","text":"<p>Real-world usage examples:</p> <ul> <li>Configuration Files - Parse config files with comments</li> <li>API Responses - Handle malformed API data</li> <li>Log Processing - Process JSON logs</li> </ul>"},{"location":"user/features-overview/","title":"Vexy JSON Features Overview","text":"<p>Vexy JSON is a comprehensive JSON parsing library that provides robust, forgiving JSON parsing with advanced features for transformation, repair, and optimization.</p>"},{"location":"user/features-overview/#core-features","title":"Core Features","text":""},{"location":"user/features-overview/#forgiving-json-parsing","title":"Forgiving JSON Parsing","text":"<p>Vexy JSON accepts JSON that would be rejected by standard parsers:</p> <pre><code>use vexy_json_core::parse;\n\n// Comments are allowed\nlet json = r#\"\n{\n    \"name\": \"John\",  // Person's name\n    \"age\": 30        /* Person's age */\n}\n\"#;\n\n// Trailing commas are fine\nlet json = r#\"{\"items\": [1, 2, 3,]}\"#;\n\n// Unquoted keys work\nlet json = r#\"{name: \"John\", age: 30}\"#;\n\n// Single quotes are supported\nlet json = r#\"{'name': 'John', 'age': 30}\"#;\n\n// Newlines can act as commas\nlet json = r#\"\n{\n    \"a\": 1\n    \"b\": 2\n}\n\"#;\n</code></pre>"},{"location":"user/features-overview/#multiple-parser-implementations","title":"Multiple Parser Implementations","text":"<p>Vexy JSON provides several parser implementations optimized for different use cases:</p> <ul> <li>Standard Parser: Full-featured with all forgiving capabilities</li> <li>Optimized Parser: Performance-focused with reduced memory allocation</li> <li>Optimized Parser V2: Enhanced version with additional optimizations</li> <li>Recursive Descent Parser: Clean, maintainable recursive implementation</li> <li>Iterative Parser: Stack-based parser for deep JSON structures</li> </ul>"},{"location":"user/features-overview/#advanced-features","title":"Advanced Features","text":""},{"location":"user/features-overview/#json-transformation","title":"JSON Transformation","text":""},{"location":"user/features-overview/#normalization","title":"Normalization","text":"<p>Standardize JSON format for consistent processing:</p> <pre><code>use vexy_json_core::transform::normalize;\n\nlet json = r#\"{\"z\": 1, \"a\": 2, \"b\": null}\"#;\nlet normalized = normalize(json).unwrap();\n// Result: {\"a\": 2, \"b\": null, \"z\": 1}\n</code></pre>"},{"location":"user/features-overview/#optimization","title":"Optimization","text":"<p>Improve JSON structure for performance:</p> <pre><code>use vexy_json_core::transform::optimize;\n\nlet json = r#\"{\"count\": 42.0, \"price\": 19.0}\"#;\nlet optimized = optimize(&amp;json).unwrap();\n// Numbers optimized: {\"count\": 42, \"price\": 19}\n</code></pre>"},{"location":"user/features-overview/#json-repair","title":"JSON Repair","text":"<p>Automatically fix common JSON issues:</p> <pre><code>use vexy_json_core::repair::JsonRepairer;\n\nlet mut repairer = JsonRepairer::new(10);\nlet broken = r#\"{\"key\": \"value\", \"missing\": \"quote}\"#;\nlet (fixed, repairs) = repairer.repair(broken).unwrap();\n</code></pre>"},{"location":"user/features-overview/#streaming-support","title":"Streaming Support","text":"<p>Process large JSON files efficiently:</p> <pre><code>use vexy_json_core::streaming::parse_streaming;\n\nfor value in parse_streaming(reader)? {\n    // Process each JSON value as it's parsed\n    process(value?);\n}\n</code></pre>"},{"location":"user/features-overview/#parallel-processing","title":"Parallel Processing","text":"<p>Parse multiple JSON documents simultaneously:</p> <pre><code>use vexy_json_core::parallel::parse_parallel;\n\nlet results = parse_parallel(&amp;json_strings, ParallelConfig::default())?;\n</code></pre>"},{"location":"user/features-overview/#language-bindings","title":"Language Bindings","text":""},{"location":"user/features-overview/#python-integration","title":"Python Integration","text":"<p>Full-featured Python bindings with NumPy and Pandas support:</p> <pre><code>import vexy_json\n\n# Standard JSON parsing\ndata = vexy_json.loads('{\"name\": \"John\", \"age\": 30}')\n\n# NumPy integration\nimport numpy as np\narray = vexy_json.loads_numpy('[1, 2, 3, 4, 5]')\n\n# Pandas integration\nimport pandas as pd\ndf = vexy_json.loads_dataframe('[{\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4}]')\n\n# Streaming support\nwith vexy_json.StreamingParser() as parser:\n    for item in parser.parse_stream(file_handle):\n        process(item)\n</code></pre>"},{"location":"user/features-overview/#webassembly-support","title":"WebAssembly Support","text":"<p>Run Vexy JSON in browsers and JavaScript environments:</p> <pre><code>import init, { parse } from 'vexy_json-wasm';\n\nawait init();\nconst result = parse('{\"name\": \"John\", age: 30}');\n</code></pre>"},{"location":"user/features-overview/#performance-features","title":"Performance Features","text":""},{"location":"user/features-overview/#memory-optimization","title":"Memory Optimization","text":"<ul> <li>String Interning: Deduplicate repeated strings</li> <li>Zero-Copy Parsing: Minimize memory allocations</li> <li>Lazy Evaluation: Parse only what's needed</li> </ul>"},{"location":"user/features-overview/#speed-optimization","title":"Speed Optimization","text":"<ul> <li>SIMD Instructions: Vectorized operations where available</li> <li>Optimized Hot Paths: Fast paths for common cases</li> <li>Parallel Processing: Multi-threaded parsing for large datasets</li> </ul>"},{"location":"user/features-overview/#error-handling-and-recovery","title":"Error Handling and Recovery","text":""},{"location":"user/features-overview/#comprehensive-error-reporting","title":"Comprehensive Error Reporting","text":"<pre><code>use vexy_json_core::parse;\n\nmatch parse(invalid_json) {\n    Ok(value) =&gt; println!(\"Parsed: {:?}\", value),\n    Err(error) =&gt; {\n        println!(\"Parse error at position {}: {}\", \n                 error.position(), error.description());\n    }\n}\n</code></pre>"},{"location":"user/features-overview/#automatic-recovery","title":"Automatic Recovery","text":"<pre><code>use vexy_json_core::parser::parse_with_fallback;\n\n// Tries multiple parsing strategies automatically\nlet result = parse_with_fallback(input, options);\n</code></pre>"},{"location":"user/features-overview/#repair-with-confidence-scoring","title":"Repair with Confidence Scoring","text":"<pre><code>use vexy_json_core::repair::advanced::AdvancedJsonRepairer;\n\nlet mut repairer = AdvancedJsonRepairer::new();\nlet (fixed, strategies) = repairer.repair(input)?;\n\nfor strategy in strategies {\n    println!(\"Applied repair: {} (confidence: {:.2})\", \n             strategy.action.description, \n             strategy.confidence.value());\n}\n</code></pre>"},{"location":"user/features-overview/#plugin-system","title":"Plugin System","text":"<p>Extend Vexy JSON with custom functionality:</p> <pre><code>use vexy_json_core::plugin::Plugin;\n\nstruct CustomPlugin;\n\nimpl Plugin for CustomPlugin {\n    fn on_parse_start(&amp;mut self, input: &amp;str) -&gt; Result&lt;()&gt; {\n        // Custom pre-processing\n        Ok(())\n    }\n\n    fn transform_value(&amp;mut self, value: &amp;mut Value, path: &amp;str) -&gt; Result&lt;()&gt; {\n        // Custom value transformation\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"user/features-overview/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"user/features-overview/#schema-validation","title":"Schema Validation","text":"<pre><code>use vexy_json_core::plugin::SchemaValidationPlugin;\n\nlet plugin = SchemaValidationPlugin::new(schema);\n// Validates JSON against schema during parsing\n</code></pre>"},{"location":"user/features-overview/#datetime-parsing","title":"Date/Time Parsing","text":"<pre><code>use vexy_json_core::plugin::DateTimePlugin;\n\nlet plugin = DateTimePlugin::new();\n// Automatically parses ISO 8601 date strings\n</code></pre>"},{"location":"user/features-overview/#comment-preservation","title":"Comment Preservation","text":"<pre><code>use vexy_json_core::plugin::CommentPreservationPlugin;\n\nlet plugin = CommentPreservationPlugin::new();\n// Preserves comments in parsed JSON\n</code></pre>"},{"location":"user/features-overview/#testing-and-fuzzing","title":"Testing and Fuzzing","text":""},{"location":"user/features-overview/#comprehensive-test-suite","title":"Comprehensive Test Suite","text":"<ul> <li>Unit Tests: Test individual components</li> <li>Integration Tests: Test full parsing workflows</li> <li>Property Tests: Test with generated inputs</li> <li>Fuzzing Tests: Test with random inputs</li> </ul>"},{"location":"user/features-overview/#continuous-integration","title":"Continuous Integration","text":"<ul> <li>Cross-Platform Testing: Linux, macOS, Windows</li> <li>Multiple Rust Versions: Stable, beta, nightly</li> <li>Performance Regression Detection: Automatic benchmarking</li> </ul>"},{"location":"user/features-overview/#documentation-and-examples","title":"Documentation and Examples","text":""},{"location":"user/features-overview/#api-documentation","title":"API Documentation","text":"<p>Complete rustdoc documentation for all public APIs.</p>"},{"location":"user/features-overview/#example-programs","title":"Example Programs","text":"<ul> <li>Basic Usage: Simple parsing examples</li> <li>Advanced Features: Complex parsing scenarios</li> <li>Performance: Benchmarking and optimization</li> <li>Integration: Using Vexy JSON with other libraries</li> </ul>"},{"location":"user/features-overview/#migration-guides","title":"Migration Guides","text":"<ul> <li>From serde_json: How to migrate existing code</li> <li>From other parsers: Comparison and migration tips</li> </ul>"},{"location":"user/features-overview/#use-cases","title":"Use Cases","text":""},{"location":"user/features-overview/#web-development","title":"Web Development","text":"<ul> <li>API Parsing: Handle inconsistent API responses</li> <li>Configuration: Parse config files with comments</li> <li>Data Processing: Transform and normalize JSON data</li> </ul>"},{"location":"user/features-overview/#data-science","title":"Data Science","text":"<ul> <li>NumPy Integration: Parse JSON directly to arrays</li> <li>Pandas Integration: Convert JSON to DataFrames</li> <li>Streaming: Process large datasets efficiently</li> </ul>"},{"location":"user/features-overview/#systems-programming","title":"Systems Programming","text":"<ul> <li>High Performance: Optimized parsing for speed</li> <li>Low Memory: Efficient memory usage</li> <li>Reliability: Robust error handling</li> </ul>"},{"location":"user/features-overview/#cross-platform-development","title":"Cross-Platform Development","text":"<ul> <li>Rust Libraries: Native Rust performance</li> <li>Python Extensions: Fast Python bindings</li> <li>Web Applications: WebAssembly support</li> </ul>"},{"location":"user/features-overview/#future-roadmap","title":"Future Roadmap","text":""},{"location":"user/features-overview/#planned-features","title":"Planned Features","text":"<ul> <li>Additional Language Bindings: JavaScript, Go, Java</li> <li>Enhanced Streaming: More streaming formats</li> <li>Advanced Optimization: Further performance improvements</li> <li>Schema Evolution: Automatic schema migration</li> </ul>"},{"location":"user/features-overview/#community-contributions","title":"Community Contributions","text":"<p>Vexy JSON welcomes contributions in:</p> <ul> <li>Feature Development: New parsing features</li> <li>Performance Optimization: Speed and memory improvements</li> <li>Documentation: Examples and guides</li> <li>Testing: Additional test cases and fuzzing</li> </ul> <p>This comprehensive feature set makes Vexy JSON suitable for a wide range of JSON processing needs, from simple parsing to complex data transformation and analysis.</p>"},{"location":"user/features/","title":"Features","text":"<p>a: 1, b: 2</p>"},{"location":"user/features/#forgiving-features","title":"Forgiving Features","text":"<p><code>vexy_json</code> is a forgiving JSON parser, handling common deviations from strict JSON (RFC 8259). Below are the supported forgiving features, enhanced in v2.0.0 with streaming, parallel processing, and plugin capabilities:</p>"},{"location":"user/features/#comments","title":"Comments","text":"<ul> <li>Single-line: <code>// ...</code> and <code># ...</code></li> <li>Multi-line: <code>/* ... */</code></li> </ul> <p>Comments are ignored anywhere whitespace is allowed.</p> <p>Example:</p> <pre><code>{\n  // This is a single-line comment\n  age: 30, # Another single-line comment\n  /* Multi-line\n     comment */\n  name: \"Alice\"\n}\n</code></pre>"},{"location":"user/features/#unquoted-keys","title":"Unquoted Keys","text":"<p>Object keys can be unquoted if they are valid identifiers.</p> <pre><code>{ name: \"vexy_json\", version: 1.0 }\n</code></pre>"},{"location":"user/features/#trailing-commas","title":"Trailing Commas","text":"<p>Trailing commas are allowed in arrays and objects.</p> <pre><code>{\n  a: 1,\n  b: 2,\n}\n</code></pre>"},{"location":"user/features/#implicit-top-level-objects-and-arrays","title":"Implicit Top-Level Objects and Arrays","text":"<p>You can omit brackets for top-level arrays or objects:</p> <pre><code>apple, banana, cherry\n# Interpreted as [\"apple\", \"banana\", \"cherry\"]\n\n\n# Interpreted as {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"user/features/#newlines-as-comma-separators","title":"Newlines as Comma Separators","text":"<p>When enabled, newlines can act as value separators, like commas, in arrays and objects.</p> <pre><code>[\n  1\n  2\n  3\n]\n</code></pre> <pre><code>{\n  key1: \"value1\"\n  key2: \"value2\"\n}\n</code></pre>"},{"location":"user/features/#extended-number-formats","title":"Extended Number Formats","text":"<ul> <li>Hexadecimal: <code>0xFF</code></li> <li>Octal: <code>0o77</code></li> <li>Binary: <code>0b1010</code></li> <li>Underscores: <code>1_000_000</code></li> </ul>"},{"location":"user/features/#single-quoted-strings","title":"Single-Quoted Strings","text":"<p>Both single and double quotes are supported for strings.</p> <pre><code>{ key: 'value', other: \"also ok\" }\n</code></pre>"},{"location":"user/features/#strict-mode","title":"Strict Mode","text":"<p>All forgiving features can be disabled for strict RFC 8259 compliance.</p> <p>These forgiving features make <code>vexy_json</code> a flexible parser for configurations, data files, and other scenarios where strict JSON adherence might be relaxed.</p>"},{"location":"user/features/#new-in-v200-advanced-features","title":"New in v2.0.0: Advanced Features","text":""},{"location":"user/features/#streaming-parser","title":"Streaming Parser","text":"<p>Process large JSON files incrementally: - Memory-efficient parsing for gigabyte-sized files - Event-driven API for fine-grained control - Support for incremental data feeds</p>"},{"location":"user/features/#parallel-processing","title":"Parallel Processing","text":"<p>Leverage multiple CPU cores: - Automatic work distribution across threads - Intelligent chunk boundary detection - Linear scalability with core count</p>"},{"location":"user/features/#plugin-architecture","title":"Plugin Architecture","text":"<p>Extend vexy_json with custom functionality: - Transform values during parsing - Add custom validation rules - Implement domain-specific logic</p>"},{"location":"user/features/#ndjson-support","title":"NDJSON Support","text":"<p>Native support for newline-delimited JSON: - Process streaming data sources - Handle log files and data exports - Efficient line-by-line parsing</p> <p>For detailed API documentation on these features, see the API Reference.</p>"},{"location":"user/getting-started/","title":"Usage Guide v2.0.0","text":"<p>This guide provides in-depth examples for using <code>vexy_json</code> v2.0.0 in Rust and JavaScript/WebAssembly, including the new streaming API, parallel processing, and plugin system.</p>"},{"location":"user/getting-started/#basic-parsing-rust","title":"Basic Parsing (Rust)","text":"<p>The simplest way to use vexy_json is with the <code>parse</code> function:</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    let json_data = r#\"{ key: \"value\", num: 123, // comment\\n trailing: [1,2,3,], hex: 0xFF }\"#;\n    let value = parse(json_data).unwrap();\n    println!(\"{:?}\", value);\n}\n</code></pre>"},{"location":"user/getting-started/#customizing-parsing-with-parseroptions","title":"Customizing Parsing with <code>ParserOptions</code>","text":"<p>For more control, use <code>parse_with_options</code> and configure <code>ParserOptions</code>:</p> <pre><code>use vexy_json::{parse_with_options, ParserOptions};\n\nfn main() {\n    let input = \"a:1, b:2\";\n    let options = ParserOptions {\n        allow_comments: true,\n        allow_unquoted_keys: true,\n        allow_trailing_commas: true,\n        allow_implicit_top_level: true,\n        allow_newline_as_comma: true,\n        allow_single_quoted_strings: true,\n        allow_extended_numbers: true,\n        ..Default::default()\n    };\n    let value = parse_with_options(input, &amp;options).unwrap();\n    println!(\"{:?}\", value);\n}\n</code></pre>"},{"location":"user/getting-started/#webassemblyjavascript-usage","title":"WebAssembly/JavaScript Usage","text":"<p>See docs/wasm.md for full API details.</p> <pre><code>import init, { parse_json_with_options } from './pkg/vexy_json_wasm.js';\n\nawait init();\nconst result = parse_json_with_options('{a:1}', { allow_comments: true });\nconsole.log(result); // { a: 1 }\n</code></pre>"},{"location":"user/getting-started/#customizing-parsing-with-parseroptions_1","title":"Customizing Parsing with <code>ParserOptions</code>","text":"<p>For more control over the parsing behavior, you can use <code>parse_with_options</code> and configure <code>ParserOptions</code>.</p> <pre><code>use vexy_json::{parse_with_options, ParserOptions};\n\nfn main() {\n    // Example: Strict JSON parsing (disabling all forgiving features)\n    let mut strict_options = ParserOptions::default();\n    strict_options.allow_comments = false;\n    strict_options.allow_trailing_commas = false;\n    strict_options.allow_unquoted_keys = false;\n    strict_options.allow_single_quotes = false;\n    strict_options.implicit_top_level = false;\n    strict_options.newline_as_comma = false;\n\n    let strict_json = r#\"{\"key\": \"value\"}\"#;\n    match parse_with_options(strict_json, strict_options) {\n        Ok(value) =&gt; println!(\"Parsed strictly: {:?}\", value),\n        Err(e) =&gt; eprintln!(\"Strict parsing error: {}\", e),\n    }\n\n    // Example: Allowing only unquoted keys and implicit top-level\n    let mut custom_options = ParserOptions::default();\n    custom_options.allow_unquoted_keys = true;\n    custom_options.implicit_top_level = true;\n    custom_options.allow_comments = false; // Keep other defaults or explicitly set\n\n    let custom_json = r#\"myKey: \"myValue\", another: 42\"#;\n    match parse_with_options(custom_json, custom_options) {\n        Ok(value) =&gt; println!(\"Parsed with custom options: {:?}\", value),\n        Err(e) =&gt; eprintln!(\"Custom parsing error: {}\", e),\n    }\n}\n</code></pre>"},{"location":"user/getting-started/#handling-forgiving-features","title":"Handling Forgiving Features","text":"<p><code>vexy_json</code> excels at parsing JSON with common relaxations. Here are examples of how it handles them:</p>"},{"location":"user/getting-started/#comments","title":"Comments","text":"<p>Both single-line (<code>//</code>, <code>#</code>) and multi-line (<code>/* ... */</code>) comments are ignored.</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    let json_with_comments = r#\"\n        {\n            // This is a single-line comment\n            \"name\": \"Alice\", /* This is a\n                                multi-line comment */\n            \"age\": 30, # Another comment style\n        }\n    \"#;\n    let value = parse(json_with_comments).unwrap();\n    println!(\"Parsed with comments: {:?}\", value);\n}\n</code></pre>"},{"location":"user/getting-started/#trailing-commas","title":"Trailing Commas","text":"<p>Trailing commas in arrays and objects are gracefully handled.</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    let json_with_trailing_comma = r#\"\n        [\n            1,\n            2,\n            3, // Trailing comma here\n        ]\n    \"#;\n    let value = parse(json_with_trailing_comma).unwrap();\n    println!(\"Parsed with trailing comma: {:#?}\", value);\n\n    let obj_with_trailing_comma = r#\"\n        {\n            key1: \"value1\",\n            key2: \"value2\", // Trailing comma here\n        }\n    \"#;\n    let obj_value = parse(obj_with_trailing_comma).unwrap();\n    println!(\"Parsed object with trailing comma: {:#?}\", obj_value);\n}\n</code></pre>"},{"location":"user/getting-started/#unquoted-keys","title":"Unquoted Keys","text":"<p>Object keys do not need to be quoted, as long as they are valid identifiers.</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    let json_unquoted_keys = r#\"{ firstName: \"John\", lastName: \"Doe\" }\"#;\n    let value = parse(json_unquoted_keys).unwrap();\n    println!(\"Parsed with unquoted keys: {:#?}\", value);\n}\n</code></pre>"},{"location":"user/getting-started/#implicit-top-level-objects-and-arrays","title":"Implicit Top-Level Objects and Arrays","text":"<p>You don't need to wrap your entire input in <code>{}</code> or <code>[]</code> if it's clearly an object or an array.</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    // Implicit object\n    let implicit_obj = r#\"name: \"Bob\", age: 25\"#;\n    let obj_value = parse(implicit_obj).unwrap();\n    println!(\"Parsed implicit object: {:#?}\", obj_value);\n\n    // Implicit array\n    let implicit_arr = r#\"\"apple\", \"banana\", \"cherry\"\"#;\n    let arr_value = parse(implicit_arr).unwrap();\n    println!(\"Parsed implicit array: {:#?}\", arr_value);\n}\n</code></pre>"},{"location":"user/getting-started/#newline-as-comma","title":"Newline as Comma","text":"<p>When the <code>newline_as_comma</code> option is enabled, newlines can act as implicit comma separators.</p> <pre><code>use vexy_json::{parse_with_options, ParserOptions};\n\nfn main() {\n    let mut options = ParserOptions::default();\n    options.newline_as_comma = true;\n\n    let json_with_newlines = r#\"\n        [\n            1\n            2\n            3\n        ]\n    \"#;\n    let value = parse_with_options(json_with_newlines, options).unwrap();\n    println!(\"Parsed with newlines as commas: {:#?}\", value);\n\n    let obj_with_newlines = r#\"\n        {\n            key1: \"value1\"\n            key2: \"value2\"\n        }\n    \"#;\n    let obj_value = parse_with_options(obj_with_newlines, options).unwrap();\n    println!(\"Parsed object with newlines as commas: {:#?}\", obj_value);\n}\n</code></pre>"},{"location":"user/getting-started/#error-handling","title":"Error Handling","text":"<p><code>vexy_json</code> returns a <code>Result&lt;Value, Error&gt;</code> which allows for robust error handling. You should always check the <code>Result</code> to handle potential parsing issues.</p> <pre><code>use vexy_json::parse;\n\nfn main() {\n    let invalid_json = r#\"{ key: \"value }\"#; // Missing closing quote\n    match parse(invalid_json) {\n        Ok(value) =&gt; println!(\"Parsed: {:?}\", value),\n        Err(e) =&gt; eprintln!(\"Parsing error: {}\", e),\n    }\n}\n</code></pre> <p>For more details on error types, refer to the API Reference.</p>"},{"location":"user/getting-started/#streaming-api-usage-new-in-v200","title":"Streaming API Usage (New in v2.0.0)","text":"<p>The streaming API is ideal for processing large JSON files without loading them entirely into memory.</p>"},{"location":"user/getting-started/#basic-streaming-example","title":"Basic Streaming Example","text":"<pre><code>use vexy_json::{StreamingParser, StreamingEvent};\n\nfn process_large_file(json_content: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut parser = StreamingParser::new();\n    parser.feed(json_content)?;\n    parser.finish()?;\n\n    let mut depth = 0;\n    while let Some(event) = parser.next_event()? {\n        match event {\n            StreamingEvent::StartObject =&gt; {\n                println!(\"{:indent$}Object {\", \"\", indent = depth * 2);\n                depth += 1;\n            }\n            StreamingEvent::EndObject =&gt; {\n                depth -= 1;\n                println!(\"{:indent$}}}\", \"\", indent = depth * 2);\n            }\n            StreamingEvent::ObjectKey(key) =&gt; {\n                print!(\"{:indent$}{}: \", \"\", key, indent = depth * 2);\n            }\n            StreamingEvent::String(s) =&gt; println!(\"\\\"{}\\\"\", s),\n            StreamingEvent::Number(n) =&gt; println!(\"{}\", n),\n            StreamingEvent::Bool(b) =&gt; println!(\"{}\", b),\n            StreamingEvent::Null =&gt; println!(\"null\"),\n            StreamingEvent::EndOfInput =&gt; break,\n            _ =&gt; {}\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"user/getting-started/#incremental-parsing","title":"Incremental Parsing","text":"<p>Perfect for network streams or reading files in chunks:</p> <pre><code>use vexy_json::StreamingParser;\nuse std::io::{BufReader, BufRead};\nuse std::fs::File;\n\nfn parse_file_incrementally(path: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n    let mut parser = StreamingParser::new();\n\n    for line in reader.lines() {\n        parser.feed(&amp;line?)?;\n\n        // Process available events after each line\n        while let Some(event) = parser.next_event()? {\n            // Handle events...\n        }\n    }\n\n    parser.finish()?;\n    Ok(())\n}\n</code></pre>"},{"location":"user/getting-started/#parallel-processing-new-in-v200","title":"Parallel Processing (New in v2.0.0)","text":"<p>Process multiple JSON files or strings in parallel for improved performance.</p>"},{"location":"user/getting-started/#basic-parallel-parsing","title":"Basic Parallel Parsing","text":"<pre><code>use vexy_json::{parse_parallel, ParallelOptions};\nuse std::fs;\n\nfn process_json_files(directory: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let files: Vec&lt;String&gt; = fs::read_dir(directory)?\n        .filter_map(|entry| {\n            entry.ok().and_then(|e| {\n                let path = e.path();\n                if path.extension()? == \"json\" {\n                    fs::read_to_string(path).ok()\n                } else {\n                    None\n                }\n            })\n        })\n        .collect();\n\n    let results = parse_parallel(files);\n\n    for (i, result) in results.iter().enumerate() {\n        match result {\n            Ok(value) =&gt; println!(\"File {} parsed successfully\", i),\n            Err(e) =&gt; eprintln!(\"Error in file {}: {}\", i, e),\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"user/getting-started/#custom-parallel-options","title":"Custom Parallel Options","text":"<pre><code>use vexy_json::{parse_parallel_with_options, ParallelOptions, ParserOptions};\n\nlet mut parallel_opts = ParallelOptions::default();\nparallel_opts.num_threads = Some(8);  // Use 8 threads\nparallel_opts.chunk_size = Some(100); // Process 100 items per chunk\n\nlet mut parser_opts = ParserOptions::default();\nparser_opts.allow_comments = true;\nparser_opts.allow_trailing_commas = true;\n\nparallel_opts.parser_options = parser_opts;\n\nlet results = parse_parallel_with_options(json_strings, parallel_opts);\n</code></pre>"},{"location":"user/getting-started/#plugin-system-new-in-v200","title":"Plugin System (New in v2.0.0)","text":"<p>Extend vexy_json with custom functionality through plugins.</p>"},{"location":"user/getting-started/#creating-a-custom-plugin","title":"Creating a Custom Plugin","text":"<pre><code>use vexy_json::{Plugin, Value, Error};\nuse std::collections::HashMap;\n\n// Plugin to redact sensitive information\nstruct RedactPlugin {\n    sensitive_keys: Vec&lt;String&gt;,\n}\n\nimpl Plugin for RedactPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"redact-sensitive\"\n    }\n\n    fn transform(&amp;self, value: &amp;mut Value) -&gt; Result&lt;(), Error&gt; {\n        match value {\n            Value::Object(map) =&gt; {\n                for key in &amp;self.sensitive_keys {\n                    if map.contains_key(key) {\n                        map.insert(key.clone(), Value::String(\"[REDACTED]\".to_string()));\n                    }\n                }\n                // Recursively process nested objects\n                for (_, v) in map.iter_mut() {\n                    self.transform(v)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for v in arr.iter_mut() {\n                    self.transform(v)?;\n                }\n            }\n            _ =&gt; {}\n        }\n        Ok(())\n    }\n}\n\n// Usage\nlet plugin = RedactPlugin {\n    sensitive_keys: vec![\"password\".to_string(), \"api_key\".to_string()],\n};\n\nlet plugins: Vec&lt;Box&lt;dyn Plugin&gt;&gt; = vec![Box::new(plugin)];\nlet value = parse_with_plugins(json_str, ParserOptions::default(), &amp;plugins)?;\n</code></pre>"},{"location":"user/getting-started/#validation-plugin-example","title":"Validation Plugin Example","text":"<pre><code>struct SchemaValidatorPlugin {\n    required_fields: Vec&lt;String&gt;,\n}\n\nimpl Plugin for SchemaValidatorPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"schema-validator\"\n    }\n\n    fn transform(&amp;self, _value: &amp;mut Value) -&gt; Result&lt;(), Error&gt; {\n        Ok(()) // No transformation needed\n    }\n\n    fn validate(&amp;self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {\n        if let Value::Object(map) = value {\n            for field in &amp;self.required_fields {\n                if !map.contains_key(field) {\n                    return Err(Error::Custom(\n                        format!(\"Missing required field: {}\", field)\n                    ));\n                }\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"user/getting-started/#ndjson-newline-delimited-json-support-new-in-v200","title":"NDJSON (Newline-Delimited JSON) Support (New in v2.0.0)","text":"<p>Process streams of JSON objects separated by newlines.</p> <pre><code>use vexy_json::NdJsonParser;\n\nfn process_log_file(log_content: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut parser = NdJsonParser::new();\n    let entries = parser.feed(log_content)?;\n\n    println!(\"Processed {} log entries\", entries.len());\n\n    for (i, entry) in entries.iter().enumerate() {\n        if let Some(timestamp) = entry.get(\"timestamp\") {\n            println!(\"Entry {}: {:?}\", i, timestamp);\n        }\n    }\n\n    Ok(())\n}\n\n// Example input:\n// {\"timestamp\": \"2024-01-01T00:00:00Z\", \"level\": \"INFO\", \"message\": \"Server started\"}\n// {\"timestamp\": \"2024-01-01T00:01:00Z\", \"level\": \"ERROR\", \"message\": \"Connection failed\"}\n// {\"timestamp\": \"2024-01-01T00:02:00Z\", \"level\": \"INFO\", \"message\": \"Retry successful\"}\n</code></pre>"},{"location":"user/getting-started/#advanced-cli-usage-new-in-v200","title":"Advanced CLI Usage (New in v2.0.0)","text":"<p>The v2.0.0 CLI includes powerful new features:</p>"},{"location":"user/getting-started/#watch-mode","title":"Watch Mode","text":"<pre><code># Watch a file for changes and reformat on save\nvexy_json --watch config.json --output formatted-config.json\n\n# Watch a directory\nvexy_json --watch ./configs/ --output-dir ./formatted/\n</code></pre>"},{"location":"user/getting-started/#batch-processing","title":"Batch Processing","text":"<pre><code># Process multiple files in parallel\nvexy_json --parallel *.json --output-dir ./processed/\n\n# Apply transformations during batch processing\nvexy_json --batch ./data/ --pretty --sort-keys --output-dir ./formatted/\n</code></pre>"},{"location":"user/getting-started/#plugin-usage","title":"Plugin Usage","text":"<pre><code># Use built-in plugins\nvexy_json input.json --plugin redact-passwords --plugin validate-schema\n\n# Load custom plugin\nvexy_json input.json --plugin-path ./my-plugin.wasm\n</code></pre> <p>For more details on the web tool, including its features and how to use it, refer to the Web Tool documentation.</p>"},{"location":"user/api/python-bindings/","title":"Python Bindings","text":"<p>Vexy JSON provides comprehensive Python bindings that offer all the functionality of the Rust library with a familiar Python API. The bindings are designed to be both performant and easy to use.</p>"},{"location":"user/api/python-bindings/#installation","title":"Installation","text":"<pre><code>pip install vexy_json\n</code></pre>"},{"location":"user/api/python-bindings/#basic-usage","title":"Basic Usage","text":""},{"location":"user/api/python-bindings/#parsing-json","title":"Parsing JSON","text":"<pre><code>import vexy_json\n\n# Standard JSON parsing\ndata = vexy_json.loads('{\"name\": \"John\", \"age\": 30}')\nprint(data)  # {'name': 'John', 'age': 30}\n\n# Parse with forgiving features\ndata = vexy_json.loads('''\n{\n    name: \"John\",  // Unquoted keys and comments\n    age: 30,       // Trailing comma is okay\n}\n''')\n</code></pre>"},{"location":"user/api/python-bindings/#json-compatibility","title":"JSON Compatibility","text":"<p>The Vexy JSON Python bindings provide full compatibility with the standard <code>json</code> module:</p> <pre><code>import vexy_json\n\n# Drop-in replacement for json.loads()\ndata = vexy_json.loads('{\"key\": \"value\"}')\n\n# All standard json functions are available\njson_str = vexy_json.dumps(data)\njson_str = vexy_json.dumps(data, indent=2)\n\n# File operations\nwith open('data.json', 'r') as f:\n    data = vexy_json.load(f)\n\nwith open('output.json', 'w') as f:\n    vexy_json.dump(data, f, indent=2)\n</code></pre>"},{"location":"user/api/python-bindings/#advanced-parsing-options","title":"Advanced Parsing Options","text":""},{"location":"user/api/python-bindings/#custom-parser-options","title":"Custom Parser Options","text":"<pre><code>import vexy_json\n\n# Parse with custom options\ndata = vexy_json.parse_with_options(\n    json_string,\n    allow_comments=True,\n    allow_trailing_commas=True,\n    allow_unquoted_keys=True,\n    allow_single_quotes=True,\n    implicit_top_level=True,\n    newline_as_comma=True,\n    max_depth=128,\n    enable_repair=True,\n    max_repairs=100,\n    fast_repair=False,\n    report_repairs=True\n)\n</code></pre>"},{"location":"user/api/python-bindings/#validation","title":"Validation","text":"<pre><code>import vexy_json\n\n# Check if JSON is valid\nis_valid = vexy_json.is_valid('{\"valid\": true}')\nprint(is_valid)  # True\n\nis_valid = vexy_json.is_valid('invalid json')\nprint(is_valid)  # False\n</code></pre>"},{"location":"user/api/python-bindings/#streaming-support","title":"Streaming Support","text":""},{"location":"user/api/python-bindings/#streaming-parser-with-context-manager","title":"Streaming Parser with Context Manager","text":"<pre><code>import vexy_json\n\n# Parse large JSON files efficiently\nwith vexy_json.StreamingParser() as parser:\n    with open('large_file.json', 'r') as f:\n        for item in parser.parse_stream(f):\n            process(item)\n</code></pre>"},{"location":"user/api/python-bindings/#ndjson-support","title":"NDJSON Support","text":"<pre><code>import vexy_json\n\n# Parse NDJSON (newline-delimited JSON)\nwith vexy_json.StreamingParser() as parser:\n    with open('data.ndjson', 'r') as f:\n        for item in parser.parse_lines(f):\n            process(item)\n</code></pre>"},{"location":"user/api/python-bindings/#custom-streaming-options","title":"Custom Streaming Options","text":"<pre><code>import vexy_json\n\n# Create streaming parser with custom options\nparser = vexy_json.StreamingParser(\n    allow_comments=True,\n    allow_trailing_commas=True,\n    enable_repair=True\n)\n\nwith parser as p:\n    for item in p.parse_stream(file_handle):\n        process(item)\n</code></pre>"},{"location":"user/api/python-bindings/#numpy-integration","title":"NumPy Integration","text":""},{"location":"user/api/python-bindings/#direct-array-parsing","title":"Direct Array Parsing","text":"<pre><code>import vexy_json\nimport numpy as np\n\n# Parse JSON array directly to NumPy array\narr = vexy_json.loads_numpy('[1, 2, 3, 4, 5]')\nprint(type(arr))  # &lt;class 'numpy.ndarray'&gt;\nprint(arr.dtype)  # int64\n\n# Specify dtype\narr = vexy_json.loads_numpy('[1.1, 2.2, 3.3]', dtype='float32')\nprint(arr.dtype)  # float32\n</code></pre>"},{"location":"user/api/python-bindings/#zero-copy-optimization","title":"Zero-Copy Optimization","text":"<pre><code>import vexy_json\n\n# Optimized parsing for numeric data\narr = vexy_json.loads_numpy_zerocopy('[1, 2, 3, 4, 5]', dtype='int64')\n# Uses zero-copy when possible for better performance\n</code></pre>"},{"location":"user/api/python-bindings/#mixed-data-types","title":"Mixed Data Types","text":"<pre><code>import vexy_json\n\n# Handle mixed arrays\narr = vexy_json.loads_numpy('[1, 2.5, 3, 4.7]')\nprint(arr.dtype)  # float64 (automatically promoted)\n\n# Non-numeric data falls back to object arrays\narr = vexy_json.loads_numpy('[\"a\", \"b\", \"c\"]')\nprint(arr.dtype)  # object\n</code></pre>"},{"location":"user/api/python-bindings/#pandas-integration","title":"Pandas Integration","text":""},{"location":"user/api/python-bindings/#dataframe-conversion","title":"DataFrame Conversion","text":"<pre><code>import vexy_json\nimport pandas as pd\n\n# Parse JSON to DataFrame\njson_data = '[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]'\ndf = vexy_json.loads_dataframe(json_data)\nprint(type(df))  # &lt;class 'pandas.core.frame.DataFrame'&gt;\n\n# Specify orientation\ndf = vexy_json.loads_dataframe(json_data, orient='records')\n</code></pre>"},{"location":"user/api/python-bindings/#error-handling","title":"Error Handling","text":""},{"location":"user/api/python-bindings/#parse-errors","title":"Parse Errors","text":"<pre><code>import vexy_json\n\ntry:\n    data = vexy_json.loads('invalid json')\nexcept ValueError as e:\n    print(f\"Parse error: {e}\")\n</code></pre>"},{"location":"user/api/python-bindings/#repair-functionality","title":"Repair Functionality","text":"<pre><code>import vexy_json\n\n# Automatic repair of common JSON issues\ntry:\n    data = vexy_json.loads('{\"key\": \"value\",}')  # Trailing comma\n    print(data)  # Successfully parsed\nexcept ValueError as e:\n    print(f\"Even repair failed: {e}\")\n</code></pre>"},{"location":"user/api/python-bindings/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user/api/python-bindings/#choosing-the-right-function","title":"Choosing the Right Function","text":"<pre><code>import vexy_json\n\n# For standard JSON, use loads() for compatibility\ndata = vexy_json.loads(standard_json)\n\n# For forgiving JSON, use parse_with_options()\ndata = vexy_json.parse_with_options(\n    forgiving_json,\n    allow_comments=True,\n    allow_trailing_commas=True\n)\n\n# For numerical data, use NumPy integration\narr = vexy_json.loads_numpy(json_array)\n\n# For tabular data, use pandas integration\ndf = vexy_json.loads_dataframe(json_records)\n</code></pre>"},{"location":"user/api/python-bindings/#memory-efficiency","title":"Memory Efficiency","text":"<pre><code>import vexy_json\n\n# Streaming for large files\nwith vexy_json.StreamingParser() as parser:\n    for item in parser.parse_stream(large_file):\n        # Process items one at a time\n        # Memory usage stays constant\n        process(item)\n</code></pre>"},{"location":"user/api/python-bindings/#type-hints","title":"Type Hints","text":"<p>The Python bindings include comprehensive type hints:</p> <pre><code>from typing import Any, Dict, List, Optional, Union\nimport vexy_json\n\ndef process_json(json_str: str) -&gt; Dict[str, Any]:\n    return vexy_json.loads(json_str)\n\ndef safe_parse(json_str: str) -&gt; Optional[Dict[str, Any]]:\n    try:\n        return vexy_json.loads(json_str)\n    except ValueError:\n        return None\n</code></pre>"},{"location":"user/api/python-bindings/#best-practices","title":"Best Practices","text":""},{"location":"user/api/python-bindings/#error-handling_1","title":"Error Handling","text":"<pre><code>import vexy_json\n\ndef safe_parse_json(json_str: str, default=None):\n    \"\"\"Safely parse JSON with fallback.\"\"\"\n    try:\n        return vexy_json.loads(json_str)\n    except ValueError as e:\n        print(f\"JSON parse error: {e}\")\n        return default\n\n# Usage\ndata = safe_parse_json(user_input, default={})\n</code></pre>"},{"location":"user/api/python-bindings/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use appropriate functions: Choose <code>loads()</code> for standard JSON, <code>parse_with_options()</code> for forgiving JSON</li> <li>Streaming for large files: Use <code>StreamingParser</code> for files that don't fit in memory</li> <li>NumPy integration: Use <code>loads_numpy()</code> for numeric arrays</li> <li>Pandas integration: Use <code>loads_dataframe()</code> for tabular data</li> <li>Validate when necessary: Use <code>is_valid()</code> to check JSON before parsing</li> </ol>"},{"location":"user/api/python-bindings/#memory-management","title":"Memory Management","text":"<pre><code>import vexy_json\n\n# For large datasets, prefer streaming\ndef process_large_json(filename):\n    with vexy_json.StreamingParser() as parser:\n        with open(filename, 'r') as f:\n            for item in parser.parse_stream(f):\n                yield process_item(item)\n\n# This keeps memory usage constant regardless of file size\n</code></pre>"},{"location":"user/api/python-bindings/#integration-examples","title":"Integration Examples","text":""},{"location":"user/api/python-bindings/#with-requests","title":"With Requests","text":"<pre><code>import requests\nimport vexy_json\n\nresponse = requests.get('https://api.example.com/data')\ndata = vexy_json.loads(response.text)\n</code></pre>"},{"location":"user/api/python-bindings/#with-fastapi","title":"With FastAPI","text":"<pre><code>from fastapi import FastAPI\nimport vexy_json\n\napp = FastAPI()\n\n@app.post(\"/parse-json\")\nasync def parse_json(content: str):\n    try:\n        data = vexy_json.loads(content)\n        return {\"success\": True, \"data\": data}\n    except ValueError as e:\n        return {\"success\": False, \"error\": str(e)}\n</code></pre>"},{"location":"user/api/python-bindings/#with-django","title":"With Django","text":"<pre><code>from django.http import JsonResponse\nimport vexy_json\n\ndef parse_json_view(request):\n    try:\n        data = vexy_json.loads(request.body)\n        # Process data\n        return JsonResponse({\"success\": True})\n    except ValueError as e:\n        return JsonResponse({\"error\": str(e)}, status=400)\n</code></pre>"},{"location":"user/api/python-bindings/#migration-from-standard-json","title":"Migration from Standard JSON","text":""},{"location":"user/api/python-bindings/#drop-in-replacement","title":"Drop-in Replacement","text":"<pre><code># Before\nimport json\ndata = json.loads(json_string)\n\n# After\nimport vexy_json\ndata = vexy_json.loads(json_string)  # Same interface, more forgiving\n</code></pre>"},{"location":"user/api/python-bindings/#gradual-migration","title":"Gradual Migration","text":"<pre><code>import json\nimport vexy_json\n\ndef parse_json_fallback(json_str):\n    \"\"\"Try standard JSON first, fall back to Vexy JSON.\"\"\"\n    try:\n        return json.loads(json_str)\n    except json.JSONDecodeError:\n        return vexy_json.loads(json_str)  # More forgiving parsing\n</code></pre>"},{"location":"user/api/python-bindings/#advanced-features","title":"Advanced Features","text":""},{"location":"user/api/python-bindings/#custom-serialization","title":"Custom Serialization","text":"<pre><code>import vexy_json\nfrom dataclasses import dataclass\n\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n# Convert to dict first, then serialize\nperson = Person(\"John\", 30)\njson_str = vexy_json.dumps(person.__dict__)\n</code></pre>"},{"location":"user/api/python-bindings/#configuration-management","title":"Configuration Management","text":"<pre><code>import vexy_json\n\n# Parse configuration files with comments\nconfig_str = '''\n{\n    // Database configuration\n    \"database\": {\n        \"host\": \"localhost\",\n        \"port\": 5432,  // Default PostgreSQL port\n        \"name\": \"myapp\",\n    },\n\n    // API settings\n    \"api\": {\n        \"timeout\": 30,\n        \"retries\": 3,\n    }\n}\n'''\n\nconfig = vexy_json.loads(config_str)\n</code></pre> <p>This comprehensive Python API provides all the power of Vexy JSON with the familiar interface Python developers expect.</p>"},{"location":"user/api/rust/","title":"API Reference v2.0.0","text":"<p>This section provides detailed documentation for the <code>vexy_json</code> Rust library v2.0.0. The API is designed to be intuitive and idiomatic for Rust developers, with powerful new features for streaming, parallel processing, and extensibility.</p>"},{"location":"user/api/rust/#vexy_jsonparse","title":"<code>vexy_json::parse</code>","text":"<pre><code>pub fn parse(input: &amp;str) -&gt; Result&lt;Value, Error&gt;\n</code></pre> <p>Parses a JSON-like string into a <code>vexy_json::Value</code> enum using default parser options. This is the primary entry point for using the library.</p> <ul> <li><code>input</code>: The string slice containing the JSON-like data to parse.</li> <li>Returns:<ul> <li><code>Ok(Value)</code>: If parsing is successful, returns a <code>Value</code> enum representing the parsed data.</li> <li><code>Err(Error)</code>: If an error occurs during parsing, returns an <code>Error</code> detailing the issue.</li> </ul> </li> </ul>"},{"location":"user/api/rust/#vexy_jsonparse_with_options","title":"<code>vexy_json::parse_with_options</code>","text":"<pre><code>pub fn parse_with_options(input: &amp;str, options: ParserOptions) -&gt; Result&lt;Value, Error&gt;\n</code></pre> <p>Parses a JSON-like string into a <code>vexy_json::Value</code> enum with custom parser options. This allows fine-grained control over which forgiving features are enabled.</p> <ul> <li><code>input</code>: The string slice containing the JSON-like data to parse.</li> <li><code>options</code>: A <code>ParserOptions</code> struct configuring the parser's behavior.</li> <li>Returns:<ul> <li><code>Ok(Value)</code>: If parsing is successful, returns a <code>Value</code> enum representing the parsed data.</li> <li><code>Err(Error)</code>: If an error occurs during parsing, returns an <code>Error</code> detailing the issue.</li> </ul> </li> </ul>"},{"location":"user/api/rust/#vexy_jsonparseroptions","title":"<code>vexy_json::ParserOptions</code>","text":"<p>This struct defines the configurable options for the <code>vexy_json</code> parser.</p> <pre><code>pub struct ParserOptions {\n    pub allow_comments: bool,\n    pub allow_trailing_commas: bool,\n    pub allow_unquoted_keys: bool,\n    pub allow_single_quotes: bool,\n    pub implicit_top_level: bool,\n    pub newline_as_comma: bool,\n    pub max_depth: usize,\n}\n</code></pre> <ul> <li><code>allow_comments</code>: If <code>true</code>, allows single-line (<code>//</code>, <code>#</code>) and multi-line (<code>/* */</code>) comments. Default: <code>true</code>.</li> <li><code>allow_trailing_commas</code>: If <code>true</code>, allows trailing commas in arrays and objects. Default: <code>true</code>.</li> <li><code>allow_unquoted_keys</code>: If <code>true</code>, allows object keys without quotes (e.g., <code>key: \"value\"</code>). Default: <code>true</code>.</li> <li><code>allow_single_quotes</code>: If <code>true</code>, allows strings to be enclosed in single quotes (<code>'</code>). Default: <code>true</code>.</li> <li><code>implicit_top_level</code>: If <code>true</code>, attempts to parse input not wrapped in <code>{}</code> or <code>[]</code> as an implicit top-level object or array. Default: <code>true</code>.</li> <li><code>newline_as_comma</code>: If <code>true</code>, treats newlines as comma separators in arrays and objects. Default: <code>true</code>.</li> <li><code>max_depth</code>: Maximum recursion depth for nested structures to prevent stack overflow. Default: <code>128</code>.</li> </ul> <p><code>ParserOptions</code> implements <code>Default</code>, so you can create a default instance and then modify specific fields:</p> <pre><code>use vexy_json::ParserOptions;\n\nlet mut options = ParserOptions::default();\noptions.allow_comments = false; // Disable comments\noptions.max_depth = 64; // Set a custom max depth\n</code></pre>"},{"location":"user/api/rust/#vexy_jsonvalue-enum","title":"<code>vexy_json::Value</code> Enum","text":"<p>This enum represents the different types of JSON values that <code>vexy_json</code> can parse.</p> <pre><code>pub enum Value {\n    Null,\n    Bool(bool),\n    Number(Number),\n    String(String),\n    Array(Vec&lt;Value&gt;),\n    Object(HashMap&lt;String, Value&gt;),\n}\n</code></pre> <ul> <li><code>Null</code>: Represents a JSON <code>null</code> value.</li> <li><code>Bool(bool)</code>: Represents a JSON boolean (<code>true</code> or <code>false</code>).</li> <li><code>Number(Number)</code>: Represents a JSON numeric value. See <code>vexy_json::Number</code> for details.</li> <li><code>String(String)</code>: Represents a JSON string.</li> <li><code>Array(Vec&lt;Value&gt;)</code>: Represents a JSON array, a vector of <code>Value</code> enums.</li> <li><code>Object(HashMap&lt;String, Value&gt;)</code>: Represents a JSON object, a hash map of string keys to <code>Value</code> enums.</li> </ul>"},{"location":"user/api/rust/#value-helper-methods","title":"<code>Value</code> Helper Methods","text":"<p>The <code>Value</code> enum provides several helper methods for type checking and value extraction:</p> <ul> <li><code>is_null() -&gt; bool</code></li> <li><code>is_bool() -&gt; bool</code></li> <li><code>is_number() -&gt; bool</code></li> <li><code>is_string() -&gt; bool</code></li> <li><code>is_array() -&gt; bool</code></li> <li><code>is_object() -&gt; bool</code></li> <li><code>as_bool() -&gt; Option&lt;bool&gt;</code></li> <li><code>as_i64() -&gt; Option&lt;i64&gt;</code>: Returns <code>None</code> if the number cannot be represented as <code>i64</code>.</li> <li><code>as_f64() -&gt; Option&lt;f64&gt;</code></li> <li><code>as_str() -&gt; Option&lt;&amp;str&gt;</code></li> <li><code>as_array() -&gt; Option&lt;&amp;Vec&lt;Value&gt;&gt;</code></li> <li><code>as_object() -&gt; Option&lt;&amp;HashMap&lt;String, Value&gt;&gt;</code></li> </ul>"},{"location":"user/api/rust/#vexy_jsonnumber-enum","title":"<code>vexy_json::Number</code> Enum","text":"<p>This enum represents a JSON number, which can be either an integer or a floating-point number.</p> <pre><code>pub enum Number {\n    Integer(i64),\n    Float(f64),\n}\n</code></pre> <ul> <li><code>Integer(i64)</code>: An integer value that fits in an <code>i64</code>.</li> <li><code>Float(f64)</code>: A floating-point value.</li> </ul>"},{"location":"user/api/rust/#vexy_jsonerror-enum","title":"<code>vexy_json::Error</code> Enum","text":"<p>This enum defines the types of errors that can occur during parsing.</p> <pre><code>pub enum Error {\n    UnexpectedChar(char, usize),\n    UnexpectedEof(usize),\n    InvalidNumber(usize),\n    InvalidEscape(usize),\n    InvalidUnicode(usize),\n    UnterminatedString(usize),\n    TrailingComma(usize),\n    Expected {\n        expected: String,\n        found: String,\n        position: usize,\n    },\n    DepthLimitExceeded(usize),\n    Custom(String),\n}\n</code></pre> <ul> <li><code>UnexpectedChar(char, usize)</code>: Encountered an unexpected character during parsing at a given position.</li> <li><code>UnexpectedEof(usize)</code>: Reached the end of the input unexpectedly at a given position.</li> <li><code>InvalidNumber(usize)</code>: An invalid number format was encountered at a given position.</li> <li><code>InvalidEscape(usize)</code>: An invalid escape sequence was found in a string at a given position.</li> <li><code>InvalidUnicode(usize)</code>: An invalid Unicode escape sequence was found at a given position.</li> <li><code>UnterminatedString(usize)</code>: A string literal was not properly terminated, starting at a given position.</li> <li><code>TrailingComma(usize)</code>: A trailing comma was found where not allowed (though typically allowed by <code>vexy_json</code>'s forgiving nature, this error might occur in strict modes or specific contexts) at a given position.</li> <li><code>Expected { expected: String, found: String, position: usize }</code>: The parser expected a specific token or value but found something else at a given position.</li> <li><code>DepthLimitExceeded(usize)</code>: The maximum recursion depth was exceeded while parsing nested structures at a given position.</li> <li><code>Custom(String)</code>: A custom error with a descriptive message.</li> </ul>"},{"location":"user/api/rust/#error-helper-methods","title":"<code>Error</code> Helper Methods","text":"<ul> <li><code>position() -&gt; Option&lt;usize&gt;</code>: Returns the character position in the input where the error occurred, if available.</li> </ul>"},{"location":"user/api/rust/#serde-integration","title":"Serde Integration","text":"<p><code>vexy_json</code> provides optional integration with the <code>serde</code> serialization framework. When the <code>serde</code> feature is enabled in your <code>Cargo.toml</code>, <code>vexy_json::Value</code> and <code>vexy_json::Number</code> implement the <code>Serialize</code> and <code>Deserialize</code> traits. This allows easy conversion between <code>vexy_json::Value</code> and other data formats supported by Serde (e.g., <code>serde_json::Value</code>).</p> <p>To enable this feature, add <code>serde</code> to your <code>vexy_json</code> dependency in <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nvexy_json = { version = \"2.0.0\", features = [\"serde\"] }\n</code></pre> <p>Example:</p> <pre><code>use vexy_json::{parse, Value};\nuse serde_json; // Requires `serde_json` crate\n\nfn main() {\n    let json_str = r#\"{ \"name\": \"Alice\", \"age\": 30 }\"#;\n    let vexy_json_value: Value = parse(json_str).unwrap();\n\n    // Convert vexy_json::Value to serde_json::Value\n    let serde_value: serde_json::Value = serde_json::to_value(vexy_json_value).unwrap();\n    println!(\"Converted to serde_json::Value: {}\", serde_value);\n\n    // Convert serde_json::Value back to vexy_json::Value\n    let new_vexy_json_value: Value = serde_json::from_value(serde_value).unwrap();\n    println!(\"Converted back to vexy_json::Value: {:?}\", new_vexy_json_value);\n}\n</code></pre>"},{"location":"user/api/rust/#webassembly-wasm-bindings","title":"WebAssembly (WASM) Bindings","text":"<p><code>vexy_json</code> offers WebAssembly bindings, allowing it to be used directly in JavaScript environments (e.g., web browsers, Node.js). This is enabled via the <code>wasm</code> feature.</p> <p>To enable this feature, add <code>wasm</code> to your <code>vexy_json</code> dependency in <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nvexy_json = { version = \"2.0.0\", features = [\"wasm\"] }\n</code></pre> <p>For detailed documentation on the WebAssembly API, including JavaScript examples, please refer to the WASM API Reference.</p>"},{"location":"user/api/rust/#streaming-api-new-in-v200","title":"Streaming API (New in v2.0.0)","text":"<p><code>vexy_json</code> v2.0.0 introduces a powerful streaming parser for processing large JSON files incrementally.</p>"},{"location":"user/api/rust/#vexy_jsonstreamingparser","title":"<code>vexy_json::StreamingParser</code>","text":"<pre><code>pub struct StreamingParser { /* ... */ }\n\nimpl StreamingParser {\n    pub fn new() -&gt; Self;\n    pub fn with_options(options: ParserOptions) -&gt; Self;\n    pub fn feed(&amp;mut self, input: &amp;str) -&gt; Result&lt;(), Error&gt;;\n    pub fn finish(&amp;mut self) -&gt; Result&lt;(), Error&gt;;\n    pub fn next_event(&amp;mut self) -&gt; Result&lt;Option&lt;StreamingEvent&gt;, Error&gt;;\n}\n</code></pre> <p>Example usage: <pre><code>use vexy_json::{StreamingParser, StreamingEvent};\n\nlet mut parser = StreamingParser::new();\nparser.feed(r#\"{\"key\": \"value\"}\"#)?;\nparser.finish()?;\n\nwhile let Some(event) = parser.next_event()? {\n    match event {\n        StreamingEvent::StartObject =&gt; println!(\"Object started\"),\n        StreamingEvent::ObjectKey(key) =&gt; println!(\"Key: {}\", key),\n        StreamingEvent::String(s) =&gt; println!(\"String: {}\", s),\n        StreamingEvent::EndObject =&gt; println!(\"Object ended\"),\n        StreamingEvent::EndOfInput =&gt; break,\n        _ =&gt; {}\n    }\n}\n</code></pre></p>"},{"location":"user/api/rust/#vexy_jsonstreamingevent","title":"<code>vexy_json::StreamingEvent</code>","text":"<pre><code>pub enum StreamingEvent {\n    StartObject,\n    EndObject,\n    StartArray,\n    EndArray,\n    ObjectKey(String),\n    Null,\n    Bool(bool),\n    Number(String),\n    String(String),\n    EndOfInput,\n}\n</code></pre>"},{"location":"user/api/rust/#parallel-processing-new-in-v200","title":"Parallel Processing (New in v2.0.0)","text":"<p><code>vexy_json</code> v2.0.0 includes parallel processing capabilities for batch operations using the <code>rayon</code> crate.</p>"},{"location":"user/api/rust/#vexy_jsonparse_parallel","title":"<code>vexy_json::parse_parallel</code>","text":"<pre><code>pub fn parse_parallel&lt;I&gt;(inputs: I) -&gt; Vec&lt;Result&lt;Value, Error&gt;&gt;\nwhere\n    I: IntoParallelIterator,\n    I::Item: AsRef&lt;str&gt;,\n</code></pre> <p>Process multiple JSON strings in parallel:</p> <pre><code>use vexy_json::parse_parallel;\n\nlet json_strings = vec![\n    r#\"{\"id\": 1, \"name\": \"Alice\"}\"#,\n    r#\"{\"id\": 2, \"name\": \"Bob\"}\"#,\n    r#\"{\"id\": 3, \"name\": \"Charlie\"}\"#,\n];\n\nlet results = parse_parallel(json_strings);\nfor (i, result) in results.iter().enumerate() {\n    match result {\n        Ok(value) =&gt; println!(\"Parsed {}: {:?}\", i, value),\n        Err(e) =&gt; eprintln!(\"Error parsing {}: {}\", i, e),\n    }\n}\n</code></pre>"},{"location":"user/api/rust/#vexy_jsonparalleloptions","title":"<code>vexy_json::ParallelOptions</code>","text":"<pre><code>pub struct ParallelOptions {\n    pub parser_options: ParserOptions,\n    pub num_threads: Option&lt;usize&gt;,\n    pub chunk_size: Option&lt;usize&gt;,\n}\n</code></pre>"},{"location":"user/api/rust/#plugin-system-new-in-v200","title":"Plugin System (New in v2.0.0)","text":"<p><code>vexy_json</code> v2.0.0 introduces a plugin architecture for extending parsing capabilities.</p>"},{"location":"user/api/rust/#vexy_jsonplugin-trait","title":"<code>vexy_json::Plugin</code> Trait","text":"<pre><code>pub trait Plugin: Send + Sync {\n    fn name(&amp;self) -&gt; &amp;str;\n    fn transform(&amp;self, value: &amp;mut Value) -&gt; Result&lt;(), Error&gt;;\n    fn validate(&amp;self, value: &amp;Value) -&gt; Result&lt;(), Error&gt; {\n        Ok(())\n    }\n}\n</code></pre> <p>Example plugin implementation:</p> <pre><code>use vexy_json::{Plugin, Value, Error};\n\nstruct DateNormalizerPlugin;\n\nimpl Plugin for DateNormalizerPlugin {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"date-normalizer\"\n    }\n\n    fn transform(&amp;self, value: &amp;mut Value) -&gt; Result&lt;(), Error&gt; {\n        // Transform date strings to ISO format\n        match value {\n            Value::String(s) =&gt; {\n                if is_date_string(s) {\n                    *s = normalize_date(s)?;\n                }\n            }\n            Value::Object(map) =&gt; {\n                for (_, v) in map.iter_mut() {\n                    self.transform(v)?;\n                }\n            }\n            Value::Array(arr) =&gt; {\n                for v in arr.iter_mut() {\n                    self.transform(v)?;\n                }\n            }\n            _ =&gt; {}\n        }\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"user/api/rust/#vexy_jsonparse_with_plugins","title":"<code>vexy_json::parse_with_plugins</code>","text":"<pre><code>pub fn parse_with_plugins(\n    input: &amp;str,\n    options: ParserOptions,\n    plugins: &amp;[Box&lt;dyn Plugin&gt;]\n) -&gt; Result&lt;Value, Error&gt;\n</code></pre> <p>Usage example: <pre><code>use vexy_json::{parse_with_plugins, ParserOptions};\n\nlet plugins: Vec&lt;Box&lt;dyn Plugin&gt;&gt; = vec![\n    Box::new(DateNormalizerPlugin),\n    Box::new(ValidationPlugin::new(schema)),\n];\n\nlet value = parse_with_plugins(input, ParserOptions::default(), &amp;plugins)?;\n</code></pre></p>"},{"location":"user/api/rust/#ndjson-support-new-in-v200","title":"NDJSON Support (New in v2.0.0)","text":""},{"location":"user/api/rust/#vexy_jsonndjsonparser","title":"<code>vexy_json::NdJsonParser</code>","text":"<pre><code>pub struct NdJsonParser { /* ... */ }\n\nimpl NdJsonParser {\n    pub fn new() -&gt; Self;\n    pub fn with_options(options: ParserOptions) -&gt; Self;\n    pub fn feed(&amp;mut self, input: &amp;str) -&gt; Result&lt;Vec&lt;Value&gt;, Error&gt;;\n}\n</code></pre> <p>Example: <pre><code>use vexy_json::NdJsonParser;\n\nlet mut parser = NdJsonParser::new();\nlet input = r#\"{\"id\": 1}\n{\"id\": 2}\n{\"id\": 3}\"#;\n\nlet values = parser.feed(input)?;\nprintln!(\"Parsed {} objects\", values.len());\n</code></pre></p>"},{"location":"user/api/streaming-api/","title":"Streaming Parser API Documentation","text":""},{"location":"user/api/streaming-api/#overview","title":"Overview","text":"<p>The vexy_json streaming parser provides an event-driven API for parsing JSON incrementally, making it suitable for: - Processing large JSON files without loading them entirely into memory - Real-time parsing of JSON data streams - Parsing newline-delimited JSON (NDJSON) files - Building custom JSON processing pipelines</p>"},{"location":"user/api/streaming-api/#core-components","title":"Core Components","text":""},{"location":"user/api/streaming-api/#streamingparser","title":"StreamingParser","text":"<p>The main streaming parser that processes input incrementally and emits parsing events.</p> <pre><code>use vexy_json::{StreamingParser, StreamingEvent};\n\nlet mut parser = StreamingParser::new();\nparser.feed(r#\"{\"key\": \"value\"}\"#)?;\nparser.finish()?;\n\nwhile let Some(event) = parser.next_event()? {\n    match event {\n        StreamingEvent::StartObject =&gt; println!(\"Object started\"),\n        StreamingEvent::ObjectKey(key) =&gt; println!(\"Key: {}\", key),\n        StreamingEvent::String(s) =&gt; println!(\"String: {}\", s),\n        StreamingEvent::EndObject =&gt; println!(\"Object ended\"),\n        StreamingEvent::EndOfInput =&gt; break,\n        _ =&gt; {}\n    }\n}\n</code></pre>"},{"location":"user/api/streaming-api/#streamingevent","title":"StreamingEvent","text":"<p>Events emitted by the streaming parser:</p> <pre><code>pub enum StreamingEvent {\n    StartObject,           // {\n    EndObject,             // }\n    StartArray,            // [\n    EndArray,              // ]\n    ObjectKey(String),     // \"key\":\n    Null,                  // null\n    Bool(bool),            // true/false\n    Number(String),        // 42, 3.14\n    String(String),        // \"text\"\n    EndOfInput,            // End of parsing\n}\n</code></pre>"},{"location":"user/api/streaming-api/#streamingvaluebuilder","title":"StreamingValueBuilder","text":"<p>Utility for building Value objects from streaming events:</p> <pre><code>use vexy_json::{StreamingParser, StreamingValueBuilder};\n\nlet mut parser = StreamingParser::new();\nlet mut builder = StreamingValueBuilder::new();\n\nparser.feed(r#\"{\"name\": \"Alice\", \"age\": 30}\"#)?;\nparser.finish()?;\n\nwhile let Some(event) = parser.next_event()? {\n    builder.process_event(event)?;\n}\n\nlet value = builder.finish()?.unwrap();\nprintln!(\"{}\", value); // {\"name\": \"Alice\", \"age\": 30}\n</code></pre>"},{"location":"user/api/streaming-api/#ndjson-support","title":"NDJSON Support","text":""},{"location":"user/api/streaming-api/#ndjsonparser","title":"NdJsonParser","text":"<p>Parser for newline-delimited JSON where each line is a separate JSON value:</p> <pre><code>use vexy_json::NdJsonParser;\n\nlet mut parser = NdJsonParser::new();\nlet input = r#\"{\"id\": 1, \"name\": \"Alice\"}\n{\"id\": 2, \"name\": \"Bob\"}\n{\"id\": 3, \"name\": \"Charlie\"}\"#;\n\nlet values = parser.feed(input)?;\nprintln!(\"Parsed {} objects\", values.len());\n\nfor value in values {\n    println!(\"{}\", value);\n}\n</code></pre>"},{"location":"user/api/streaming-api/#streamingndjsonparser","title":"StreamingNdJsonParser","text":"<p>Event-based NDJSON parser:</p> <pre><code>use vexy_json::StreamingNdJsonParser;\n\nlet mut parser = StreamingNdJsonParser::new();\nparser.feed(r#\"{\"a\": 1}\n{\"b\": 2}\"#)?;\nparser.finish()?;\n\nwhile let Some(event) = parser.next_event()? {\n    // Process events for each line\n    println!(\"{:?}\", event);\n}\n</code></pre>"},{"location":"user/api/streaming-api/#parser-options","title":"Parser Options","text":"<p>Both streaming parsers support the same options as the regular parser:</p> <pre><code>use vexy_json::{StreamingParser, ParserOptions};\n\nlet options = ParserOptions {\n    allow_comments: true,\n    allow_trailing_commas: true,\n    allow_unquoted_keys: true,\n    allow_single_quotes: true,\n    implicit_top_level: true,\n    newline_as_comma: true,\n    max_depth: 128,\n};\n\nlet mut parser = StreamingParser::with_options(options);\n</code></pre>"},{"location":"user/api/streaming-api/#usage-patterns","title":"Usage Patterns","text":""},{"location":"user/api/streaming-api/#pattern-1-event-processing","title":"Pattern 1: Event Processing","text":"<pre><code>fn process_json_stream(input: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut parser = StreamingParser::new();\n    parser.feed(input)?;\n    parser.finish()?;\n\n    while let Some(event) = parser.next_event()? {\n        match event {\n            StreamingEvent::ObjectKey(key) =&gt; {\n                println!(\"Found key: {}\", key);\n            }\n            StreamingEvent::String(s) =&gt; {\n                println!(\"Found string: {}\", s);\n            }\n            StreamingEvent::EndOfInput =&gt; break,\n            _ =&gt; {}\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"user/api/streaming-api/#pattern-2-incremental-processing","title":"Pattern 2: Incremental Processing","text":"<pre><code>fn process_chunks(chunks: &amp;[&amp;str]) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut parser = StreamingParser::new();\n\n    for chunk in chunks {\n        parser.feed(chunk)?;\n\n        // Process available events after each chunk\n        while let Some(event) = parser.next_event()? {\n            if matches!(event, StreamingEvent::EndOfInput) {\n                break;\n            }\n            // Handle event...\n        }\n    }\n\n    parser.finish()?;\n\n    // Process final events\n    while let Some(event) = parser.next_event()? {\n        if matches!(event, StreamingEvent::EndOfInput) {\n            break;\n        }\n        // Handle final events...\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"user/api/streaming-api/#pattern-3-building-custom-values","title":"Pattern 3: Building Custom Values","text":"<pre><code>fn build_filtered_object(input: &amp;str) -&gt; Result&lt;Value, Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut parser = StreamingParser::new();\n    let mut builder = StreamingValueBuilder::new();\n\n    parser.feed(input)?;\n    parser.finish()?;\n\n    while let Some(event) = parser.next_event()? {\n        // Filter events or transform them\n        match event {\n            StreamingEvent::ObjectKey(key) if key.starts_with(\"_\") =&gt; {\n                // Skip private keys\n                continue;\n            }\n            _ =&gt; builder.process_event(event)?,\n        }\n    }\n\n    Ok(builder.finish()?.unwrap_or(Value::Null))\n}\n</code></pre>"},{"location":"user/api/streaming-api/#error-handling","title":"Error Handling","text":"<p>The streaming parser uses the same error types as the regular parser:</p> <pre><code>use vexy_json::{StreamingParser, Error};\n\nlet mut parser = StreamingParser::new();\n\nmatch parser.feed(\"invalid json\") {\n    Ok(()) =&gt; println!(\"Chunk processed\"),\n    Err(Error::UnexpectedChar(ch, pos)) =&gt; {\n        println!(\"Unexpected character '{}' at position {}\", ch, pos);\n    }\n    Err(e) =&gt; println!(\"Other error: {}\", e),\n}\n</code></pre>"},{"location":"user/api/streaming-api/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Memory Usage: The streaming parser uses minimal memory, only buffering incomplete tokens</li> <li>Latency: Events are emitted as soon as complete tokens are available</li> <li>Throughput: Designed for high-throughput scenarios with large datasets</li> <li>Buffering: Internal buffers are automatically managed and kept minimal</li> </ol>"},{"location":"user/api/streaming-api/#limitations","title":"Limitations","text":"<ol> <li>Token Values: Due to the existing Token enum design, string and number content extraction is simplified in the current implementation</li> <li>Error Recovery: The parser currently fails fast on errors rather than attempting recovery</li> <li>Async Support: Async/await support is planned but not yet implemented</li> </ol>"},{"location":"user/api/streaming-api/#examples","title":"Examples","text":"<p>See <code>examples/streaming_example.rs</code> for a complete working example demonstrating all streaming parser features.</p>"},{"location":"user/api/wasm/","title":"WebAssembly (WASM) API Reference","text":"<p><code>vexy_json</code> provides WebAssembly bindings for use in JavaScript environments (browsers, Node.js). The WASM module exposes parsing functions that mirror the Rust API, including forgiving features and strict mode.</p>"},{"location":"user/api/wasm/#usage","title":"Usage","text":"<pre><code>import init, { parse_json, parse_json_with_options } from './pkg/vexy_json_wasm.js';\n\nawait init();\nconst result = parse_json_with_options('{a:1}', { allow_comments: true });\nconsole.log(result); // { a: 1 }\n</code></pre>"},{"location":"user/api/wasm/#api","title":"API","text":"<ul> <li><code>parse_json(input: string): any</code> \u2014 Parse with default forgiving options</li> <li><code>parse_json_with_options(input: string, options: object): any</code> \u2014 Parse with custom options</li> <li><code>get_parser_options(): object</code> \u2014 Get default options</li> </ul>"},{"location":"user/api/wasm/#options","title":"Options","text":"<p>All forgiving features can be toggled via options (see features.md).</p>"},{"location":"user/api/wasm/#recent-fixes","title":"Recent Fixes","text":"<ul> <li>As of v1.2.4, parsed objects are returned as plain JavaScript objects, not Maps. See Troubleshooting.</li> </ul> <p>\ud83d\udcdd Note: Version 1.2.4 includes a critical fix for object conversion. Previous versions incorrectly returned JavaScript Maps instead of plain objects for parsed JSON. If you're experiencing issues where <code>{a:1}</code> returns <code>{}</code>, please upgrade to version 1.2.4 or later. See Troubleshooting for details.</p> <p>To use the WASM bindings, you need to enable the <code>wasm</code> feature in your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nvexy_json = { version = \"2.0.0\", features = [\"wasm\"] }\n</code></pre> <p>After building your Rust project with the <code>wasm</code> feature (e.g., using <code>wasm-pack</code>), you can import the generated JavaScript module.</p>"},{"location":"user/api/wasm/#available-javascript-functions","title":"Available JavaScript Functions","text":"<p>The following functions are exposed to JavaScript:</p>"},{"location":"user/api/wasm/#init","title":"<code>init()</code>","text":"<pre><code>init(): Promise&lt;void&gt;\n</code></pre> <p>Initializes the WebAssembly module. This function should be called once when the WASM module is loaded to set up proper panic handling for better debugging experience. It returns a Promise that resolves when the WASM module is ready.</p> <p>Example:</p> <pre><code>import init from './pkg/vexy_json_wasm.js';\n\nasync function run() {\n  await init();\n  console.log(\"vexy_json WASM module loaded.\");\n  // Now you can use other vexy_json functions\n}\nrun();\n</code></pre>"},{"location":"user/api/wasm/#parse_jsoninput-string","title":"<code>parse_json(input: string)</code>","text":"<pre><code>parse_json(input: string): any\n</code></pre> <p>Parses a JSON-like string into a JavaScript value using default parser options. This is the main parsing function for WebAssembly usage. It accepts relaxed JSON syntax including comments, unquoted keys, trailing commas, and more.</p> <ul> <li><code>input</code>: The JSON string to parse (supports forgiving syntax).</li> <li>Returns: The successfully parsed value converted to a native JavaScript type (object, array, string, number, boolean, null).</li> <li>Throws: A <code>ParseError</code> object if a parsing error occurs.</li> </ul> <p>Example:</p> <pre><code>import { parse_json } from './pkg/vexy_json_wasm.js';\n\ntry {\n  const result = parse_json(`{\n    // This is a comment\n    key: 'single quotes work',\n    trailing: 'commas allowed',\n  }`);\n  console.log(result);\n  // Output: { key: 'single quotes work', trailing: 'commas allowed' }\n} catch (e) {\n  console.error(`Parse Error: ${e.message} at position ${e.position}`);\n}\n</code></pre>"},{"location":"user/api/wasm/#parse_json_with_optionsinput-string-options-object","title":"<code>parse_json_with_options(input: string, options: object)</code>","text":"<pre><code>parse_json_with_options(input: string, options: object): any\n</code></pre> <p>Parses a JSON string with custom parser options. This function allows fine-grained control over which forgiving features to enable.</p> <ul> <li><code>input</code>: The JSON string to parse.</li> <li><code>options</code>: A JavaScript object with parser configuration properties (see <code>get_parser_options()</code> for available properties).</li> <li>Returns: The successfully parsed value.</li> <li>Throws: A <code>ParseError</code> object if a parsing error occurs.</li> </ul> <p>Example:</p> <pre><code>import { parse_json_with_options } from './pkg/vexy_json_wasm.js';\n\n// Strict JSON mode\nconst strictOptions = {\n  allowComments: false,\n  allowTrailingCommas: false,\n  allowUnquotedKeys: false,\n  allowSingleQuotes: false,\n  implicitTopLevel: false,\n  newlineAsComma: false\n};\n\ntry {\n  const result = parse_json_with_options('{\"key\": \"value\"}', strictOptions);\n  console.log(result);\n} catch (e) {\n  console.error(`Strict Parse Error: ${e.message}`);\n}\n\n// Enable only specific features\nconst customOptions = {\n  allowUnquotedKeys: true,\n  implicitTopLevel: true\n};\n\ntry {\n  const result = parse_json_with_options('key: \"value\"', customOptions);\n  console.log(result);\n} catch (e) {\n  console.error(`Custom Parse Error: ${e.message}`);\n}\n</code></pre>"},{"location":"user/api/wasm/#validate_jsoninput-string","title":"<code>validate_json(input: string)</code>","text":"<pre><code>validate_json(input: string): boolean\n</code></pre> <p>Validates if a JSON string can be successfully parsed. This is a lightweight function that checks syntax validity without constructing the full value tree. Useful for input validation.</p> <ul> <li><code>input</code>: The JSON string to validate.</li> <li>Returns: <code>true</code> if the input is valid and can be parsed, <code>false</code> otherwise.</li> </ul> <p>Example:</p> <pre><code>import { validate_json } from './pkg/vexy_json_wasm.js';\n\nconsole.log(validate_json('{\"key\": \"value\"}')); // true\nconsole.log(validate_json('{key: \"value\"}'));   // true (unquoted keys allowed by default)\nconsole.log(validate_json('{invalid'));         // false\n</code></pre>"},{"location":"user/api/wasm/#get_parser_options","title":"<code>get_parser_options()</code>","text":"<pre><code>get_parser_options(): object\n</code></pre> <p>Returns the current default configuration for the parser as a JavaScript object. This object can be modified and passed to <code>parse_json_with_options</code>.</p> <ul> <li>Returns: A JavaScript object with all available parser options and their default values. The keys are camelCase (e.g., <code>allowComments</code>).</li> </ul> <p>Example:</p> <pre><code>import { get_parser_options, parse_json_with_options } from './pkg/vexy_json_wasm.js';\n\nconst defaultOptions = get_parser_options();\nconsole.log(defaultOptions.allowComments); // true\n\n// Modify specific options\nconst modifiedOptions = { ...defaultOptions, allowComments: false };\nconst result = parse_json_with_options('// comment\\n{\"a\":1}', modifiedOptions); // Will throw error if comments are disabled\n</code></pre>"},{"location":"user/api/wasm/#stringify_valuevalue-any","title":"<code>stringify_value(value: any)</code>","text":"<pre><code>stringify_value(value: any): string\n</code></pre> <p>Converts a JavaScript value (typically obtained from a <code>parse_json</code> operation) back to a compact JSON string representation.</p> <ul> <li><code>value</code>: The JavaScript value to stringify.</li> <li>Returns: A compact JSON string representation.</li> <li>Throws: An error if the value cannot be serialized.</li> </ul> <p>Example:</p> <pre><code>import { parse_json, stringify_value } from './pkg/vexy_json_wasm.js';\n\nconst parsed = parse_json('{key: \"value\", num: 42}');\nconst jsonString = stringify_value(parsed); // '{\"key\":\"value\",\"num\":42}'\nconsole.log(jsonString);\n</code></pre>"},{"location":"user/api/wasm/#get_version_info","title":"<code>get_version_info()</code>","text":"<pre><code>get_version_info(): object\n</code></pre> <p>Returns version and build information for the <code>vexy_json</code> library. Useful for debugging and compatibility checking.</p> <ul> <li>Returns: A JavaScript object with properties like <code>version</code>, <code>description</code>, <code>authors</code>, <code>homepage</code>, <code>repository</code>, and <code>license</code>.</li> </ul> <p>Example:</p> <pre><code>import { get_version_info } from './pkg/vexy_json_wasm.js';\n\nconst info = get_version_info();\nconsole.log(`vexy_json v${info.version} - ${info.description}`);\n</code></pre>"},{"location":"user/api/wasm/#parseerror-class","title":"<code>ParseError</code> Class","text":"<p>When a parsing error occurs in <code>parse_json</code> or <code>parse_json_with_options</code>, a <code>ParseError</code> object is thrown. This class provides structured error information.</p> <pre><code>class ParseError {\n  readonly message: string;\n  readonly position: number;\n}\n</code></pre> <ul> <li><code>message</code>: A string describing what went wrong.</li> <li><code>position</code>: The character position in the input string where the error occurred (0-indexed).</li> </ul> <p>Example (Error Handling):</p> <pre><code>import { parse_json } from './pkg/vexy_json_wasm.js';\n\ntry {\n  parse_json('{invalid json');\n} catch (e) {\n  if (e instanceof Error &amp;&amp; e.message.startsWith('Parse Error:')) { // Basic check for ParseError\n    console.error(`Caught vexy_json ParseError: ${e.message} at position ${e.position}`);\n  } else {\n    console.error(`Caught unexpected error: ${e}`);\n  }\n}\n</code></pre>"},{"location":"user/api/python/","title":"vexy_json - Forgiving JSON Parser for Python","text":"<p>A Python library for parsing \"forgiving\" JSON, which is JSON that includes features like:</p> <ul> <li>Comments (single-line <code>//</code> and multi-line <code>/* */</code>)</li> <li>Trailing commas in arrays and objects</li> <li>Unquoted object keys</li> <li>Single-quoted strings</li> <li>Implicit top-level objects and arrays</li> <li>Newlines as comma separators</li> </ul> <p>This is a Python binding for the Rust vexy_json library, which is a port of the JavaScript the reference implementation library.</p>"},{"location":"user/api/python/#installation","title":"Installation","text":"<pre><code>pip install vexy_json\n</code></pre>"},{"location":"user/api/python/#quick-start","title":"Quick Start","text":"<pre><code>import vexy_json\n\n# Parse forgiving JSON\nresult = vexy_json.parse('''\n{\n    // This is a comment\n    name: \"Alice\",\n    age: 30,\n    active: true,  // trailing comma is OK\n}\n''')\n\nprint(result)\n# Output: {'name': 'Alice', 'age': 30, 'active': True}\n</code></pre>"},{"location":"user/api/python/#features","title":"Features","text":""},{"location":"user/api/python/#basic-parsing","title":"Basic Parsing","text":"<pre><code>import vexy_json\n\n# Standard JSON\ndata = vexy_json.parse('{\"key\": \"value\"}')\n\n# Forgiving features\ndata = vexy_json.parse('''\n{\n    // Comments are allowed\n    unquoted_key: \"value\",\n    'single_quotes': true,\n    trailing_comma: \"ok\",\n}\n''')\n</code></pre>"},{"location":"user/api/python/#custom-options","title":"Custom Options","text":"<pre><code>import vexy_json\n\n# Parse with specific options\ndata = vexy_json.parse_with_options(\n    'key: value',\n    allow_comments=True,\n    allow_trailing_commas=True,\n    allow_unquoted_keys=True,\n    allow_single_quotes=True,\n    implicit_top_level=True,\n    newline_as_comma=True,\n    max_depth=128\n)\n# Output: {'key': 'value'}\n</code></pre>"},{"location":"user/api/python/#validation","title":"Validation","text":"<pre><code>import vexy_json\n\n# Check if JSON is valid\nif vexy_json.is_valid('{\"valid\": true}'):\n    print(\"Valid JSON!\")\n\nif not vexy_json.is_valid('invalid json'):\n    print(\"Invalid JSON!\")\n</code></pre>"},{"location":"user/api/python/#serialization","title":"Serialization","text":"<pre><code>import vexy_json\n\ndata = {'name': 'Alice', 'age': 30}\n\n# Compact output\njson_str = vexy_json.dumps(data)\nprint(json_str)\n# Output: {\"name\":\"Alice\",\"age\":30}\n\n# Pretty printed output\njson_str = vexy_json.dumps(data, indent=2)\nprint(json_str)\n# Output:\n# {\n#   \"age\": 30,\n#   \"name\": \"Alice\"\n# }\n</code></pre>"},{"location":"user/api/python/#api-reference","title":"API Reference","text":""},{"location":"user/api/python/#functions","title":"Functions","text":""},{"location":"user/api/python/#parseinput-str-any","title":"<code>parse(input: str) -&gt; Any</code>","text":"<p>Parse a JSON string with all forgiving features enabled.</p> <p>Parameters: - <code>input</code> (str): The JSON string to parse</p> <p>Returns: - The parsed JSON as a Python object (dict, list, str, int, float, bool, or None)</p> <p>Raises: - <code>ValueError</code>: If the input is not valid JSON</p>"},{"location":"user/api/python/#parse_with_optionsinput-str-options-any","title":"<code>parse_with_options(input: str, **options) -&gt; Any</code>","text":"<p>Parse a JSON string with custom options.</p> <p>Parameters: - <code>input</code> (str): The JSON string to parse - <code>allow_comments</code> (bool): Allow single-line and multi-line comments (default: True) - <code>allow_trailing_commas</code> (bool): Allow trailing commas (default: True) - <code>allow_unquoted_keys</code> (bool): Allow unquoted object keys (default: True) - <code>allow_single_quotes</code> (bool): Allow single-quoted strings (default: True) - <code>implicit_top_level</code> (bool): Allow implicit top-level objects/arrays (default: True) - <code>newline_as_comma</code> (bool): Treat newlines as commas (default: True) - <code>max_depth</code> (int): Maximum nesting depth (default: 128)</p> <p>Returns: - The parsed JSON as a Python object</p> <p>Raises: - <code>ValueError</code>: If the input is not valid JSON</p>"},{"location":"user/api/python/#is_validinput-str-bool","title":"<code>is_valid(input: str) -&gt; bool</code>","text":"<p>Check if a string is valid JSON/Vexy JSON.</p> <p>Parameters: - <code>input</code> (str): The JSON string to validate</p> <p>Returns: - <code>bool</code>: True if valid, False otherwise</p>"},{"location":"user/api/python/#dumpsobj-any-indent-optionalint-none-str","title":"<code>dumps(obj: Any, indent: Optional[int] = None) -&gt; str</code>","text":"<p>Serialize a Python object to a JSON string.</p> <p>Parameters: - <code>obj</code>: The Python object to serialize - <code>indent</code> (int, optional): Number of spaces for indentation</p> <p>Returns: - <code>str</code>: The JSON string representation</p> <p>Raises: - <code>TypeError</code>: If the object cannot be serialized</p>"},{"location":"user/api/python/#comparison-with-standard-library","title":"Comparison with Standard Library","text":"<p>Unlike Python's built-in <code>json</code> module, vexy_json is forgiving and accepts non-standard JSON:</p> <pre><code>import json\nimport vexy_json\n\nforgiving_json = '''\n{\n    // Comment\n    name: \"Alice\",\n    'age': 30,\n}\n'''\n\n# This will raise an exception\ntry:\n    json.loads(forgiving_json)\nexcept json.JSONDecodeError as e:\n    print(f\"json module failed: {e}\")\n\n# This works fine\nresult = vexy_json.parse(forgiving_json)\nprint(f\"vexy_json parsed: {result}\")\n</code></pre>"},{"location":"user/api/python/#performance","title":"Performance","text":"<p>vexy_json is implemented in Rust and should be competitive with other JSON parsers for most use cases. The forgiving features add minimal overhead.</p>"},{"location":"user/api/python/#license","title":"License","text":"<p>This project is licensed under either of:</p> <ul> <li>Apache License, Version 2.0 (LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0)</li> <li>MIT License (LICENSE-MIT or http://opensource.org/licenses/MIT)</li> </ul> <p>at your option.</p>"},{"location":"user/guides/json-repair/","title":"JSON Repair","text":"<p>Vexy JSON provides advanced JSON repair capabilities that can automatically fix common JSON formatting issues. The repair system uses confidence scoring and multiple strategies to intelligently fix malformed JSON.</p>"},{"location":"user/guides/json-repair/#overview","title":"Overview","text":"<p>The JSON repair system operates on three levels:</p> <ol> <li>Basic Repair: Simple bracket balancing and quote fixing</li> <li>Advanced Repair: Intelligent pattern recognition and multi-strategy fixes</li> <li>Enhanced Repair: Detailed tracking and confidence scoring</li> </ol>"},{"location":"user/guides/json-repair/#basic-repair","title":"Basic Repair","text":""},{"location":"user/guides/json-repair/#simple-usage","title":"Simple Usage","text":"<pre><code>use vexy_json_core::repair::JsonRepairer;\n\nlet mut repairer = JsonRepairer::new(10); // Max 10 repairs\nlet malformed = r#\"{\"key\": \"value\", \"missing\": \"quote}\"#;\n\nmatch repairer.repair(malformed) {\n    Ok((fixed, repairs)) =&gt; {\n        println!(\"Fixed: {}\", fixed);\n        println!(\"Applied {} repairs\", repairs.len());\n    }\n    Err(e) =&gt; println!(\"Repair failed: {}\", e),\n}\n</code></pre>"},{"location":"user/guides/json-repair/#common-repairs","title":"Common Repairs","text":"<p>The basic repairer handles:</p> <ul> <li>Missing quotes: <code>{key: \"value\"}</code> \u2192 <code>{\"key\": \"value\"}</code></li> <li>Bracket imbalances: <code>{\"key\": \"value\"</code> \u2192 <code>{\"key\": \"value\"}</code></li> <li>Trailing commas: <code>{\"key\": \"value\",}</code> \u2192 <code>{\"key\": \"value\"}</code></li> <li>Single quotes: <code>{'key': 'value'}</code> \u2192 <code>{\"key\": \"value\"}</code></li> </ul>"},{"location":"user/guides/json-repair/#advanced-repair","title":"Advanced Repair","text":""},{"location":"user/guides/json-repair/#configuration","title":"Configuration","text":"<pre><code>use vexy_json_core::repair::advanced::{AdvancedJsonRepairer, TypeCoercionRules};\n\nlet mut repairer = AdvancedJsonRepairer::new()\n    .with_confidence_threshold(0.7)\n    .with_type_coercion_rules(TypeCoercionRules {\n        unquote_numbers: true,\n        fix_literals: true,\n        fix_quotes: true,\n        quote_keys: true,\n    });\n\nlet (fixed, strategies) = repairer.repair(input)?;\n</code></pre>"},{"location":"user/guides/json-repair/#repair-strategies","title":"Repair Strategies","text":"<p>The advanced repairer includes multiple strategies:</p>"},{"location":"user/guides/json-repair/#type-coercion","title":"Type Coercion","text":"<pre><code>// Input: {\"count\": \"42\", \"price\": \"19.99\"}\n// Output: {\"count\": 42, \"price\": 19.99}\n\n// Input: {\"flag\": \"true\", \"value\": \"null\"}\n// Output: {\"flag\": true, \"value\": null}\n</code></pre>"},{"location":"user/guides/json-repair/#quote-normalization","title":"Quote Normalization","text":"<pre><code>// Input: {'name': 'John', \"age\": '30'}\n// Output: {\"name\": \"John\", \"age\": \"30\"}\n</code></pre>"},{"location":"user/guides/json-repair/#key-quoting","title":"Key Quoting","text":"<pre><code>// Input: {name: \"John\", age: 30}\n// Output: {\"name\": \"John\", \"age\": 30}\n</code></pre>"},{"location":"user/guides/json-repair/#comma-insertion","title":"Comma Insertion","text":"<pre><code>// Input: {\"a\": 1 \"b\": 2}\n// Output: {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"user/guides/json-repair/#confidence-scoring","title":"Confidence Scoring","text":"<p>Each repair strategy has a confidence score:</p> <pre><code>use vexy_json_core::repair::advanced::RepairConfidence;\n\nlet (fixed, strategies) = repairer.repair(input)?;\n\nfor strategy in strategies {\n    println!(\"Repair: {}\", strategy.action.description);\n    println!(\"Confidence: {:.2}\", strategy.confidence.value());\n\n    if strategy.confidence.is_high() {\n        println!(\"High confidence repair\");\n    }\n}\n</code></pre>"},{"location":"user/guides/json-repair/#preview-mode","title":"Preview Mode","text":"<p>Test repairs without applying them:</p> <pre><code>let mut repairer = AdvancedJsonRepairer::new()\n    .with_preview_mode(true);\n\nlet (original, strategies) = repairer.repair(input)?;\n// original == input (unchanged)\n// strategies contains what would be applied\n</code></pre>"},{"location":"user/guides/json-repair/#enhanced-repair-with-tracking","title":"Enhanced Repair with Tracking","text":""},{"location":"user/guides/json-repair/#detailed-repair-tracking","title":"Detailed Repair Tracking","text":"<pre><code>use vexy_json_core::parser::parse_with_detailed_repair_tracking;\n\nlet result = parse_with_detailed_repair_tracking(input, options)?;\n\nmatch result {\n    EnhancedParseResult::Success { value, tier, repairs } =&gt; {\n        println!(\"Parsed successfully using {:?}\", tier);\n        if !repairs.is_empty() {\n            println!(\"Applied {} repairs:\", repairs.len());\n            for repair in repairs {\n                println!(\"  {}\", repair.description);\n            }\n        }\n    }\n    EnhancedParseResult::Failure { errors, tier, repairs } =&gt; {\n        println!(\"Parse failed at {:?} tier\", tier);\n        for error in errors {\n            println!(\"Error: {}\", error);\n        }\n    }\n}\n</code></pre>"},{"location":"user/guides/json-repair/#three-tier-parsing","title":"Three-Tier Parsing","text":"<p>The enhanced parser uses a three-tier strategy:</p> <ol> <li>Fast Tier: Standard <code>serde_json</code> for maximum performance</li> <li>Forgiving Tier: Vexy JSON parser for non-standard JSON</li> <li>Repair Tier: Automatic repair for malformed JSON</li> </ol> <pre><code>use vexy_json_core::parser::parse_with_fallback;\n\nlet result = parse_with_fallback(input, options);\n// Automatically tries all three tiers\n</code></pre>"},{"location":"user/guides/json-repair/#repair-history-and-analytics","title":"Repair History and Analytics","text":""},{"location":"user/guides/json-repair/#tracking-repair-history","title":"Tracking Repair History","text":"<pre><code>use vexy_json_core::repair::advanced::AdvancedJsonRepairer;\n\nlet mut repairer = AdvancedJsonRepairer::new();\n\n// Perform multiple repairs\nlet _ = repairer.repair(input1)?;\nlet _ = repairer.repair(input2)?;\nlet _ = repairer.repair(input3)?;\n\n// Analyze repair history\nlet history = repairer.history();\nprintln!(\"Total repairs: {}\", history.len());\n\nfor entry in history.entries() {\n    println!(\"Repair at {:?}: {} strategies applied\", \n             entry.timestamp, entry.strategies.len());\n}\n</code></pre>"},{"location":"user/guides/json-repair/#repair-statistics","title":"Repair Statistics","text":"<pre><code>// Get repair statistics\nlet stats = history.statistics();\nprintln!(\"Most common repair: {:?}\", stats.most_common_repair);\nprintln!(\"Average confidence: {:.2}\", stats.average_confidence);\nprintln!(\"Success rate: {:.2}%\", stats.success_rate * 100.0);\n</code></pre>"},{"location":"user/guides/json-repair/#custom-repair-strategies","title":"Custom Repair Strategies","text":""},{"location":"user/guides/json-repair/#implementing-custom-repairs","title":"Implementing Custom Repairs","text":"<pre><code>use vexy_json_core::repair::advanced::{RepairStrategy, RepairAction, RepairType, RepairConfidence};\n\nfn create_custom_repair(input: &amp;str) -&gt; Option&lt;RepairStrategy&gt; {\n    // Custom logic to detect and fix specific issues\n    if input.contains(\"specific_pattern\") {\n        Some(RepairStrategy {\n            action: RepairAction {\n                action_type: RepairType::ReplaceText,\n                position: 0,\n                original: \"specific_pattern\".to_string(),\n                replacement: \"fixed_pattern\".to_string(),\n                description: \"Fixed specific pattern\".to_string(),\n            },\n            confidence: RepairConfidence::new(0.9),\n            alternatives: vec![],\n        })\n    } else {\n        None\n    }\n}\n</code></pre>"},{"location":"user/guides/json-repair/#integration-with-parsing","title":"Integration with Parsing","text":""},{"location":"user/guides/json-repair/#automatic-repair-during-parsing","title":"Automatic Repair During Parsing","text":"<pre><code>use vexy_json_core::{parse_with_options, ParserOptions};\n\nlet options = ParserOptions {\n    enable_repair: true,\n    max_repairs: 50,\n    fast_repair: false,\n    report_repairs: true,\n    ..Default::default()\n};\n\nmatch parse_with_options(input, options) {\n    Ok(value) =&gt; println!(\"Parsed successfully: {:?}\", value),\n    Err(e) =&gt; println!(\"Parse failed: {}\", e),\n}\n</code></pre>"},{"location":"user/guides/json-repair/#repair-first-parsing","title":"Repair-First Parsing","text":"<pre><code>use vexy_json_core::parser::parse_with_fallback;\n\n// Always try repair if normal parsing fails\nlet result = parse_with_fallback(input, options);\n</code></pre>"},{"location":"user/guides/json-repair/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user/guides/json-repair/#fast-vs-thorough-repair","title":"Fast vs. Thorough Repair","text":"<pre><code>// Fast repair (less thorough but faster)\nlet options = ParserOptions {\n    fast_repair: true,\n    ..Default::default()\n};\n\n// Thorough repair (more comprehensive but slower)\nlet options = ParserOptions {\n    fast_repair: false,\n    max_repairs: 100,\n    ..Default::default()\n};\n</code></pre>"},{"location":"user/guides/json-repair/#memory-usage","title":"Memory Usage","text":"<pre><code>// Limit memory usage with cached vs. non-cached repairers\nlet fast_repairer = JsonRepairer::new_without_cache(10);\nlet cached_repairer = JsonRepairer::new(10); // Uses internal cache\n</code></pre>"},{"location":"user/guides/json-repair/#error-handling","title":"Error Handling","text":""},{"location":"user/guides/json-repair/#repair-failures","title":"Repair Failures","text":"<pre><code>use vexy_json_core::repair::JsonRepairer;\n\nlet mut repairer = JsonRepairer::new(5);\nmatch repairer.repair(input) {\n    Ok((fixed, repairs)) =&gt; {\n        println!(\"Successfully applied {} repairs\", repairs.len());\n    }\n    Err(repair_error) =&gt; {\n        match repair_error {\n            RepairError::TooManyRepairs =&gt; {\n                println!(\"Too many repairs needed\");\n            }\n            RepairError::UnrepairableInput =&gt; {\n                println!(\"Input cannot be repaired\");\n            }\n            RepairError::InvalidInput(msg) =&gt; {\n                println!(\"Invalid input: {}\", msg);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"user/guides/json-repair/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>fn parse_with_graceful_degradation(input: &amp;str) -&gt; Result&lt;Value, String&gt; {\n    // Try standard parsing first\n    if let Ok(value) = parse(input) {\n        return Ok(value);\n    }\n\n    // Try repair\n    let mut repairer = JsonRepairer::new(10);\n    if let Ok((fixed, _)) = repairer.repair(input) {\n        if let Ok(value) = parse(&amp;fixed) {\n            return Ok(value);\n        }\n    }\n\n    // Fall back to partial parsing or error\n    Err(\"Could not parse or repair JSON\".to_string())\n}\n</code></pre>"},{"location":"user/guides/json-repair/#best-practices","title":"Best Practices","text":""},{"location":"user/guides/json-repair/#when-to-use-repair","title":"When to Use Repair","text":"<ol> <li>User Input: When parsing user-provided JSON</li> <li>Legacy Data: When working with old or non-standard JSON</li> <li>Data Migration: When converting between JSON formats</li> <li>API Integration: When consuming APIs with inconsistent JSON</li> </ol>"},{"location":"user/guides/json-repair/#configuration-guidelines","title":"Configuration Guidelines","text":"<pre><code>// For user input (be forgiving)\nlet user_input_repairer = AdvancedJsonRepairer::new()\n    .with_confidence_threshold(0.5)  // Lower threshold\n    .with_type_coercion_rules(TypeCoercionRules {\n        unquote_numbers: true,\n        fix_literals: true,\n        fix_quotes: true,\n        quote_keys: true,\n    });\n\n// For critical data (be strict)\nlet critical_repairer = AdvancedJsonRepairer::new()\n    .with_confidence_threshold(0.9)  // Higher threshold\n    .with_preview_mode(true);        // Review before applying\n</code></pre>"},{"location":"user/guides/json-repair/#testing-repair-logic","title":"Testing Repair Logic","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_repair_confidence() {\n        let mut repairer = AdvancedJsonRepairer::new();\n        let (fixed, strategies) = repairer.repair(r#\"{\"key\": \"value\",}\"#).unwrap();\n\n        assert_eq!(fixed, r#\"{\"key\": \"value\"}\"#);\n        assert!(!strategies.is_empty());\n        assert!(strategies[0].confidence.is_high());\n    }\n}\n</code></pre> <p>The JSON repair system provides powerful tools for handling malformed JSON while maintaining safety and providing visibility into what changes were made.</p>"},{"location":"user/guides/migration/","title":"Migration Guide: vexy_json v2.0.0","text":"<p>This document provides comprehensive guidance for upgrading to vexy_json v2.0.0 from previous versions.</p>"},{"location":"user/guides/migration/#migrating-from-v1x-to-v200","title":"Migrating from v1.x to v2.0.0","text":""},{"location":"user/guides/migration/#overview","title":"Overview","text":"<p>Version 2.0.0 is a major release that introduces powerful new features while maintaining backward compatibility for most existing code. The core parsing API remains unchanged, but new APIs have been added for streaming, parallel processing, and plugins.</p>"},{"location":"user/guides/migration/#backward-compatible-changes","title":"\u2705 Backward Compatible Changes","text":"<p>The following APIs work exactly as before: - <code>parse(input: &amp;str) -&gt; Result&lt;Value&gt;</code> - <code>parse_with_options(input: &amp;str, options: ParserOptions) -&gt; Result&lt;Value&gt;</code> - All <code>Value</code> enum methods and traits - All <code>ParserOptions</code> fields - CLI basic functionality</p>"},{"location":"user/guides/migration/#new-features-to-adopt","title":"\ud83d\ude80 New Features to Adopt","text":""},{"location":"user/guides/migration/#streaming-api","title":"Streaming API","text":"<p>If you're parsing large files, consider migrating to the streaming API:</p> <p>Before (v1.x): <pre><code>let large_json = std::fs::read_to_string(\"huge.json\")?;\nlet value = parse(&amp;large_json)?; // Uses lots of memory\n</code></pre></p> <p>After (v2.0.0): <pre><code>use vexy_json::StreamingParser;\n\nlet mut parser = StreamingParser::new();\nlet file = std::fs::File::open(\"huge.json\")?;\nlet reader = std::io::BufReader::new(file);\n\nfor line in reader.lines() {\n    parser.feed(&amp;line?)?;\n}\nparser.finish()?;\n\n// Process events incrementally\nwhile let Some(event) = parser.next_event()? {\n    // Handle events with minimal memory usage\n}\n</code></pre></p>"},{"location":"user/guides/migration/#parallel-processing","title":"Parallel Processing","text":"<p>For batch operations, use the new parallel API:</p> <p>Before (v1.x): <pre><code>let mut results = Vec::new();\nfor json in json_files {\n    results.push(parse(&amp;json));\n}\n</code></pre></p> <p>After (v2.0.0): <pre><code>use vexy_json::parse_parallel;\n\nlet results = parse_parallel(json_files); // Automatically uses multiple cores\n</code></pre></p>"},{"location":"user/guides/migration/#minor-breaking-changes","title":"\u26a0\ufe0f Minor Breaking Changes","text":"<ol> <li>Error Enum Reorganization</li> <li>Some error variants have been renamed for clarity</li> <li> <p>Add explicit imports if you match on specific error types:    <pre><code>use vexy_json::Error::{UnexpectedChar, InvalidNumber};\n</code></pre></p> </li> <li> <p>Feature Flags</p> </li> <li><code>wasm-bindgen</code> feature renamed to <code>wasm</code></li> <li> <p><code>full</code> feature now includes streaming and parallel features</p> </li> <li> <p>WASM JavaScript API</p> </li> <li>Now uses consistent camelCase:</li> <li><code>parse_json</code> \u2192 <code>parseJson</code></li> <li><code>parse_json_with_options</code> \u2192 <code>parseJsonWithOptions</code></li> </ol>"},{"location":"user/guides/migration/#dependency-updates","title":"\ud83d\udce6 Dependency Updates","text":"<p>If you depend on specific versions of vexy_json's dependencies: - <code>serde</code>: Now requires 1.0.190+ - <code>wasm-bindgen</code>: Updated to 0.2.90 - New dependencies: <code>rayon</code>, <code>crossbeam-channel</code>, <code>simd-json</code></p>"},{"location":"user/guides/migration/#cli-changes","title":"\ud83d\udd27 CLI Changes","text":"<p>The CLI has been significantly enhanced. Update scripts that use vexy_json:</p> <p>New capabilities: <pre><code># Watch mode\nvexy_json --watch input.json -o output.json\n\n# Batch processing\nvexy_json --batch ./data/ --output-dir ./processed/\n\n# Pretty printing with options\nvexy_json --pretty --sort-keys --indent 4 input.json\n</code></pre></p>"},{"location":"user/guides/migration/#migration-guide-vexy_json-v020","title":"Migration Guide: vexy_json v0.2.0","text":"<p>This section covers the earlier v0.2.0 refactor for historical reference.</p>"},{"location":"user/guides/migration/#summary","title":"Summary","text":"<p>The refactor focused on internal improvements while maintaining full backward compatibility for the public API. Most users should be able to upgrade without any code changes.</p>"},{"location":"user/guides/migration/#no-breaking-changes","title":"\u2705 No Breaking Changes","text":"<p>The following public APIs remain unchanged and fully compatible:</p> <ul> <li><code>parse(input: &amp;str) -&gt; Result&lt;Value&gt;</code></li> <li><code>parse_with_options(input: &amp;str, options: ParserOptions) -&gt; Result&lt;Value&gt;</code></li> <li><code>ParserOptions</code> struct and all its fields</li> <li><code>Value</code> enum and all its variants</li> <li><code>Error</code> enum and existing error types</li> <li>WASM bindings and JavaScript API</li> </ul>"},{"location":"user/guides/migration/#new-features-added","title":"\u2728 New Features Added","text":""},{"location":"user/guides/migration/#enhanced-error-handling","title":"Enhanced Error Handling","text":"<p>New exports available: <pre><code>use vexy_json::{ParseResult, Error};\n\n// New type alias for semantic clarity\nfn parse_config() -&gt; ParseResult&lt;Config&gt; {\n    // ParseResult&lt;T&gt; is equivalent to Result&lt;T, Error&gt;\n    // but provides semantic clarity for parsing operations\n}\n\n// Enhanced error context (automatically available)\nmatch parse(input) {\n    Err(error) =&gt; {\n        // New error methods available\n        if error.is_string_error() { /* handle string errors */ }\n        if error.is_number_error() { /* handle number errors */ }\n        if error.is_structural_error() { /* handle syntax errors */ }\n    }\n}\n</code></pre></p>"},{"location":"user/guides/migration/#enhanced-wasm-api","title":"Enhanced WASM API","text":"<p>New JavaScript functions: <pre><code>// Enhanced error objects with more information\ntry {\n    const result = vexy_json.parse_json(input);\n} catch (error) {\n    console.log(error.message);        // Error description\n    console.log(error.position);       // Character position (if available)\n    console.log(error.isStringError);  // Error categorization\n    console.log(error.isNumberError);\n    console.log(error.isStructuralError);\n}\n</code></pre></p>"},{"location":"user/guides/migration/#internal-improvements","title":"\ud83d\udd27 Internal Improvements","text":"<p>The following improvements enhance performance and maintainability without affecting the public API:</p>"},{"location":"user/guides/migration/#architecture","title":"Architecture","text":"<ul> <li>Modular error system: Enhanced error types with source chain support</li> <li>Property-based testing: Comprehensive test coverage with <code>proptest</code></li> <li>Better WASM integration: Enhanced JavaScript error objects</li> </ul>"},{"location":"user/guides/migration/#performance","title":"Performance","text":"<ul> <li>Optimized WASM bindings: Latest wasm-bindgen with smaller bundle size</li> <li>Enhanced CI/CD: Multi-toolchain testing and security audits</li> </ul>"},{"location":"user/guides/migration/#development-experience","title":"Development Experience","text":"<ul> <li>Enhanced error messages: More precise error positioning and context</li> <li>Better documentation: Comprehensive API docs and examples</li> <li>Improved CI/CD: Enhanced testing matrix and security audits</li> </ul>"},{"location":"user/guides/migration/#recommended-usage-patterns","title":"\ud83d\udcda Recommended Usage Patterns","text":""},{"location":"user/guides/migration/#for-rust-users","title":"For Rust Users","text":"<pre><code>use vexy_json::{parse, ParseResult, ParserOptions};\n\n// Recommended: Use the new ParseResult type for clarity\nfn parse_config_file(content: &amp;str) -&gt; ParseResult&lt;Config&gt; {\n    let options = ParserOptions::default(); // All forgiving features enabled\n    let value = parse_with_options(content, options)?;\n    // Convert value to your config struct...\n    Ok(config)\n}\n\n// Error handling with enhanced categorization\nmatch parse(input) {\n    Ok(value) =&gt; println!(\"Parsed: {}\", value),\n    Err(error) =&gt; {\n        if error.is_string_error() {\n            eprintln!(\"String parsing error at position {:?}: {}\", \n                     error.position(), error);\n        } else {\n            eprintln!(\"Parse error: {}\", error);\n        }\n    }\n}\n</code></pre>"},{"location":"user/guides/migration/#for-javascript-users","title":"For JavaScript Users","text":"<pre><code>// Enhanced error handling with structured error objects\ntry {\n    const result = vexy_json.parse_json(jsonString);\n    console.log('Parsed:', result);\n} catch (error) {\n    console.error(`Parse error at position ${error.position}: ${error.message}`);\n\n    // Enhanced error categorization\n    if (error.isStringError) {\n        console.log('This is a string-related parsing error');\n    }\n}\n</code></pre>"},{"location":"user/guides/migration/#future-compatibility","title":"\ud83d\ude80 Future Compatibility","text":"<p>This refactor establishes a solid foundation for future enhancements:</p> <ul> <li>Enhanced error reporting: Better error context and source chains</li> <li>Modular architecture: Clean separation enables targeted optimizations</li> <li>Comprehensive testing: Property-based tests ensure robust behavior</li> <li>Security auditing: Automated dependency and security checks</li> </ul>"},{"location":"user/guides/migration/#support","title":"\ud83d\udcde Support","text":"<p>If you encounter any issues during migration:</p> <ol> <li>Check compatibility: Ensure you're not using any undocumented internal APIs</li> <li>Update imports: Make sure you're importing from the main <code>vexy_json</code> crate</li> <li>Test thoroughly: Run your existing test suite to verify behavior</li> <li>Report issues: File bug reports with specific reproduction cases</li> </ol>"},{"location":"user/guides/migration/#benefits-summary","title":"\ud83d\udcc8 Benefits Summary","text":"<p>After migration, you'll benefit from:</p> <ul> <li>\u2705 Same API: No code changes required for most users</li> <li>\u2705 Better errors: More precise error reporting and categorization  </li> <li>\u2705 Enhanced WASM: Better JavaScript integration with structured errors</li> <li>\u2705 Improved performance: Optimized internal architecture</li> <li>\u2705 Future-proof: Foundation for upcoming features and optimizations</li> </ul> <p>The refactor maintains the reliability you expect while providing a foundation for continued improvements.</p>"},{"location":"user/guides/transform/","title":"JSON Transformation","text":"<p>The Vexy JSON library provides powerful JSON transformation capabilities through its <code>transform</code> module. This module includes JSON normalization and AST optimization features.</p>"},{"location":"user/guides/transform/#json-normalization","title":"JSON Normalization","text":"<p>The JSON normalizer provides standardized JSON formatting with various normalization options.</p>"},{"location":"user/guides/transform/#basic-usage","title":"Basic Usage","text":"<pre><code>use vexy_json_core::transform::{normalize, normalize_with_options, NormalizerOptions};\n\n// Basic normalization with default options\nlet json = r#\"{\"b\": 2, \"a\": 1, \"c\": null}\"#;\nlet normalized = normalize(json).unwrap();\n// Result: {\"a\": 1, \"b\": 2, \"c\": null}\n\n// Custom normalization options\nlet options = NormalizerOptions {\n    sort_keys: true,\n    remove_null_values: true,\n    remove_empty_containers: true,\n    ..Default::default()\n};\nlet normalized = normalize_with_options(json, options).unwrap();\n// Result: {\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"user/guides/transform/#normalization-options","title":"Normalization Options","text":"<p>The <code>NormalizerOptions</code> struct provides fine-grained control over normalization:</p> <ul> <li><code>sort_keys</code>: Sort object keys alphabetically</li> <li><code>remove_null_values</code>: Remove null values from objects</li> <li><code>remove_empty_containers</code>: Remove empty objects and arrays</li> <li><code>normalize_numbers</code>: Convert floats to integers when possible</li> <li><code>prefer_integers</code>: Prefer integer representation for whole numbers</li> <li><code>trim_strings</code>: Trim whitespace from string values</li> <li><code>normalize_string_case</code>: Convert strings to lowercase</li> <li><code>deduplicate_arrays</code>: Remove duplicate values from arrays</li> <li><code>max_depth</code>: Maximum recursion depth for nested structures</li> </ul>"},{"location":"user/guides/transform/#specialized-normalizers","title":"Specialized Normalizers","text":""},{"location":"user/guides/transform/#canonical-normalizer","title":"Canonical Normalizer","text":"<p>Produces deterministic JSON output suitable for hashing and comparison:</p> <pre><code>use vexy_json_core::transform::CanonicalNormalizer;\n\nlet normalizer = CanonicalNormalizer::new();\nlet canonical = normalizer.normalize(json).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#cleanup-normalizer","title":"Cleanup Normalizer","text":"<p>Removes unnecessary elements and optimizes for size:</p> <pre><code>use vexy_json_core::transform::CleanupNormalizer;\n\nlet normalizer = CleanupNormalizer::new();\nlet cleaned = normalizer.normalize(json).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#ast-optimization","title":"AST Optimization","text":"<p>The AST optimizer improves JSON structure performance through various optimization techniques.</p>"},{"location":"user/guides/transform/#basic-usage_1","title":"Basic Usage","text":"<pre><code>use vexy_json_core::transform::{optimize, optimize_with_options, OptimizerOptions};\n\n// Basic optimization with default options\nlet json = r#\"{\"count\": 42.0, \"items\": [1, 2, 3]}\"#;\nlet optimized = optimize(&amp;json).unwrap();\n// Numbers are optimized, strings may be interned\n\n// Custom optimization options\nlet options = OptimizerOptions {\n    intern_strings: true,\n    min_intern_length: 5,\n    min_intern_count: 2,\n    optimize_numbers: true,\n    remove_empty_containers: true,\n    ..Default::default()\n};\nlet optimized = optimize_with_options(&amp;json, options).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#optimization-features","title":"Optimization Features","text":""},{"location":"user/guides/transform/#string-interning","title":"String Interning","text":"<p>Reduces memory usage by deduplicating repeated strings:</p> <pre><code>let options = OptimizerOptions {\n    intern_strings: true,\n    min_intern_length: 10,    // Only intern strings &gt;= 10 chars\n    min_intern_count: 3,      // Only intern strings appearing &gt;= 3 times\n    ..Default::default()\n};\n</code></pre>"},{"location":"user/guides/transform/#number-optimization","title":"Number Optimization","text":"<p>Converts floats to integers when possible:</p> <pre><code>// Input: {\"price\": 19.0, \"count\": 42.5}\n// Output: {\"price\": 19, \"count\": 42.5}\n</code></pre>"},{"location":"user/guides/transform/#container-optimization","title":"Container Optimization","text":"<p>Optimizes small objects and arrays:</p> <pre><code>let options = OptimizerOptions {\n    optimize_small_objects: true,\n    max_small_object_size: 4,\n    collapse_single_arrays: true,\n    remove_empty_containers: true,\n    ..Default::default()\n};\n</code></pre>"},{"location":"user/guides/transform/#specialized-optimizers","title":"Specialized Optimizers","text":""},{"location":"user/guides/transform/#memory-optimizer","title":"Memory Optimizer","text":"<p>Optimizes for minimal memory usage:</p> <pre><code>use vexy_json_core::transform::MemoryOptimizer;\n\nlet optimized = MemoryOptimizer::minimize_memory(&amp;json).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#performance-optimizer","title":"Performance Optimizer","text":"<p>Optimizes for maximum performance:</p> <pre><code>use vexy_json_core::transform::PerformanceOptimizer;\n\nlet optimized = PerformanceOptimizer::maximize_performance(&amp;json).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#optimization-statistics","title":"Optimization Statistics","text":"<p>Track optimization effectiveness:</p> <pre><code>use vexy_json_core::transform::AstOptimizer;\n\nlet mut optimizer = AstOptimizer::new();\nlet optimized = optimizer.optimize(&amp;json).unwrap();\nlet stats = optimizer.stats();\n\nprintln!(\"Interned strings: {}\", stats.interner_stats.interned_strings);\nprintln!(\"Saved bytes: {}\", stats.interner_stats.saved_bytes);\n</code></pre>"},{"location":"user/guides/transform/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user/guides/transform/#chaining-transformations","title":"Chaining Transformations","text":"<p>Combine normalization and optimization:</p> <pre><code>use vexy_json_core::{parse, transform::{normalize, optimize}};\n\nlet json = r#\"{\"z\": 1.0, \"a\": 2.0, \"b\": null}\"#;\nlet value = parse(json).unwrap();\nlet normalized = normalize(&amp;value).unwrap();\nlet optimized = optimize(&amp;normalized).unwrap();\n</code></pre>"},{"location":"user/guides/transform/#custom-transformation-pipeline","title":"Custom Transformation Pipeline","text":"<p>Create custom transformation pipelines:</p> <pre><code>use vexy_json_core::transform::{NormalizerOptions, OptimizerOptions};\n\nfn custom_transform(json: &amp;str) -&gt; Result&lt;String, Error&gt; {\n    // First normalize\n    let norm_options = NormalizerOptions {\n        sort_keys: true,\n        remove_null_values: true,\n        ..Default::default()\n    };\n    let normalized = normalize_with_options(json, norm_options)?;\n\n    // Then optimize\n    let opt_options = OptimizerOptions {\n        intern_strings: true,\n        optimize_numbers: true,\n        ..Default::default()\n    };\n    let optimized = optimize_with_options(&amp;normalized, opt_options)?;\n\n    Ok(optimized.to_string())\n}\n</code></pre>"},{"location":"user/guides/transform/#performance-considerations","title":"Performance Considerations","text":""},{"location":"user/guides/transform/#when-to-use-normalization","title":"When to Use Normalization","text":"<ul> <li>Data deduplication: When you need consistent JSON formatting</li> <li>Comparison: When comparing JSON structures</li> <li>Storage: When minimizing storage space</li> <li>Hashing: When creating content hashes</li> </ul>"},{"location":"user/guides/transform/#when-to-use-optimization","title":"When to Use Optimization","text":"<ul> <li>Memory-constrained environments: Use MemoryOptimizer</li> <li>Performance-critical applications: Use PerformanceOptimizer</li> <li>Large JSON datasets: String interning provides significant benefits</li> <li>Repeated processing: Optimization overhead pays off over time</li> </ul>"},{"location":"user/guides/transform/#best-practices","title":"Best Practices","text":"<ol> <li>Profile before optimizing: Measure actual performance impact</li> <li>Choose appropriate options: Not all optimizations help every use case</li> <li>Consider trade-offs: Memory savings vs. processing time</li> <li>Test thoroughly: Ensure optimizations don't change semantics</li> </ol>"},{"location":"user/guides/transform/#error-handling","title":"Error Handling","text":"<p>Both normalization and optimization can fail:</p> <pre><code>use vexy_json_core::transform::normalize;\n\nmatch normalize(json) {\n    Ok(normalized) =&gt; println!(\"Success: {}\", normalized),\n    Err(e) =&gt; eprintln!(\"Normalization failed: {}\", e),\n}\n</code></pre> <p>Common error scenarios: - Invalid JSON input - Circular references (when max_depth is exceeded) - Memory allocation failures - Serialization errors</p>"},{"location":"user/guides/transform/#integration-with-other-features","title":"Integration with Other Features","text":""},{"location":"user/guides/transform/#with-parsing","title":"With Parsing","text":"<pre><code>use vexy_json_core::{parse_with_options, transform::normalize, ParserOptions};\n\nlet options = ParserOptions {\n    allow_comments: true,\n    allow_trailing_commas: true,\n    ..Default::default()\n};\n\nlet parsed = parse_with_options(json, options)?;\nlet normalized = normalize(&amp;parsed)?;\n</code></pre>"},{"location":"user/guides/transform/#with-streaming","title":"With Streaming","text":"<pre><code>use vexy_json_core::{streaming::parse_streaming, transform::optimize};\n\nfor value in parse_streaming(reader)? {\n    let optimized = optimize(&amp;value?)?;\n    // Process optimized value\n}\n</code></pre> <p>This transformation system provides powerful tools for JSON processing while maintaining the flexibility and performance that Vexy JSON is known for.</p>"},{"location":"user/guides/troubleshooting/","title":"Troubleshooting","text":"<p>This page documents common issues and their solutions when using vexy_json, particularly with WebAssembly bindings.</p>"},{"location":"user/guides/troubleshooting/#webassembly-issues","title":"WebAssembly Issues","text":""},{"location":"user/guides/troubleshooting/#objects-parsing-to-empty-results","title":"Objects Parsing to Empty Results","text":"<p>Issue: Parsed JSON objects appear empty (<code>{}</code>) even when the input contains valid data like <code>{a:1}</code> or <code>{\"a\":1}</code>.</p> <p>Symptoms: - <code>Object.keys(result)</code> returns an empty array - <code>JSON.stringify(result)</code> returns <code>\"{}\"</code> - Property access on parsed objects returns <code>undefined</code> - Browser console shows results as <code>Map(1)</code> instead of plain objects</p> <p>Root Cause: This was a critical bug in versions prior to 1.2.4 where the WebAssembly bindings used <code>serde_wasm_bindgen::to_value()</code> which converted Rust <code>HashMap</code> objects to JavaScript <code>Map</code> objects instead of plain JavaScript objects.</p> <p>Solution:  - Fixed in version 1.2.4: The WebAssembly bindings now use a custom <code>value_to_js()</code> function that creates proper JavaScript objects - If using an older version: Upgrade to version 1.2.4 or later</p> <p>Technical Details: The fix involved replacing the automatic serde conversion with manual object creation:</p> <pre><code>// Before (problematic):\nserde_wasm_bindgen::to_value(&amp;value)\n\n// After (fixed):\nvalue_to_js(&amp;value) // Custom function using js_sys::Object\n</code></pre>"},{"location":"user/guides/troubleshooting/#browser-caching-of-wasm-modules","title":"Browser Caching of WASM Modules","text":"<p>Issue: Changes to the WASM module are not reflected in the browser even after rebuilding.</p> <p>Solution: 1. Hard refresh your browser (Ctrl+Shift+R or Cmd+Shift+R) 2. Clear browser cache 3. Add cache-busting query parameters to module imports:    <pre><code>import init from './pkg/vexy_json_wasm.js?v=' + Date.now();\n</code></pre></p>"},{"location":"user/guides/troubleshooting/#wasm-module-loading-failures","title":"WASM Module Loading Failures","text":"<p>Issue: WebAssembly module fails to load with network errors.</p> <p>Common Causes &amp; Solutions:</p> <ol> <li>Incorrect MIME type: Ensure your web server serves <code>.wasm</code> files with <code>application/wasm</code> MIME type</li> <li>CORS issues: Serve files from a proper HTTP server, not file:// protocol</li> <li>Path issues: Verify the path to <code>pkg/vexy_json_wasm.js</code> and <code>pkg/vexy_json_bg.wasm</code> is correct</li> </ol> <p>Testing Setup: Use a simple HTTP server for testing: <pre><code># Python 3\npython -m http.server 8080\n\n# Node.js (with http-server package)\nnpx http-server -p 8080\n\n# Rust (with basic-http-server)\ncargo install basic-http-server\nbasic-http-server docs/ -a 127.0.0.1:8080\n</code></pre></p>"},{"location":"user/guides/troubleshooting/#parser-issues","title":"Parser Issues","text":""},{"location":"user/guides/troubleshooting/#unquoted-keys-not-working","title":"Unquoted Keys Not Working","text":"<p>Issue: JSON with unquoted keys like <code>{key: \"value\"}</code> fails to parse.</p> <p>Solution: Ensure <code>allow_unquoted_keys</code> is enabled in parser options:</p> <pre><code>const options = {\n  allow_unquoted_keys: true,\n  // ... other options\n};\nconst result = parse_json_with_options(input, options);\n</code></pre>"},{"location":"user/guides/troubleshooting/#comments-causing-parse-errors","title":"Comments Causing Parse Errors","text":"<p>Issue: JSON with comments like <code>// comment</code> or <code>/* comment */</code> fails to parse.</p> <p>Solution: Enable comment support in parser options:</p> <pre><code>const options = {\n  allow_comments: true,\n  // ... other options\n};\nconst result = parse_json_with_options(input, options);\n</code></pre>"},{"location":"user/guides/troubleshooting/#debug-tools","title":"Debug Tools","text":""},{"location":"user/guides/troubleshooting/#browser-console-debugging","title":"Browser Console Debugging","text":"<p>Enable debug logging by using the debug builds of the WebAssembly module. Debug messages will appear in the browser console showing:</p> <ul> <li>Token parsing progress</li> <li>Value conversion steps  </li> <li>Object creation details</li> </ul>"},{"location":"user/guides/troubleshooting/#test-pages","title":"Test Pages","text":"<p>The following test pages are available for debugging:</p> <ul> <li><code>error-debug.html</code> - Error handling and basic parsing tests</li> <li><code>console-debug.html</code> - Console output capture and display</li> <li><code>token-debug.html</code> - Token-level parsing analysis</li> <li><code>deep-debug.html</code> - Comprehensive parsing verification</li> </ul>"},{"location":"user/guides/troubleshooting/#manual-testing","title":"Manual Testing","text":"<p>Test parsing functionality manually:</p> <pre><code>// Test basic object parsing\nconst result1 = parse_json('{\"a\": 1}');\nconsole.log('Quoted keys:', result1);\n\n// Test unquoted keys (requires options)\nconst options = { allow_unquoted_keys: true };\nconst result2 = parse_json_with_options('{a: 1}', options);\nconsole.log('Unquoted keys:', result2);\n\n// Verify object properties\nconsole.log('Keys:', Object.keys(result2));\nconsole.log('JSON:', JSON.stringify(result2));\n</code></pre>"},{"location":"user/guides/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered here:</p> <ol> <li>Check the GitHub Issues</li> <li>Review the API documentation</li> <li>Examine the test files for usage examples</li> <li>Create a new issue with:</li> <li>Your vexy_json version</li> <li>Browser and version</li> <li>Minimal reproduction case</li> <li>Expected vs actual behavior</li> </ol>"},{"location":"user/reference/release-notes/","title":"vexy_json v2.0.0 Release Notes","text":"<p>\ud83d\ude80 Major Release - January 2025</p> <p>We're thrilled to announce vexy_json v2.0.0, a groundbreaking release that transforms vexy_json from a capable JSON parser into a high-performance, enterprise-ready parsing platform. This release introduces streaming APIs, parallel processing, a plugin architecture, and significant performance improvements.</p>"},{"location":"user/reference/release-notes/#highlights","title":"\ud83c\udf1f Highlights","text":"<ul> <li>Streaming Parser: Process gigabyte-sized JSON files with minimal memory usage</li> <li>Parallel Processing: Multi-threaded parsing with intelligent chunk boundaries</li> <li>Plugin Architecture: Extensible framework for custom transformations and validators</li> <li>SIMD Optimization: 2-3x performance improvements for string scanning</li> <li>Memory Pool V3: 80% reduction in allocations with typed arenas</li> <li>Enhanced CLI: Watch mode, batch processing, and advanced formatting</li> <li>NDJSON Support: Native support for newline-delimited JSON streams</li> <li>Error Recovery V2: ML-based pattern recognition with actionable suggestions</li> </ul>"},{"location":"user/reference/release-notes/#vexy_json-v100-release-notes","title":"vexy_json v1.0.0 Release Notes","text":"<p>\ud83d\ude80 Stable Release - January 7, 2025</p> <p>We're excited to announce the stable release of vexy_json v1.0.0, a production-ready forgiving JSON parser for Rust. This is a complete port of the JavaScript library the reference implementation, bringing powerful and flexible JSON parsing capabilities to the Rust ecosystem.</p>"},{"location":"user/reference/release-notes/#what-is-vexy_json","title":"\ud83c\udf89 What is vexy_json?","text":"<p>vexy_json is a forgiving JSON parser that extends standard JSON with developer-friendly features while maintaining full compatibility with RFC 8259. It allows you to parse relaxed JSON syntax commonly found in configuration files, making JSON more human-readable and maintainable.</p>"},{"location":"user/reference/release-notes/#key-features","title":"\u2728 Key Features","text":""},{"location":"user/reference/release-notes/#forgiving-json-parsing-1010-features-complete","title":"\ud83d\udd27 Forgiving JSON Parsing (10/10 Features Complete)","text":"<ul> <li>Comments: Single-line (<code>//</code>, <code>#</code>) and multi-line (<code>/* */</code>) comments</li> <li>Flexible Strings: Both single (<code>'</code>) and double (<code>\"</code>) quoted strings</li> <li>Unquoted Keys: Object keys without quotes (<code>{key: value}</code>)</li> <li>Trailing Commas: Allow trailing commas in arrays and objects</li> <li>Implicit Structures: Top-level objects and arrays without brackets</li> <li>Flexible Numbers: Leading/trailing dots, explicit <code>+</code> signs</li> <li>Advanced Parsing: Consecutive commas, leading commas, mixed syntax</li> </ul>"},{"location":"user/reference/release-notes/#production-ready-quality","title":"\ud83d\ude80 Production-Ready Quality","text":"<ul> <li>100% Test Coverage: All 73 tests passing across 8 test suites</li> <li>Zero Warnings: Clean compilation with zero compiler/clippy warnings</li> <li>Performance Optimized: Sub-millisecond parsing for typical use cases</li> <li>Memory Efficient: Zero-copy parsing where possible</li> <li>Error Recovery: Detailed error messages with position information</li> </ul>"},{"location":"user/reference/release-notes/#comprehensive-integration","title":"\ud83d\udd17 Comprehensive Integration","text":"<ul> <li>Serde Support: Full serialization/deserialization integration</li> <li>CLI Tool: Command-line JSON processor for shell workflows</li> <li>Dual APIs: High-level convenience and low-level control</li> <li>Rust Idiomatic: Leverages Result types, pattern matching, and traits</li> </ul>"},{"location":"user/reference/release-notes/#installation","title":"\ud83d\udce6 Installation","text":""},{"location":"user/reference/release-notes/#library-usage","title":"Library Usage","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nvexy_json = \"1.0.0\"\n</code></pre>"},{"location":"user/reference/release-notes/#cli-tool","title":"CLI Tool","text":"<pre><code>cargo install vexy_json\n</code></pre>"},{"location":"user/reference/release-notes/#usage-examples","title":"\ud83c\udfaf Usage Examples","text":""},{"location":"user/reference/release-notes/#basic-library-usage","title":"Basic Library Usage","text":"<pre><code>use vexy_json::parse;\n\n// Standard JSON\nlet data = parse(r#\"{\"name\": \"Alice\", \"age\": 30}\"#)?;\n\n// Forgiving JSON with comments and unquoted keys\nlet config = parse(r#\"{\n    // Application configuration\n    server_port: 8080,\n    database: {\n        host: 'localhost',\n        timeout: 30,  // trailing comma OK\n    }\n}\"#)?;\n\n// Implicit top-level structures\nlet object = parse(\"name: 'Alice', age: 30\")?;\n// \u2192 {\"name\": \"Alice\", \"age\": 30}\n\nlet array = parse(\"'red', 'green', 'blue'\")?;\n// \u2192 [\"red\", \"green\", \"blue\"]\n</code></pre>"},{"location":"user/reference/release-notes/#cli-tool-usage","title":"CLI Tool Usage","text":"<pre><code># Process configuration files\necho \"{debug: true, port: 3000}\" | vexy_json\n# Output: {\"debug\":true,\"port\":3000}\n\n# Handle files with comments\ncat config.jsonc | vexy_json &gt; config.json\n\n# Pipeline integration\ncurl api.example.com/config | vexy_json | jq '.database'\n</code></pre>"},{"location":"user/reference/release-notes/#serde-integration","title":"Serde Integration","text":"<pre><code>use vexy_json::from_str;\nuse serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct Config {\n    host: String,\n    port: u16,\n}\n\nlet config: Config = from_str(\"host: 'localhost', port: 8080\")?;\n</code></pre>"},{"location":"user/reference/release-notes/#performance-characteristics","title":"\ud83d\udcca Performance Characteristics","text":"<p>Based on comprehensive benchmark testing:</p> <ul> <li>Core JSON Parsing: 11.5\u00b5s - 4.7ms (simple objects to 1000-element arrays)</li> <li>Forgiving Features: 6.7\u00b5s - 23.6\u00b5s overhead (20-40% vs strict mode)</li> <li>Real-world Scenarios: 81.5\u00b5s - 357.5\u00b5s for complex nested structures</li> <li>Linear Scaling: O(n) performance characteristics validated</li> <li>Production Suitable: Sub-millisecond performance for typical use cases</li> </ul>"},{"location":"user/reference/release-notes/#test-coverage-quality-metrics","title":"\ud83e\uddea Test Coverage &amp; Quality Metrics","text":"<p>Complete Test Suite Results (73/73 Passing):</p> <ul> <li>\u2705 Unit tests: 2/2 passing</li> <li>\u2705 Basic tests: 7/7 passing</li> <li>\u2705 Forgiving features: 10/10 passing</li> <li>\u2705 Jsonic compatibility: 17/17 passing</li> <li>\u2705 Newline-as-comma: 8/8 passing</li> <li>\u2705 Number formats: 8/8 passing</li> <li>\u2705 Supported the reference implementation: 17/17 passing</li> <li>\u2705 Doc tests: 4/4 passing</li> </ul> <p>Quality Standards:</p> <ul> <li>Zero compiler warnings</li> <li>Zero clippy warnings</li> <li>Clean build with exit code 0</li> <li>Comprehensive error handling</li> <li>Full rustdoc documentation</li> </ul>"},{"location":"user/reference/release-notes/#the-reference-implementation-compatibility","title":"\ud83d\udd04 the reference implementation Compatibility","text":"<p>vexy_json achieves complete compatibility with the the reference implementation JavaScript library:</p> <ul> <li>All 17 the reference implementation compatibility tests pass</li> <li>Identical parsing behavior for all supported features</li> <li>Same error handling and edge case behavior</li> <li>Seamless migration path from the reference implementation.js projects</li> </ul>"},{"location":"user/reference/release-notes/#configuration-options","title":"\ud83d\udee0\ufe0f Configuration Options","text":"<p>Customize parsing behavior with <code>ParserOptions</code>:</p> <pre><code>use vexy_json::{parse_with_options, ParserOptions};\n\nlet mut options = ParserOptions::default();\noptions.allow_comments = false;           // Disable comments\noptions.allow_trailing_commas = false;    // Strict comma handling\noptions.allow_unquoted_keys = false;      // Require quoted keys\n\nlet result = parse_with_options(input, options)?;\n</code></pre>"},{"location":"user/reference/release-notes/#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>vexy_json is built with a clean, modular architecture:</p> <ul> <li>Lexer: High-performance tokenization with zero-copy strings</li> <li>Parser: Recursive descent parser with configurable grammar</li> <li>Value System: Rich JSON value representation with conversions</li> <li>Error Handling: Detailed error messages with position tracking</li> <li>Options System: Granular control over parsing features</li> </ul>"},{"location":"user/reference/release-notes/#whats-next","title":"\ud83d\udd2e What's Next?","text":"<p>This v1.0.0 release represents a stable, production-ready parser. Future development will focus on:</p> <ul> <li>Performance optimizations</li> <li>Additional forgiving features based on community feedback</li> <li>Enhanced error recovery mechanisms</li> <li>Extended ecosystem integration</li> </ul>"},{"location":"user/reference/release-notes/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! See our contributing guidelines for details on:</p> <ul> <li>Code style and standards</li> <li>Testing requirements</li> <li>Documentation expectations</li> <li>Community guidelines</li> </ul>"},{"location":"user/reference/release-notes/#license","title":"\ud83d\udcc4 License","text":"<p>Licensed under either of:</p> <ul> <li>Apache License, Version 2.0 (LICENSE-APACHE)</li> <li>MIT license (LICENSE-MIT)</li> </ul> <p>at your option.</p>"},{"location":"user/reference/release-notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>Special thanks to the the reference implementation.js project for the original implementation and design patterns that made this Rust port possible.</p>"},{"location":"user/reference/release-notes/#version-200-major-release","title":"\ud83d\ude80 Version 2.0.0 - Major Release","text":""},{"location":"user/reference/release-notes/#new-features","title":"\ud83c\udfaf New Features","text":""},{"location":"user/reference/release-notes/#streaming-parser-api","title":"Streaming Parser API","text":"<p>Process large JSON files incrementally without loading them entirely into memory:</p> <pre><code>use vexy_json::{StreamingParser, StreamingEvent};\n\nlet mut parser = StreamingParser::new();\nparser.feed(chunk1)?;\nparser.feed(chunk2)?;\nparser.finish()?;\n\nwhile let Some(event) = parser.next_event()? {\n    match event {\n        StreamingEvent::ObjectKey(key) =&gt; println!(\"Key: {}\", key),\n        StreamingEvent::String(s) =&gt; println!(\"Value: {}\", s),\n        _ =&gt; {}\n    }\n}\n</code></pre>"},{"location":"user/reference/release-notes/#parallel-processing","title":"Parallel Processing","text":"<p>Automatically process large files using multiple CPU cores:</p> <pre><code>use vexy_json::parse_parallel;\n\nlet json_files = vec![file1, file2, file3, file4];\nlet results = parse_parallel(json_files);\n</code></pre>"},{"location":"user/reference/release-notes/#plugin-system","title":"Plugin System","text":"<p>Extend vexy_json with custom functionality:</p> <pre><code>use vexy_json::{Plugin, parse_with_plugins};\n\nstruct MyPlugin;\nimpl Plugin for MyPlugin {\n    fn name(&amp;self) -&gt; &amp;str { \"my-plugin\" }\n    fn transform(&amp;self, value: &amp;mut Value) -&gt; Result&lt;(), Error&gt; {\n        // Custom transformation logic\n        Ok(())\n    }\n}\n\nlet plugins = vec![Box::new(MyPlugin)];\nlet value = parse_with_plugins(input, options, &amp;plugins)?;\n</code></pre>"},{"location":"user/reference/release-notes/#ndjson-support","title":"NDJSON Support","text":"<p>Native support for newline-delimited JSON:</p> <pre><code>use vexy_json::NdJsonParser;\n\nlet mut parser = NdJsonParser::new();\nlet values = parser.feed(ndjson_content)?;\n</code></pre>"},{"location":"user/reference/release-notes/#performance-improvements","title":"\u26a1 Performance Improvements","text":"<ul> <li>SIMD String Scanning: 2-3x faster string processing using vectorized operations</li> <li>Memory Pool V3: 80% reduction in allocations with typed arena allocators</li> <li>Parallel Chunking: Intelligent boundary detection for safe parallel parsing</li> <li>String Interning: Reduced memory usage for repeated JSON keys</li> <li>Zero-Copy Paths: Optimized paths for simple values avoid allocations</li> <li>FxHashMap: Faster hash map implementation for object parsing</li> </ul>"},{"location":"user/reference/release-notes/#cli-enhancements","title":"\ud83d\udee0\ufe0f CLI Enhancements","text":""},{"location":"user/reference/release-notes/#watch-mode","title":"Watch Mode","text":"<pre><code>vexy_json --watch config.json --output formatted.json\n</code></pre>"},{"location":"user/reference/release-notes/#batch-processing","title":"Batch Processing","text":"<pre><code>vexy_json --batch ./data/ --output-dir ./processed/ --parallel\n</code></pre>"},{"location":"user/reference/release-notes/#advanced-formatting","title":"Advanced Formatting","text":"<pre><code>vexy_json input.json --pretty --sort-keys --indent 4\n</code></pre>"},{"location":"user/reference/release-notes/#api-improvements","title":"\ud83d\udd27 API Improvements","text":"<ul> <li>Async Support: Future-ready async traits for streaming operations</li> <li>Better Error Context: Enhanced error messages with recovery suggestions</li> <li>Type-Safe Builders: Fluent API for constructing parser configurations</li> <li>Visitor Pattern: AST manipulation with the visitor pattern</li> <li>Event-Driven API: Fine-grained control over parsing events</li> </ul>"},{"location":"user/reference/release-notes/#benchmarks","title":"\ud83d\udcca Benchmarks","text":"Operation v1.0.0 v2.0.0 Improvement 1MB JSON Parse 8.5ms 3.2ms 2.7x faster 100MB JSON Stream 850ms 180ms 4.7x faster Memory Usage (1MB) 3.2MB 1.1MB 65% less Parallel 10x1MB 85ms 12ms 7.1x faster"},{"location":"user/reference/release-notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Fixed memory leak in deeply nested object parsing</li> <li>Resolved panic on malformed Unicode escapes</li> <li>Corrected trailing comma handling in strict mode</li> <li>Fixed thread safety issues in parallel parsing</li> <li>Resolved WASM binding memory alignment issues</li> </ul>"},{"location":"user/reference/release-notes/#breaking-changes","title":"\ud83d\udc94 Breaking Changes","text":"<p>While we've maintained backward compatibility for most APIs, some changes were necessary:</p> <ol> <li>Error Types: Error enum variants have been reorganized for better categorization</li> <li>Feature Flags: Some feature flags have been renamed for consistency</li> <li>WASM API: JavaScript API now uses camelCase consistently</li> </ol>"},{"location":"user/reference/release-notes/#dependency-updates","title":"\ud83d\udce6 Dependency Updates","text":"<ul> <li>Updated to <code>wasm-bindgen</code> 0.2.90</li> <li>Updated to <code>rayon</code> 1.8.0 for parallel processing</li> <li>Added <code>simd-json</code> for SIMD operations</li> <li>Added <code>crossbeam-channel</code> for streaming</li> </ul>"},{"location":"user/reference/release-notes/#known-issues","title":"\ud83d\udd0d Known Issues","text":"<ul> <li>Streaming parser doesn't yet support custom number parsing</li> <li>Plugin API is still experimental and may change</li> <li>Some SIMD optimizations require nightly Rust</li> </ul>"},{"location":"user/reference/release-notes/#acknowledgments_1","title":"\ud83d\ude4f Acknowledgments","text":"<p>Special thanks to all contributors who made this release possible, especially: - The Rust community for invaluable feedback - the reference implementation.js maintainers for the original inspiration - Our beta testers who helped identify edge cases</p> <p>Ready to upgrade? </p> <pre><code>cargo add vexy_json@2.0.0\n</code></pre> <p>For migration guidance, see our Migration Guide.</p> <p>Questions or feedback? Open an issue on GitHub.</p> <p>Happy parsing! \ud83e\udd80</p>"},{"location":"wasm/npm-package/","title":"@twardoch/vexy_json-wasm","text":"<p>WebAssembly bindings for vexy_json, a forgiving JSON parser that's a Rust port of the reference implementation.</p>"},{"location":"wasm/npm-package/#installation","title":"Installation","text":"<pre><code>npm install @twardoch/vexy_json-wasm\n</code></pre>"},{"location":"wasm/npm-package/#usage","title":"Usage","text":"<pre><code>import init, { parse_js, parse_with_options_js, is_valid, format } from '@twardoch/vexy_json-wasm';\n\n// Initialize the WASM module\nawait init();\n\n// Parse forgiving JSON\nconst result = parse_js('{ key: \"value\", trailing: true, }');\nconsole.log(result); // {\"key\":\"value\",\"trailing\":true}\n\n// Parse with custom options\nconst customResult = parse_with_options_js(\n  'key: value\\nkey2: value2',\n  true,  // allow_comments\n  true,  // allow_trailing_commas\n  true,  // allow_unquoted_keys\n  true,  // allow_single_quotes\n  true,  // implicit_top_level\n  true   // newline_as_comma\n);\nconsole.log(customResult); // {\"key\":\"value\",\"key2\":\"value2\"}\n\n// Check if input is valid\nconsole.log(is_valid('{\"valid\": true}')); // true\nconsole.log(is_valid('invalid json')); // false\n\n// Format JSON (parse and re-stringify)\nconst formatted = format('{ compact:true,data:[1,2,3] }');\nconsole.log(formatted); // {\"compact\":true,\"data\":[1,2,3]}\n</code></pre>"},{"location":"wasm/npm-package/#features","title":"Features","text":"<p>vexy_json supports all standard JSON features plus:</p> <ul> <li>Comments: Single-line (<code>//</code>) and multi-line (<code>/* */</code>)</li> <li>Trailing commas: In objects and arrays</li> <li>Unquoted keys: Object keys without quotes</li> <li>Single quotes: For string values</li> <li>Implicit top-level: <code>key: value</code> \u2192 <code>{\"key\": \"value\"}</code></li> <li>Newlines as commas: Line breaks can separate values</li> </ul>"},{"location":"wasm/npm-package/#api","title":"API","text":""},{"location":"wasm/npm-package/#parse_jsinput-string-string","title":"<code>parse_js(input: string): string</code>","text":"<p>Parse a JSON/Vexy JSON string with default options (all forgiving features enabled).</p>"},{"location":"wasm/npm-package/#parse_with_options_jsinput-string-options-string","title":"<code>parse_with_options_js(input: string, ...options): string</code>","text":"<p>Parse with custom options: - <code>allow_comments</code>: Enable single-line and multi-line comments - <code>allow_trailing_commas</code>: Allow trailing commas in arrays and objects - <code>allow_unquoted_keys</code>: Allow unquoted object keys - <code>allow_single_quotes</code>: Allow single-quoted strings - <code>implicit_top_level</code>: Convert top-level non-arrays/objects to valid JSON - <code>newline_as_comma</code>: Treat newlines as commas</p>"},{"location":"wasm/npm-package/#is_validinput-string-boolean","title":"<code>is_valid(input: string): boolean</code>","text":"<p>Check if the input is valid JSON/Vexy JSON.</p>"},{"location":"wasm/npm-package/#formatinput-string-string","title":"<code>format(input: string): string</code>","text":"<p>Parse and re-stringify JSON/Vexy JSON (currently outputs compact JSON).</p>"},{"location":"wasm/npm-package/#license","title":"License","text":"<p>MIT OR Apache-2.0</p>"}]}